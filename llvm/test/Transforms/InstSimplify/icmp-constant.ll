; NOTE: Assertions have been autogenerated by utils/update_test_checks.py
; RUN: opt < %s -instsimplify -S | FileCheck %s

; Fold icmp with a constant operand.

define i1 @tautological_ule(i8 %x) {
; CHECK-LABEL: @tautological_ule(
; CHECK-NEXT:    ret i1 true
;
  %cmp = icmp ule i8 %x, 255
  ret i1 %cmp
}

define i1 @tautological_ugt(i8 %x) {
; CHECK-LABEL: @tautological_ugt(
; CHECK-NEXT:    ret i1 false
;
  %cmp = icmp ugt i8 %x, 255
  ret i1 %cmp
}

; 'urem x, C2' produces [0, C2)
define i1 @urem3(i32 %X) {
; CHECK-LABEL: @urem3(
; CHECK-NEXT:    ret i1 true
;
  %A = urem i32 %X, 10
  %B = icmp ult i32 %A, 15
  ret i1 %B
}

;'srem x, C2' produces (-|C2|, |C2|)
define i1 @srem1(i32 %X) {
; CHECK-LABEL: @srem1(
; CHECK-NEXT:    ret i1 false
;
  %A = srem i32 %X, -5
  %B = icmp sgt i32 %A, 5
  ret i1 %B
}

;'udiv C2, x' produces [0, C2]
define i1 @udiv5(i32 %X) {
; CHECK-LABEL: @udiv5(
; CHECK-NEXT:    ret i1 false
;
  %A = udiv i32 123, %X
  %C = icmp ugt i32 %A, 124
  ret i1 %C
}

; 'udiv x, C2' produces [0, UINT_MAX / C2]
define i1 @udiv1(i32 %X) {
; CHECK-LABEL: @udiv1(
; CHECK-NEXT:    ret i1 true
;
  %A = udiv i32 %X, 1000000
  %B = icmp ult i32 %A, 5000
  ret i1 %B
}

; 'sdiv C2, x' produces [-|C2|, |C2|]
define i1 @compare_dividend(i32 %a) {
; CHECK-LABEL: @compare_dividend(
; CHECK-NEXT:    ret i1 false
;
  %div = sdiv i32 2, %a
  %cmp = icmp eq i32 %div, 3
  ret i1 %cmp
}

; 'sdiv x, C2' produces [INT_MIN / C2, INT_MAX / C2]
;    where C2 != -1 and C2 != 0 and C2 != 1
define i1 @sdiv1(i32 %X) {
; CHECK-LABEL: @sdiv1(
; CHECK-NEXT:    ret i1 true
;
  %A = sdiv i32 %X, 1000000
  %B = icmp slt i32 %A, 3000
  ret i1 %B
}

; 'shl nuw C2, x' produces [C2, C2 << CLZ(C2)]
define i1 @shl5(i32 %X) {
; CHECK-LABEL: @shl5(
; CHECK-NEXT:    ret i1 true
;
  %sub = shl nuw i32 4, %X
  %cmp = icmp ugt i32 %sub, 3
  ret i1 %cmp
}

; 'shl nsw C2, x' produces [C2 << CLO(C2)-1, C2]
define i1 @shl2(i32 %X) {
; CHECK-LABEL: @shl2(
; CHECK-NEXT:    ret i1 false
;
  %sub = shl nsw i32 -1, %X
  %cmp = icmp eq i32 %sub, 31
  ret i1 %cmp
}

; 'shl nsw C2, x' produces [C2 << CLO(C2)-1, C2]
define i1 @shl4(i32 %X) {
; CHECK-LABEL: @shl4(
; CHECK-NEXT:    ret i1 true
;
  %sub = shl nsw i32 -1, %X
  %cmp = icmp sle i32 %sub, -1
  ret i1 %cmp
}

; 'shl nsw C2, x' produces [C2, C2 << CLZ(C2)-1]
define i1 @icmp_shl_nsw_1(i64 %a) {
; CHECK-LABEL: @icmp_shl_nsw_1(
; CHECK-NEXT:    ret i1 true
;
  %shl = shl nsw i64 1, %a
  %cmp = icmp sge i64 %shl, 0
  ret i1 %cmp
}

; 'shl nsw C2, x' produces [C2 << CLO(C2)-1, C2]
define i1 @icmp_shl_nsw_neg1(i64 %a) {
; CHECK-LABEL: @icmp_shl_nsw_neg1(
; CHECK-NEXT:    ret i1 false
;
  %shl = shl nsw i64 -1, %a
  %cmp = icmp sge i64 %shl, 3
  ret i1 %cmp
}

; 'lshr x, C2' produces [0, UINT_MAX >> C2]
define i1 @lshr2(i32 %x) {
; CHECK-LABEL: @lshr2(
; CHECK-NEXT:    ret i1 false
;
  %s = lshr i32 %x, 30
  %c = icmp ugt i32 %s, 8
  ret i1 %c
}

; 'lshr C2, x' produces [C2 >> (Width-1), C2]
define i1 @exact_lshr_ugt_false(i32 %a) {
; CHECK-LABEL: @exact_lshr_ugt_false(
; CHECK-NEXT:    ret i1 false
;
  %shr = lshr exact i32 30, %a
  %cmp = icmp ult i32 %shr, 15
  ret i1 %cmp
}

; 'lshr C2, x' produces [C2 >> (Width-1), C2]
define i1 @lshr_sgt_false(i32 %a) {
; CHECK-LABEL: @lshr_sgt_false(
; CHECK-NEXT:    ret i1 false
;
  %shr = lshr i32 1, %a
  %cmp = icmp sgt i32 %shr, 1
  ret i1 %cmp
}

; 'ashr x, C2' produces [INT_MIN >> C2, INT_MAX >> C2]
define i1 @ashr2(i32 %x) {
; CHECK-LABEL: @ashr2(
; CHECK-NEXT:    ret i1 false
;
  %s = ashr i32 %x, 30
  %c = icmp slt i32 %s, -5
  ret i1 %c
}

; 'ashr C2, x' produces [C2, C2 >> (Width-1)]
define i1 @ashr_sgt_false(i32 %a) {
; CHECK-LABEL: @ashr_sgt_false(
; CHECK-NEXT:    ret i1 false
;
  %shr = ashr i32 -30, %a
  %cmp = icmp sgt i32 %shr, -1
  ret i1 %cmp
}

; 'ashr C2, x' produces [C2, C2 >> (Width-1)]
define i1 @exact_ashr_sgt_false(i32 %a) {
; CHECK-LABEL: @exact_ashr_sgt_false(
; CHECK-NEXT:    ret i1 false
;
  %shr = ashr exact i32 -30, %a
  %cmp = icmp sgt i32 %shr, -15
  ret i1 %cmp
}

; 'or x, C2' produces [C2, UINT_MAX]
define i1 @or1(i32 %X) {
; CHECK-LABEL: @or1(
; CHECK-NEXT:    ret i1 false
;
  %A = or i32 %X, 62
  %B = icmp ult i32 %A, 50
  ret i1 %B
}

; 'and x, C2' produces [0, C2]
define i1 @and1(i32 %X) {
; CHECK-LABEL: @and1(
; CHECK-NEXT:    ret i1 false
;
  %A = and i32 %X, 62
  %B = icmp ugt i32 %A, 70
  ret i1 %B
}

; 'add nuw x, C2' produces [C2, UINT_MAX]
define i1 @tautological9(i32 %x) {
; CHECK-LABEL: @tautological9(
; CHECK-NEXT:    ret i1 true
;
  %add = add nuw i32 %x, 13
  %cmp = icmp ne i32 %add, 12
  ret i1 %cmp
}

