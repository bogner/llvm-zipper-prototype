# RUN: llc -march=x86 -run-pass machine-cp -o /dev/null %s 2>&1 | FileCheck %s

--- |
  declare void @foo()
  define void @copyprop_remove_kill0() { ret void }
  define void @copyprop_remove_kill1() { ret void }
  define void @copyprop_remove_kill2() { ret void }
  define void @copyprop0() { ret void }
  define void @nocopyprop0() { ret void }
  define void @nocopyprop1() { ret void }
...
---
# The second copy is redundant and will be removed, check that we also remove
# the kill flag of intermediate instructions.
# CHECK-LABEL: name: copyprop_remove_kill0
# CHECK: bb.0:
# CHECK-NEXT: %rax = COPY %rdi
# CHECK-NEXT: NOOP implicit %rdi
# CHECK-NOT: COPY
# CHECK-NEXT: NOOP implicit %rax, implicit %rdi
name: copyprop_remove_kill0
body: |
  bb.0:
    %rax = COPY %rdi
    NOOP implicit killed %rdi
    %rdi = COPY %rax
    NOOP implicit %rax, implicit %rdi
...
---
# The second copy is redundant and will be removed, check that we also remove
# the kill flag of intermediate instructions.
# CHECK-LABEL: name: copyprop_remove_kill1
# CHECK: bb.0:
# CHECK-NEXT: %rax = COPY %rdi
# CHECK-NEXT: NOOP implicit %edi
# CHECK-NOT: COPY
# CHECK-NEXT: NOOP implicit %rax, implicit %rdi
name: copyprop_remove_kill1
body: |
  bb.0:
    %rax = COPY %rdi
    NOOP implicit killed %edi
    %rdi = COPY %rax
    NOOP implicit %rax, implicit %rdi
...
---
# The second copy is redundant and will be removed, check that we also remove
# the kill flag of intermediate instructions.
# CHECK-LABEL: name: copyprop_remove_kill2
# CHECK: bb.0:
# CHECK-NEXT: %ax = COPY %di
# CHECK-NEXT: NOOP implicit %rdi
# CHECK-NOT: COPY
# CHECK-NEXT: NOOP implicit %rax, implicit %rdi
name: copyprop_remove_kill2
body: |
  bb.0:
    %ax = COPY %di
    NOOP implicit killed %rdi
    %di = COPY %ax
    NOOP implicit %rax, implicit %rdi
...
---
# The second copy is redundant; the call preserves the source and dest register.
# CHECK-LABEL: name: copyprop0
# CHECK: bb.0:
# CHECK-NEXT: %rax = COPY %rdi
# CHECK-NEXT: CALL64pcrel32 @foo, csr_64_rt_mostregs
# CHECK-NEXT: NOOP implicit %edi
# CHECK-NOT: COPY
# CHECK-NEXT: NOOP implicit %rax, implicit %rdi
name: copyprop0
body: |
  bb.0:
    %rax = COPY %rdi
    CALL64pcrel32 @foo, csr_64_rt_mostregs
    NOOP implicit killed %edi
    %rdi = COPY %rax
    NOOP implicit %rax, implicit %rdi
...
---
# The second copy is not redundant if the source register (%rax) is clobbered
# even if the dest (%rbp) is not.
# CHECK-LABEL: name: nocopyprop0
# CHECK: bb.0:
# CHECK-NEXT: %rax = COPY %rbp
# CHECK-NEXT: CALL64pcrel32 @foo, csr_64, implicit %rax, implicit %rbp
# CHECK-NEXT: %rbp = COPY %rax
# CHECK-NEXT: NOOP implicit %rax, implicit %rbp
name: nocopyprop0
body: |
  bb.0:
    %rax = COPY %rbp
    CALL64pcrel32 @foo, csr_64, implicit %rax, implicit %rbp
    %rbp = COPY %rax
    NOOP implicit %rax, implicit %rbp
...
---
# The second copy is not redundant if the dest register (%rax) is clobbered
# even if the source (%rbp) is not.
# CHECK-LABEL: name: nocopyprop1
# CHECK: bb.0:
# CHECK-NEXT: %rbp = COPY %rax
# CHECK-NEXT: CALL64pcrel32 @foo, csr_64, implicit %rax, implicit %rbp
# CHECK-NEXT: %rax = COPY %rbp
# CHECK-NEXT: NOOP implicit %rax, implicit %rbp
name: nocopyprop1
body: |
  bb.0:
    %rbp = COPY %rax
    CALL64pcrel32 @foo, csr_64, implicit %rax, implicit %rbp
    %rax = COPY %rbp
    NOOP implicit %rax, implicit %rbp
...
