; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mcpu=atom -mtriple=x86_64-unknown-linux-gnu | FileCheck %s
; RUN: llc < %s -mcpu=sandybridge -mtriple=x86_64-unknown-linux-gnu | FileCheck %s -check-prefix=SNB

; Additional tests for 64-bit divide bypass

define i64 @Test_get_quotient(i64 %a, i64 %b) nounwind {
; CHECK-LABEL: Test_get_quotient:
; CHECK:       # BB#0:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; CHECK-NEXT:    orq %rsi, %rax
; CHECK-NEXT:    testq %rcx, %rax
; CHECK-NEXT:    je .LBB0_1
; CHECK-NEXT:  # BB#2:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    cqto
; CHECK-NEXT:    idivq %rsi
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB0_1:
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    divl %esi
; CHECK-NEXT:    # kill: %EAX<def> %EAX<kill> %RAX<def>
; CHECK-NEXT:    retq
;
; SNB-LABEL: Test_get_quotient:
; SNB:       # BB#0:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    orq %rsi, %rax
; SNB-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; SNB-NEXT:    testq %rcx, %rax
; SNB-NEXT:    je .LBB0_1
; SNB-NEXT:  # BB#2:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    cqto
; SNB-NEXT:    idivq %rsi
; SNB-NEXT:    retq
; SNB-NEXT:  .LBB0_1:
; SNB-NEXT:    xorl %edx, %edx
; SNB-NEXT:    movl %edi, %eax
; SNB-NEXT:    divl %esi
; SNB-NEXT:    # kill: %EAX<def> %EAX<kill> %RAX<def>
; SNB-NEXT:    retq
  %result = sdiv i64 %a, %b
  ret i64 %result
}

define i64 @Test_get_remainder(i64 %a, i64 %b) nounwind {
; CHECK-LABEL: Test_get_remainder:
; CHECK:       # BB#0:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; CHECK-NEXT:    orq %rsi, %rax
; CHECK-NEXT:    testq %rcx, %rax
; CHECK-NEXT:    je .LBB1_1
; CHECK-NEXT:  # BB#2:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    cqto
; CHECK-NEXT:    idivq %rsi
; CHECK-NEXT:    movq %rdx, %rax
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB1_1:
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    divl %esi
; CHECK-NEXT:    # kill: %EDX<def> %EDX<kill> %RDX<def>
; CHECK-NEXT:    movq %rdx, %rax
; CHECK-NEXT:    retq
;
; SNB-LABEL: Test_get_remainder:
; SNB:       # BB#0:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    orq %rsi, %rax
; SNB-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; SNB-NEXT:    testq %rcx, %rax
; SNB-NEXT:    je .LBB1_1
; SNB-NEXT:  # BB#2:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    cqto
; SNB-NEXT:    idivq %rsi
; SNB-NEXT:    movq %rdx, %rax
; SNB-NEXT:    retq
; SNB-NEXT:  .LBB1_1:
; SNB-NEXT:    xorl %edx, %edx
; SNB-NEXT:    movl %edi, %eax
; SNB-NEXT:    divl %esi
; SNB-NEXT:    # kill: %EDX<def> %EDX<kill> %RDX<def>
; SNB-NEXT:    movq %rdx, %rax
; SNB-NEXT:    retq
  %result = srem i64 %a, %b
  ret i64 %result
}

define i64 @Test_get_quotient_and_remainder(i64 %a, i64 %b) nounwind {
; CHECK-LABEL: Test_get_quotient_and_remainder:
; CHECK:       # BB#0:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; CHECK-NEXT:    orq %rsi, %rax
; CHECK-NEXT:    testq %rcx, %rax
; CHECK-NEXT:    je .LBB2_1
; CHECK-NEXT:  # BB#2:
; CHECK-NEXT:    movq %rdi, %rax
; CHECK-NEXT:    cqto
; CHECK-NEXT:    idivq %rsi
; CHECK-NEXT:    addq %rdx, %rax
; CHECK-NEXT:    retq
; CHECK-NEXT:  .LBB2_1:
; CHECK-NEXT:    xorl %edx, %edx
; CHECK-NEXT:    movl %edi, %eax
; CHECK-NEXT:    divl %esi
; CHECK-NEXT:    # kill: %EAX<def> %EAX<kill> %RAX<def>
; CHECK-NEXT:    # kill: %EDX<def> %EDX<kill> %RDX<def>
; CHECK-NEXT:    addq %rdx, %rax
; CHECK-NEXT:    retq
;
; SNB-LABEL: Test_get_quotient_and_remainder:
; SNB:       # BB#0:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    orq %rsi, %rax
; SNB-NEXT:    movabsq $-4294967296, %rcx # imm = 0xFFFFFFFF00000000
; SNB-NEXT:    testq %rcx, %rax
; SNB-NEXT:    je .LBB2_1
; SNB-NEXT:  # BB#2:
; SNB-NEXT:    movq %rdi, %rax
; SNB-NEXT:    cqto
; SNB-NEXT:    idivq %rsi
; SNB-NEXT:    addq %rdx, %rax
; SNB-NEXT:    retq
; SNB-NEXT:  .LBB2_1:
; SNB-NEXT:    xorl %edx, %edx
; SNB-NEXT:    movl %edi, %eax
; SNB-NEXT:    divl %esi
; SNB-NEXT:    # kill: %EDX<def> %EDX<kill> %RDX<def>
; SNB-NEXT:    # kill: %EAX<def> %EAX<kill> %RAX<def>
; SNB-NEXT:    addq %rdx, %rax
; SNB-NEXT:    retq
  %resultdiv = sdiv i64 %a, %b
  %resultrem = srem i64 %a, %b
  %result = add i64 %resultdiv, %resultrem
  ret i64 %result
}
