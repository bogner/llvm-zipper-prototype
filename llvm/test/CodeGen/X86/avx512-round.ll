; NOTE: Assertions have been autogenerated by utils/update_llc_test_checks.py
; RUN: llc < %s -mtriple=x86_64-apple-darwin -mcpu=knl --show-mc-encoding| FileCheck %s

define <16 x float> @floor_v16f32(<16 x float> %a) {
; CHECK-LABEL: floor_v16f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaleps $9, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0x7d,0x48,0x08,0xc0,0x09]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <16 x float> @llvm.floor.v16f32(<16 x float> %a)
  ret <16 x float> %res
}
declare <16 x float> @llvm.floor.v16f32(<16 x float> %p)

define <8 x double> @floor_v8f64(<8 x double> %a) {
; CHECK-LABEL: floor_v8f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalepd $9, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0xfd,0x48,0x09,0xc0,0x09]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <8 x double> @llvm.floor.v8f64(<8 x double> %a)
  ret <8 x double> %res
}
declare <8 x double> @llvm.floor.v8f64(<8 x double> %p)

define <16 x float> @ceil_v16f32(<16 x float> %a) {
; CHECK-LABEL: ceil_v16f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaleps $10, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0x7d,0x48,0x08,0xc0,0x0a]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <16 x float> @llvm.ceil.v16f32(<16 x float> %a)
  ret <16 x float> %res
}
declare <16 x float> @llvm.ceil.v16f32(<16 x float> %p)

define <8 x double> @ceil_v8f64(<8 x double> %a) {
; CHECK-LABEL: ceil_v8f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalepd $10, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0xfd,0x48,0x09,0xc0,0x0a]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <8 x double> @llvm.ceil.v8f64(<8 x double> %a)
  ret <8 x double> %res
}
declare <8 x double> @llvm.ceil.v8f64(<8 x double> %p)

define <16 x float> @trunc_v16f32(<16 x float> %a) {
; CHECK-LABEL: trunc_v16f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaleps $11, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0x7d,0x48,0x08,0xc0,0x0b]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <16 x float> @llvm.trunc.v16f32(<16 x float> %a)
  ret <16 x float> %res
}
declare <16 x float> @llvm.trunc.v16f32(<16 x float> %p)

define <8 x double> @trunc_v8f64(<8 x double> %a) {
; CHECK-LABEL: trunc_v8f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalepd $11, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0xfd,0x48,0x09,0xc0,0x0b]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <8 x double> @llvm.trunc.v8f64(<8 x double> %a)
  ret <8 x double> %res
}
declare <8 x double> @llvm.trunc.v8f64(<8 x double> %p)

define <16 x float> @rint_v16f32(<16 x float> %a) {
; CHECK-LABEL: rint_v16f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaleps $4, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0x7d,0x48,0x08,0xc0,0x04]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <16 x float> @llvm.rint.v16f32(<16 x float> %a)
  ret <16 x float> %res
}
declare <16 x float> @llvm.rint.v16f32(<16 x float> %p)

define <8 x double> @rint_v8f64(<8 x double> %a) {
; CHECK-LABEL: rint_v8f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalepd $4, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0xfd,0x48,0x09,0xc0,0x04]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <8 x double> @llvm.rint.v8f64(<8 x double> %a)
  ret <8 x double> %res
}
declare <8 x double> @llvm.rint.v8f64(<8 x double> %p)

define <16 x float> @nearbyint_v16f32(<16 x float> %a) {
; CHECK-LABEL: nearbyint_v16f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaleps $12, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0x7d,0x48,0x08,0xc0,0x0c]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <16 x float> @llvm.nearbyint.v16f32(<16 x float> %a)
  ret <16 x float> %res
}
declare <16 x float> @llvm.nearbyint.v16f32(<16 x float> %p)

define <8 x double> @nearbyint_v8f64(<8 x double> %a) {
; CHECK-LABEL: nearbyint_v8f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalepd $12, %zmm0, %zmm0 ## encoding: [0x62,0xf3,0xfd,0x48,0x09,0xc0,0x0c]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call <8 x double> @llvm.nearbyint.v8f64(<8 x double> %a)
  ret <8 x double> %res
}
declare <8 x double> @llvm.nearbyint.v8f64(<8 x double> %p)

define double @nearbyint_f64(double %a) {
; CHECK-LABEL: nearbyint_f64:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscalesd $12, %xmm0, %xmm0, %xmm0 ## encoding: [0x62,0xf3,0xfd,0x08,0x0b,0xc0,0x0c]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call double @llvm.nearbyint.f64(double %a)
  ret double %res
}
declare double @llvm.nearbyint.f64(double %p)

define float @floor_f32(float %a) {
; CHECK-LABEL: floor_f32:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaless $9, %xmm0, %xmm0, %xmm0 ## encoding: [0x62,0xf3,0x7d,0x08,0x0a,0xc0,0x09]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %res = call float @llvm.floor.f32(float %a)
  ret float %res
}
declare float @llvm.floor.f32(float %p)

define float @floor_f32m(float* %aptr) {
; CHECK-LABEL: floor_f32m:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vmovss (%rdi), %xmm0 ## EVEX TO VEX Compression encoding: [0xc5,0xfa,0x10,0x07]
; CHECK-NEXT:    ## xmm0 = mem[0],zero,zero,zero
; CHECK-NEXT:    vrndscaless $9, %xmm0, %xmm0, %xmm0 ## encoding: [0x62,0xf3,0x7d,0x08,0x0a,0xc0,0x09]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = load float, float* %aptr, align 4
  %res = call float @llvm.floor.f32(float %a)
  ret float %res
}

define float @floor_f32m_optsize(float* %aptr) optsize {
; CHECK-LABEL: floor_f32m_optsize:
; CHECK:       ## BB#0:
; CHECK-NEXT:    vrndscaless $9, (%rdi), %xmm0, %xmm0 ## encoding: [0x62,0xf3,0x7d,0x08,0x0a,0x07,0x09]
; CHECK-NEXT:    retq ## encoding: [0xc3]
  %a = load float, float* %aptr, align 4
  %res = call float @llvm.floor.f32(float %a)
  ret float %res
}

