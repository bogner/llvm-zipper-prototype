# RUN: llc -O0 -run-pass=regbankselect -global-isel %s -o - 2>&1 | FileCheck %s
# REQUIRES: global-isel

--- |
  ; ModuleID = 'generic-virtual-registers-type-error.mir'
  target datalayout = "e-m:o-i64:64-i128:128-n32:64-S128"
  target triple = "aarch64-apple-ios"
  define void @defaultMapping() {
  entry:
    ret void
  }
  define void @defaultMappingVector() {
  entry:
    ret void
  }
  define void @defaultMapping1Repair() {
  entry:
    ret void
  }
  define void @defaultMapping2Repairs() {
  entry:
    ret void
  }
  define void @defaultMappingDefRepair() {
  entry:
    ret void
  }
...

---
# Check that we assign a relevant register bank for %0.
# Based on the type i32, this should be gpr.
name:            defaultMapping
isSSA:           true
# CHECK:      registers:
# CHECK-NEXT:   - { id: 0, class: gpr }
registers:
  - { id: 0, class: _ }
body: |
  bb.0.entry:
    liveins: %x0
    ; CHECK:      %0(32) = G_ADD i32 %x0
    %0(32) = G_ADD i32 %x0, %x0
...

---
# Check that we assign a relevant register bank for %0.
# Based on the type <2 x i32>, this should be fpr.
# FPR is used for both floating point and vector registers.
name:            defaultMappingVector
isSSA:           true
# CHECK:      registers:
# CHECK-NEXT:   - { id: 0, class: fpr }
registers:
  - { id: 0, class: _ }
body: |
  bb.0.entry:
    liveins: %d0
    ; CHECK:      %0(32) = G_ADD <2 x i32> %d0
    %0(32) = G_ADD <2 x i32> %d0, %d0
...

---
# Check that we repair the assignment for %0.
# Indeed based on the source of the copy it should live
# in FPR, but at the use, it should be GPR.
name:            defaultMapping1Repair
isSSA:           true
# CHECK:      registers:
# CHECK-NEXT:   - { id: 0, class: fpr }
# CHECK-NEXT:   - { id: 1, class: gpr }
# CHECK-NEXT:   - { id: 2, class: gpr }
registers:
  - { id: 0, class: _ }
  - { id: 1, class: _ }
body: |
  bb.0.entry:
    liveins: %s0, %x0
    ; CHECK:           %0(32) = COPY %s0
    ; CHECK-NEXT:      %2(32) = COPY %0
    ; CHECK-NEXT:      %1(32) = G_ADD i32 %2, %x0
    %0(32) = COPY %s0
    %1(32) = G_ADD i32 %0, %x0
...

# Check that we repair the assignment for %0 differently for both uses.
name:            defaultMapping2Repairs
isSSA:           true
# CHECK:      registers:
# CHECK-NEXT:   - { id: 0, class: fpr }
# CHECK-NEXT:   - { id: 1, class: gpr }
# CHECK-NEXT:   - { id: 2, class: gpr }
# CHECK-NEXT:   - { id: 3, class: gpr }
registers:
  - { id: 0, class: _ }
  - { id: 1, class: _ }
body: |
  bb.0.entry:
    liveins: %s0, %x0
    ; CHECK:           %0(32) = COPY %s0
    ; CHECK-NEXT:      %2(32) = COPY %0
    ; CHECK-NEXT:      %3(32) = COPY %0
    ; CHECK-NEXT:      %1(32) = G_ADD i32 %2, %3
    %0(32) = COPY %s0
    %1(32) = G_ADD i32 %0, %0
...

---
# Check that we repair the definition of %1.
# %1 is forced to be into FPR, but its definition actually
# requires that it lives in GPR. Make sure regbankselect
# fixes that.
name:            defaultMappingDefRepair
isSSA:           true
# CHECK:      registers:
# CHECK-NEXT:   - { id: 0, class: gpr }
# CHECK-NEXT:   - { id: 1, class: fpr }
# CHECK-NEXT:   - { id: 2, class: gpr }
registers:
  - { id: 0, class: _ }
  - { id: 1, class: fpr }
body: |
  bb.0.entry:
    liveins: %w0
    ; CHECK:           %0(32) = COPY %w0
    ; CHECK-NEXT:      %2(32) = G_ADD i32 %0, %w0
    ; CHECK-NEXT:      %1(32) = COPY %2
    %0(32) = COPY %w0
    %1(32) = G_ADD i32 %0, %w0
...
