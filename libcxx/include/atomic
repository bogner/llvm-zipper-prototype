// -*- C++ -*-
//===--------------------------- atomic -----------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_ATOMIC
#define _LIBCPP_ATOMIC

/*
    atomic synopsis

namespace std
{

// order and consistency

typedef enum memory_order
{
    memory_order_relaxed,
    memory_order_consume,  // load-consume
    memory_order_acquire,  // load-acquire
    memory_order_release,  // store-release
    memory_order_acq_rel,  // store-release load-acquire
    memory_order_seq_cst   // store-release load-acquire
} memory_order;

template <class T> T kill_dependency(T y);

// lock-free property

#define ATOMIC_CHAR_LOCK_FREE unspecified
#define ATOMIC_CHAR16_T_LOCK_FREE unspecified
#define ATOMIC_CHAR32_T_LOCK_FREE unspecified
#define ATOMIC_WCHAR_T_LOCK_FREE unspecified
#define ATOMIC_SHORT_LOCK_FREE unspecified
#define ATOMIC_INT_LOCK_FREE unspecified
#define ATOMIC_LONG_LOCK_FREE unspecified
#define ATOMIC_LLONG_LOCK_FREE unspecified
#define ATOMIC_ADDRESS_LOCK_FREE unspecified

// flag type and operations

typedef struct atomic_flag
{
    bool test_and_set(memory_order = memory_order_seq_cst) volatile;
    bool test_and_set(memory_order = memory_order_seq_cst);
    void clear(memory_order = memory_order_seq_cst) volatile;
    void clear(memory_order = memory_order_seq_cst);
    atomic_flag() = default;
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
} atomic_flag;

bool atomic_flag_test_and_set(volatile atomic_flag*);
bool atomic_flag_test_and_set(atomic_flag*);
bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order);
bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order);
void atomic_flag_clear(volatile atomic_flag*);
void atomic_flag_clear(atomic_flag*);
void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order);
void atomic_flag_clear_explicit(atomic_flag*, memory_order);

#define ATOMIC_FLAG_INIT see below
#define ATOMIC_VAR_INIT(value) see below

// atomic_bool

typedef struct atomic_bool
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(bool, memory_order = memory_order_seq_cst) volatile;
    void store(bool, memory_order = memory_order_seq_cst);
    bool load(memory_order = memory_order_seq_cst) const volatile;
    bool load(memory_order = memory_order_seq_cst) const;
    operator bool() const volatile;
    operator bool() const;
    bool exchange(bool, memory_order = memory_order_seq_cst) volatile;
    bool exchange(bool, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(bool&, bool, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(bool&, bool, memory_order, memory_order);
    bool compare_exchange_strong(bool&, bool, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(bool&, bool, memory_order, memory_order);
    bool compare_exchange_weak(bool&, bool,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(bool&, bool,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(bool&, bool,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(bool&, bool,
                                 memory_order = memory_order_seq_cst);
    atomic_bool() = default;
    constexpr atomic_bool(bool);
    atomic_bool(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) volatile = delete;
    bool operator=(bool) volatile;
    bool operator=(bool);
} atomic_bool;

bool atomic_is_lock_free(const volatile atomic_bool*);
bool atomic_is_lock_free(const atomic_bool*);
void atomic_init(volatile atomic_bool*, bool);
void atomic_init(atomic_bool*, bool);
void atomic_store(volatile atomic_bool*, bool);
void atomic_store(atomic_bool*, bool);
void atomic_store_explicit(volatile atomic_bool*, bool, memory_order);
void atomic_store_explicit(atomic_bool*, bool, memory_order);
bool atomic_load(const volatile atomic_bool*);
bool atomic_load(const atomic_bool*);
bool atomic_load_explicit(const volatile atomic_bool*, memory_order);
bool atomic_load_explicit(const atomic_bool*, memory_order);
bool atomic_exchange(volatile atomic_bool*, bool);
bool atomic_exchange(atomic_bool*, bool);
bool atomic_exchange_explicit(volatile atomic_bool*, bool, memory_order);
bool atomic_exchange_explicit(atomic_bool*, bool, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_bool*, bool*, bool);
bool atomic_compare_exchange_weak(atomic_bool*, bool*, bool);
bool atomic_compare_exchange_strong(volatile atomic_bool*, bool*, bool);
bool atomic_compare_exchange_strong(atomic_bool*, bool*, bool);
bool atomic_compare_exchange_weak_explicit(volatile atomic_bool*, bool*, bool,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_bool*, bool*, bool,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_bool*, bool*, bool,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_bool*, bool*, bool,
                                             memory_order, memory_order);

// atomic_char

typedef struct atomic_char
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(char, memory_order = memory_order_seq_cst) volatile;
    void store(char, memory_order = memory_order_seq_cst);
    char load(memory_order = memory_order_seq_cst) const volatile;
    char load(memory_order = memory_order_seq_cst) const;
    operator char() const volatile;
    operator char() const;
    char exchange(char, memory_order = memory_order_seq_cst) volatile;
    char exchange(char, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(char&, char, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(char&, char, memory_order, memory_order);
    bool compare_exchange_strong(char&, char, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(char&, char, memory_order, memory_order);
    bool compare_exchange_weak(char&, char,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(char&, char,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(char&, char,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(char&, char,
                                 memory_order = memory_order_seq_cst);
    char fetch_add(char, memory_order = memory_order_seq_cst) volatile;
    char fetch_add(char, memory_order = memory_order_seq_cst);
    char fetch_sub(char, memory_order = memory_order_seq_cst) volatile;
    char fetch_sub(char, memory_order = memory_order_seq_cst);
    char fetch_and(char, memory_order = memory_order_seq_cst) volatile;
    char fetch_and(char, memory_order = memory_order_seq_cst);
    char fetch_or(char, memory_order = memory_order_seq_cst) volatile;
    char fetch_or(char, memory_order = memory_order_seq_cst);
    char fetch_xor(char, memory_order = memory_order_seq_cst) volatile;
    char fetch_xor(char, memory_order = memory_order_seq_cst);
    atomic_char() = default;
    constexpr atomic_char(char);
    atomic_char(const atomic_char&) = delete;
    atomic_char& operator=(const atomic_char&) = delete;
    atomic_char& operator=(const atomic_char&) volatile = delete;
    char operator=(char) volatile;
    char operator=(char);
    char operator++(int) volatile;
    char operator++(int);
    char operator--(int) volatile;
    char operator--(int);
    char operator++() volatile;
    char operator++();
    char operator--() volatile;
    char operator--();
    char operator+=(char) volatile;
    char operator+=(char);
    char operator-=(char) volatile;
    char operator-=(char);
    char operator&=(char) volatile;
    char operator&=(char);
    char operator|=(char) volatile;
    char operator|=(char);
    char operator^=(char) volatile;
    char operator^=(char);
} atomic_char;

bool atomic_is_lock_free(const volatile atomic_char*);
bool atomic_is_lock_free(const atomic_char*);
void atomic_init(volatile atomic_char*, char);
void atomic_init(atomic_char*, char);
void atomic_store(volatile atomic_char*, char);
void atomic_store(atomic_char*, char);
void atomic_store_explicit(volatile atomic_char*, char, memory_order);
void atomic_store_explicit(atomic_char*, char, memory_order);
char atomic_load(const volatile atomic_char*);
char atomic_load(const atomic_char*);
char atomic_load_explicit(const volatile atomic_char*, memory_order);
char atomic_load_explicit(const atomic_char*, memory_order);
char atomic_exchange(volatile atomic_char*, char);
char atomic_exchange(atomic_char*, char);
char atomic_exchange_explicit(volatile atomic_char*, char, memory_order);
char atomic_exchange_explicit(atomic_char*, char, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char*, char*, char);
bool atomic_compare_exchange_weak(atomic_char*, char*, char);
bool atomic_compare_exchange_strong(volatile atomic_char*, char*, char);
bool atomic_compare_exchange_strong(atomic_char*, char*, char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char*, char*, char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char*, char*, char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char*, char*, char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char*, char*, char,
                                             memory_order, memory_order);
char atomic_fetch_add(volatile atomic_char*, char);
char atomic_fetch_add(atomic_char*, char);
char atomic_fetch_add_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_add_explicit(atomic_char*, char, memory_order);
char atomic_fetch_sub(volatile atomic_char*, char);
char atomic_fetch_sub(atomic_char*, char);
char atomic_fetch_sub_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_sub_explicit(atomic_char*, char, memory_order);
char atomic_fetch_and(volatile atomic_char*, char);
char atomic_fetch_and(atomic_char*, char);
char atomic_fetch_and_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_and_explicit(atomic_char*, char, memory_order);
char atomic_fetch_or(volatile atomic_char*, char);
char atomic_fetch_or(atomic_char*, char);
char atomic_fetch_or_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_or_explicit(atomic_char*, char, memory_order);
char atomic_fetch_xor(volatile atomic_char*, char);
char atomic_fetch_xor(atomic_char*, char);
char atomic_fetch_xor_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_xor_explicit(atomic_char*, char, memory_order);

// atomic_schar

typedef struct atomic_schar
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(signed char, memory_order = memory_order_seq_cst) volatile;
    void store(signed char, memory_order = memory_order_seq_cst);
    signed char load(memory_order = memory_order_seq_cst) const volatile;
    signed char load(memory_order = memory_order_seq_cst) const;
    operator signed char() const volatile;
    operator signed char() const;
    signed char exchange(signed char,
                         memory_order = memory_order_seq_cst) volatile;
    signed char exchange(signed char, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(signed char&, signed char, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(signed char&, signed char, memory_order,
                               memory_order);
    bool compare_exchange_strong(signed char&, signed char, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(signed char&, signed char, memory_order,
                                 memory_order);
    bool compare_exchange_weak(signed char&, signed char,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(signed char&, signed char,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(signed char&, signed char,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(signed char&, signed char,
                                 memory_order = memory_order_seq_cst);
    signed char fetch_add(signed char,
                          memory_order = memory_order_seq_cst) volatile;
    signed char fetch_add(signed char, memory_order = memory_order_seq_cst);
    signed char fetch_sub(signed char,
                          memory_order = memory_order_seq_cst) volatile;
    signed char fetch_sub(signed char, memory_order = memory_order_seq_cst);
    signed char fetch_and(signed char,
                          memory_order = memory_order_seq_cst) volatile;
    signed char fetch_and(signed char, memory_order = memory_order_seq_cst);
    signed char fetch_or(signed char,
                         memory_order = memory_order_seq_cst) volatile;
    signed char fetch_or(signed char, memory_order = memory_order_seq_cst);
    signed char fetch_xor(signed char,
                          memory_order = memory_order_seq_cst) volatile;
    signed char fetch_xor(signed char, memory_order = memory_order_seq_cst);
    atomic_schar() = default;
    constexpr atomic_schar(signed char);
    atomic_schar(const atomic_schar&) = delete;
    atomic_schar& operator=(const atomic_schar&) = delete;
    atomic_schar& operator=(const atomic_schar&) volatile = delete;
    signed char operator=(signed char) volatile;
    signed char operator=(signed char);
    signed char operator++(int) volatile;
    signed char operator++(int);
    signed char operator--(int) volatile;
    signed char operator--(int);
    signed char operator++() volatile;
    signed char operator++();
    signed char operator--() volatile;
    signed char operator--();
    signed char operator+=(signed char) volatile;
    signed char operator+=(signed char);
    signed char operator-=(signed char) volatile;
    signed char operator-=(signed char);
    signed char operator&=(signed char) volatile;
    signed char operator&=(signed char);
    signed char operator|=(signed char) volatile;
    signed char operator|=(signed char);
    signed char operator^=(signed char) volatile;
    signed char operator^=(signed char);
} atomic_schar;

bool atomic_is_lock_free(const volatile atomic_schar*);
bool atomic_is_lock_free(const atomic_schar*);
void atomic_init(volatile atomic_schar*, signed char);
void atomic_init(atomic_schar*, signed char);
void atomic_store(volatile atomic_schar*, signed char);
void atomic_store(atomic_schar*, signed char);
void atomic_store_explicit(volatile atomic_schar*, signed char, memory_order);
void atomic_store_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_load(const volatile atomic_schar*);
signed char atomic_load(const atomic_schar*);
signed char atomic_load_explicit(const volatile atomic_schar*, memory_order);
signed char atomic_load_explicit(const atomic_schar*, memory_order);
signed char atomic_exchange(volatile atomic_schar*, signed char);
signed char atomic_exchange(atomic_schar*, signed char);
signed char atomic_exchange_explicit(volatile atomic_schar*, signed char,
                                     memory_order);
signed char atomic_exchange_explicit(atomic_schar*, signed char, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_schar*, signed char*,
                                  signed char);
bool atomic_compare_exchange_weak(atomic_schar*, signed char*, signed char);
bool atomic_compare_exchange_strong(volatile atomic_schar*, signed char*,
                                    signed char);
bool atomic_compare_exchange_strong(atomic_schar*, signed char*, signed char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_schar*, signed char*,
                                           signed char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_schar*, signed char*,
                                           signed char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_schar*,
                                             signed char*, signed char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_schar*, signed char*,
                                             signed char, memory_order, memory_order);
signed char atomic_fetch_add(volatile atomic_schar*, signed char);
signed char atomic_fetch_add(atomic_schar*, signed char);
signed char atomic_fetch_add_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_add_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_sub(volatile atomic_schar*, signed char);
signed char atomic_fetch_sub(atomic_schar*, signed char);
signed char atomic_fetch_sub_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_sub_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_and(volatile atomic_schar*, signed char);
signed char atomic_fetch_and(atomic_schar*, signed char);
signed char atomic_fetch_and_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_and_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_or(volatile atomic_schar*, signed char);
signed char atomic_fetch_or(atomic_schar*, signed char);
signed char atomic_fetch_or_explicit(volatile atomic_schar*, signed char,
                                     memory_order);
signed char atomic_fetch_or_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_xor(volatile atomic_schar*, signed char);
signed char atomic_fetch_xor(atomic_schar*, signed char);
signed char atomic_fetch_xor_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_xor_explicit(atomic_schar*, signed char, memory_order);

// atomic_uchar

typedef struct atomic_uchar
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(unsigned char, memory_order = memory_order_seq_cst) volatile;
    void store(unsigned char, memory_order = memory_order_seq_cst);
    unsigned char load(memory_order = memory_order_seq_cst) const volatile;
    unsigned char load(memory_order = memory_order_seq_cst) const;
    operator unsigned char() const volatile;
    operator unsigned char() const;
    unsigned char exchange(unsigned char,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned char exchange(unsigned char, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(unsigned char&, unsigned char, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(unsigned char&, unsigned char, memory_order,
                               memory_order);
    bool compare_exchange_strong(unsigned char&, unsigned char, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(unsigned char&, unsigned char, memory_order,
                                 memory_order);
    bool compare_exchange_weak(unsigned char&, unsigned char,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(unsigned char&, unsigned char,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(unsigned char&, unsigned char,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(unsigned char&, unsigned char,
                                 memory_order = memory_order_seq_cst);
    unsigned char fetch_add(unsigned char,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned char fetch_add(unsigned char, memory_order = memory_order_seq_cst);
    unsigned char fetch_sub(unsigned char,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned char fetch_sub(unsigned char, memory_order = memory_order_seq_cst);
    unsigned char fetch_and(unsigned char,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned char fetch_and(unsigned char, memory_order = memory_order_seq_cst);
    unsigned char fetch_or(unsigned char,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned char fetch_or(unsigned char, memory_order = memory_order_seq_cst);
    unsigned char fetch_xor(unsigned char,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned char fetch_xor(unsigned char, memory_order = memory_order_seq_cst);
    atomic_uchar() = default;
    constexpr atomic_uchar(unsigned char);
    atomic_uchar(const atomic_uchar&) = delete;
    atomic_uchar& operator=(const atomic_uchar&) = delete;
    atomic_uchar& operator=(const atomic_uchar&) volatile = delete;
    unsigned char operator=(unsigned char) volatile;
    unsigned char operator=(unsigned char);
    unsigned char operator++(int) volatile;
    unsigned char operator++(int);
    unsigned char operator--(int) volatile;
    unsigned char operator--(int);
    unsigned char operator++() volatile;
    unsigned char operator++();
    unsigned char operator--() volatile;
    unsigned char operator--();
    unsigned char operator+=(unsigned char) volatile;
    unsigned char operator+=(unsigned char);
    unsigned char operator-=(unsigned char) volatile;
    unsigned char operator-=(unsigned char);
    unsigned char operator&=(unsigned char) volatile;
    unsigned char operator&=(unsigned char);
    unsigned char operator|=(unsigned char) volatile;
    unsigned char operator|=(unsigned char);
    unsigned char operator^=(unsigned char) volatile;
    unsigned char operator^=(unsigned char);
} atomic_uchar;

bool atomic_is_lock_free(const volatile atomic_uchar*);
bool atomic_is_lock_free(const atomic_uchar*);
void atomic_init(volatile atomic_uchar*, unsigned char);
void atomic_init(atomic_uchar*, unsigned char);
void atomic_store(volatile atomic_uchar*, unsigned char);
void atomic_store(atomic_uchar*, unsigned char);
void atomic_store_explicit(volatile atomic_uchar*, unsigned char, memory_order);
void atomic_store_explicit(atomic_uchar*, unsigned char, memory_order);
unsigned char atomic_load(const volatile atomic_uchar*);
unsigned char atomic_load(const atomic_uchar*);
unsigned char atomic_load_explicit(const volatile atomic_uchar*, memory_order);
unsigned char atomic_load_explicit(const atomic_uchar*, memory_order);
unsigned char atomic_exchange(volatile atomic_uchar*, unsigned char);
unsigned char atomic_exchange(atomic_uchar*, unsigned char);
unsigned char atomic_exchange_explicit(volatile atomic_uchar*, unsigned char,
                                       memory_order);
unsigned char atomic_exchange_explicit(atomic_uchar*, unsigned char,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_uchar*, unsigned char*,
                                  unsigned char);
bool atomic_compare_exchange_weak(atomic_uchar*, unsigned char*, unsigned char);
bool atomic_compare_exchange_strong(volatile atomic_uchar*, unsigned char*,
                                    unsigned char);
bool atomic_compare_exchange_strong(atomic_uchar*, unsigned char*,
                                    unsigned char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_uchar*,
                                           unsigned char*, unsigned char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_uchar*, unsigned char*,
                                           unsigned char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_uchar*,
                                             unsigned char*, unsigned char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_uchar*, unsigned char*,
                                             unsigned char, memory_order,
                                             memory_order);
unsigned char atomic_fetch_add(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_add(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_add_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_add_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_sub(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_sub(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_sub_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_sub_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_and(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_and(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_and_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_and_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_or(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_or(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_or_explicit(volatile atomic_uchar*, unsigned char,
                                       memory_order);
unsigned char atomic_fetch_or_explicit(atomic_uchar*, unsigned char,
                                       memory_order);
unsigned char atomic_fetch_xor(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_xor(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_xor_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_xor_explicit(atomic_uchar*, unsigned char,
                                        memory_order);

// atomic_short

typedef struct atomic_short
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(short, memory_order = memory_order_seq_cst) volatile;
    void store(short, memory_order = memory_order_seq_cst);
    short load(memory_order = memory_order_seq_cst) const volatile;
    short load(memory_order = memory_order_seq_cst) const;
    operator short() const volatile;
    operator short() const;
    short exchange(short, memory_order = memory_order_seq_cst) volatile;
    short exchange(short, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(short&, short, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(short&, short, memory_order, memory_order);
    bool compare_exchange_strong(short&, short, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(short&, short, memory_order, memory_order);
    bool compare_exchange_weak(short&, short,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(short&, short,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(short&, short,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(short&, short,
                                 memory_order = memory_order_seq_cst);
    short fetch_add(short, memory_order = memory_order_seq_cst) volatile;
    short fetch_add(short, memory_order = memory_order_seq_cst);
    short fetch_sub(short, memory_order = memory_order_seq_cst) volatile;
    short fetch_sub(short, memory_order = memory_order_seq_cst);
    short fetch_and(short, memory_order = memory_order_seq_cst) volatile;
    short fetch_and(short, memory_order = memory_order_seq_cst);
    short fetch_or(short, memory_order = memory_order_seq_cst) volatile;
    short fetch_or(short, memory_order = memory_order_seq_cst);
    short fetch_xor(short, memory_order = memory_order_seq_cst) volatile;
    short fetch_xor(short, memory_order = memory_order_seq_cst);
    atomic_short() = default;
    constexpr atomic_short(short);
    atomic_short(const atomic_short&) = delete;
    atomic_short& operator=(const atomic_short&) = delete;
    atomic_short& operator=(const atomic_short&) volatile = delete;
    short operator=(short) volatile;
    short operator=(short);
    short operator++(int) volatile;
    short operator++(int);
    short operator--(int) volatile;
    short operator--(int);
    short operator++() volatile;
    short operator++();
    short operator--() volatile;
    short operator--();
    short operator+=(short) volatile;
    short operator+=(short);
    short operator-=(short) volatile;
    short operator-=(short);
    short operator&=(short) volatile;
    short operator&=(short);
    short operator|=(short) volatile;
    short operator|=(short);
    short operator^=(short) volatile;
    short operator^=(short);
} atomic_short;

bool atomic_is_lock_free(const volatile atomic_short*);
bool atomic_is_lock_free(const atomic_short*);
void atomic_init(volatile atomic_short*, short);
void atomic_init(atomic_short*, short);
void atomic_store(volatile atomic_short*, short);
void atomic_store(atomic_short*, short);
void atomic_store_explicit(volatile atomic_short*, short, memory_order);
void atomic_store_explicit(atomic_short*, short, memory_order);
short atomic_load(const volatile atomic_short*);
short atomic_load(const atomic_short*);
short atomic_load_explicit(const volatile atomic_short*, memory_order);
short atomic_load_explicit(const atomic_short*, memory_order);
short atomic_exchange(volatile atomic_short*, short);
short atomic_exchange(atomic_short*, short);
short atomic_exchange_explicit(volatile atomic_short*, short, memory_order);
short atomic_exchange_explicit(atomic_short*, short, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_short*, short*, short);
bool atomic_compare_exchange_weak(atomic_short*, short*, short);
bool atomic_compare_exchange_strong(volatile atomic_short*, short*, short);
bool atomic_compare_exchange_strong(atomic_short*, short*, short);
bool atomic_compare_exchange_weak_explicit(volatile atomic_short*, short*,
                                           short, memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_short*, short*, short,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_short*, short*,
                                             short, memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_short*, short*, short,
                                             memory_order, memory_order);
short atomic_fetch_add(volatile atomic_short*, short);
short atomic_fetch_add(atomic_short*, short);
short atomic_fetch_add_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_add_explicit(atomic_short*, short, memory_order);
short atomic_fetch_sub(volatile atomic_short*, short);
short atomic_fetch_sub(atomic_short*, short);
short atomic_fetch_sub_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_sub_explicit(atomic_short*, short, memory_order);
short atomic_fetch_and(volatile atomic_short*, short);
short atomic_fetch_and(atomic_short*, short);
short atomic_fetch_and_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_and_explicit(atomic_short*, short, memory_order);
short atomic_fetch_or(volatile atomic_short*, short);
short atomic_fetch_or(atomic_short*, short);
short atomic_fetch_or_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_or_explicit(atomic_short*, short, memory_order);
short atomic_fetch_xor(volatile atomic_short*, short);
short atomic_fetch_xor(atomic_short*, short);
short atomic_fetch_xor_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_xor_explicit(atomic_short*, short, memory_order);

// atomic_ushort

typedef struct atomic_ushort
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(unsigned short, memory_order = memory_order_seq_cst) volatile;
    void store(unsigned short, memory_order = memory_order_seq_cst);
    unsigned short load(memory_order = memory_order_seq_cst) const volatile;
    unsigned short load(memory_order = memory_order_seq_cst) const;
    operator unsigned short() const volatile;
    operator unsigned short() const;
    unsigned short exchange(unsigned short,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned short exchange(unsigned short,
                            memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(unsigned short&, unsigned short, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(unsigned short&, unsigned short, memory_order,
                               memory_order);
    bool compare_exchange_strong(unsigned short&, unsigned short, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(unsigned short&, unsigned short, memory_order,
                                 memory_order);
    bool compare_exchange_weak(unsigned short&, unsigned short,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(unsigned short&, unsigned short,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(unsigned short&, unsigned short,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(unsigned short&, unsigned short,
                                 memory_order = memory_order_seq_cst);
    unsigned short fetch_add(unsigned short,
                             memory_order = memory_order_seq_cst) volatile;
    unsigned short fetch_add(unsigned short,
                             memory_order = memory_order_seq_cst);
    unsigned short fetch_sub(unsigned short,
                             memory_order = memory_order_seq_cst) volatile;
    unsigned short fetch_sub(unsigned short,
                             memory_order = memory_order_seq_cst);
    unsigned short fetch_and(unsigned short,
                             memory_order = memory_order_seq_cst) volatile;
    unsigned short fetch_and(unsigned short,
                             memory_order = memory_order_seq_cst);
    unsigned short fetch_or(unsigned short,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned short fetch_or(unsigned short,
                            memory_order = memory_order_seq_cst);
    unsigned short fetch_xor(unsigned short,
                             memory_order = memory_order_seq_cst) volatile;
    unsigned short fetch_xor(unsigned short,
                             memory_order = memory_order_seq_cst);
    atomic_ushort() = default;
    constexpr atomic_ushort(unsigned short);
    atomic_ushort(const atomic_ushort&) = delete;
    atomic_ushort& operator=(const atomic_ushort&) = delete;
    atomic_ushort& operator=(const atomic_ushort&) volatile = delete;
    unsigned short operator=(unsigned short) volatile;
    unsigned short operator=(unsigned short);
    unsigned short operator++(int) volatile;
    unsigned short operator++(int);
    unsigned short operator--(int) volatile;
    unsigned short operator--(int);
    unsigned short operator++() volatile;
    unsigned short operator++();
    unsigned short operator--() volatile;
    unsigned short operator--();
    unsigned short operator+=(unsigned short) volatile;
    unsigned short operator+=(unsigned short);
    unsigned short operator-=(unsigned short) volatile;
    unsigned short operator-=(unsigned short);
    unsigned short operator&=(unsigned short) volatile;
    unsigned short operator&=(unsigned short);
    unsigned short operator|=(unsigned short) volatile;
    unsigned short operator|=(unsigned short);
    unsigned short operator^=(unsigned short) volatile;
    unsigned short operator^=(unsigned short);
} atomic_ushort;

bool atomic_is_lock_free(const volatile atomic_ushort*);
bool atomic_is_lock_free(const atomic_ushort*);
void atomic_init(volatile atomic_ushort*, unsigned short);
void atomic_init(atomic_ushort*, unsigned short);
void atomic_store(volatile atomic_ushort*, unsigned short);
void atomic_store(atomic_ushort*, unsigned short);
void atomic_store_explicit(volatile atomic_ushort*, unsigned short,
                           memory_order);
void atomic_store_explicit(atomic_ushort*, unsigned short, memory_order);
unsigned short atomic_load(const volatile atomic_ushort*);
unsigned short atomic_load(const atomic_ushort*);
unsigned short atomic_load_explicit(const volatile atomic_ushort*,
                                    memory_order);
unsigned short atomic_load_explicit(const atomic_ushort*, memory_order);
unsigned short atomic_exchange(volatile atomic_ushort*, unsigned short);
unsigned short atomic_exchange(atomic_ushort*, unsigned short);
unsigned short atomic_exchange_explicit(volatile atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_exchange_explicit(atomic_ushort*, unsigned short,
                                        memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ushort*, unsigned short*,
                                  unsigned short);
bool atomic_compare_exchange_weak(atomic_ushort*, unsigned short*,
                                  unsigned short);
bool atomic_compare_exchange_strong(volatile atomic_ushort*, unsigned short*,
                                    unsigned short);
bool atomic_compare_exchange_strong(atomic_ushort*, unsigned short*,
                                    unsigned short);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ushort*,
                                           unsigned short*, unsigned short,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ushort*, unsigned short*,
                                           unsigned short, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ushort*,
                                             unsigned short*, unsigned short,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ushort*, unsigned short*,
                                             unsigned short, memory_order,
                                             memory_order);
unsigned short atomic_fetch_add(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_add(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_add_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_add_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_sub(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_sub(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_sub_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_sub_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_and(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_and(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_and_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_and_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_or(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_or(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_or_explicit(volatile atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_fetch_or_explicit(atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_fetch_xor(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_xor(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_xor_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_xor_explicit(atomic_ushort*, unsigned short,
                                         memory_order);

// atomic_int

typedef struct atomic_int
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(int, memory_order = memory_order_seq_cst) volatile;
    void store(int, memory_order = memory_order_seq_cst);
    int load(memory_order = memory_order_seq_cst) const volatile;
    int load(memory_order = memory_order_seq_cst) const;
    operator int() const volatile;
    operator int() const;
    int exchange(int, memory_order = memory_order_seq_cst) volatile;
    int exchange(int, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(int&, int, memory_order, memory_order) volatile;
    bool compare_exchange_weak(int&, int, memory_order, memory_order);
    bool compare_exchange_strong(int&, int, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(int&, int, memory_order, memory_order);
    bool compare_exchange_weak(int&, int,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(int&, int, memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(int&, int,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(int&, int,
                                 memory_order = memory_order_seq_cst);
    int fetch_add(int, memory_order = memory_order_seq_cst) volatile;
    int fetch_add(int, memory_order = memory_order_seq_cst);
    int fetch_sub(int, memory_order = memory_order_seq_cst) volatile;
    int fetch_sub(int, memory_order = memory_order_seq_cst);
    int fetch_and(int, memory_order = memory_order_seq_cst) volatile;
    int fetch_and(int, memory_order = memory_order_seq_cst);
    int fetch_or(int, memory_order = memory_order_seq_cst) volatile;
    int fetch_or(int, memory_order = memory_order_seq_cst);
    int fetch_xor(int, memory_order = memory_order_seq_cst) volatile;
    int fetch_xor(int, memory_order = memory_order_seq_cst);
    atomic_int() = default;
    constexpr atomic_int(int);
    atomic_int(const atomic_int&) = delete;
    atomic_int& operator=(const atomic_int&) = delete;
    atomic_int& operator=(const atomic_int&) volatile = delete;
    int operator=(int) volatile;
    int operator=(int);
    int operator++(int) volatile;
    int operator++(int);
    int operator--(int) volatile;
    int operator--(int);
    int operator++() volatile;
    int operator++();
    int operator--() volatile;
    int operator--();
    int operator+=(int) volatile;
    int operator+=(int);
    int operator-=(int) volatile;
    int operator-=(int);
    int operator&=(int) volatile;
    int operator&=(int);
    int operator|=(int) volatile;
    int operator|=(int);
    int operator^=(int) volatile;
    int operator^=(int);
} atomic_int;

bool atomic_is_lock_free(const volatile atomic_int*);
bool atomic_is_lock_free(const atomic_int*);
void atomic_init(volatile atomic_int*, int);
void atomic_init(atomic_int*, int);
void atomic_store(volatile atomic_int*, int);
void atomic_store(atomic_int*, int);
void atomic_store_explicit(volatile atomic_int*, int, memory_order);
void atomic_store_explicit(atomic_int*, int, memory_order);
int atomic_load(const volatile atomic_int*);
int atomic_load(const atomic_int*);
int atomic_load_explicit(const volatile atomic_int*, memory_order);
int atomic_load_explicit(const atomic_int*, memory_order);
int atomic_exchange(volatile atomic_int*, int);
int atomic_exchange(atomic_int*, int);
int atomic_exchange_explicit(volatile atomic_int*, int, memory_order);
int atomic_exchange_explicit(atomic_int*, int, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_int*, int*, int);
bool atomic_compare_exchange_weak(atomic_int*, int*, int);
bool atomic_compare_exchange_strong(volatile atomic_int*, int*, int);
bool atomic_compare_exchange_strong(atomic_int*, int*, int);
bool atomic_compare_exchange_weak_explicit(volatile atomic_int*, int*, int,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_int*, int*, int, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_int*, int*, int,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_int*, int*, int,
                                             memory_order, memory_order);
int atomic_fetch_add(volatile atomic_int*, int);
int atomic_fetch_add(atomic_int*, int);
int atomic_fetch_add_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_add_explicit(atomic_int*, int, memory_order);
int atomic_fetch_sub(volatile atomic_int*, int);
int atomic_fetch_sub(atomic_int*, int);
int atomic_fetch_sub_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_sub_explicit(atomic_int*, int, memory_order);
int atomic_fetch_and(volatile atomic_int*, int);
int atomic_fetch_and(atomic_int*, int);
int atomic_fetch_and_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_and_explicit(atomic_int*, int, memory_order);
int atomic_fetch_or(volatile atomic_int*, int);
int atomic_fetch_or(atomic_int*, int);
int atomic_fetch_or_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_or_explicit(atomic_int*, int, memory_order);
int atomic_fetch_xor(volatile atomic_int*, int);
int atomic_fetch_xor(atomic_int*, int);
int atomic_fetch_xor_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_xor_explicit(atomic_int*, int, memory_order);

// atomic_uint

typedef struct atomic_uint
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(unsigned int, memory_order = memory_order_seq_cst) volatile;
    void store(unsigned int, memory_order = memory_order_seq_cst);
    unsigned int load(memory_order = memory_order_seq_cst) const volatile;
    unsigned int load(memory_order = memory_order_seq_cst) const;
    operator unsigned int() const volatile;
    operator unsigned int() const;
    unsigned int exchange(unsigned int,
                          memory_order = memory_order_seq_cst) volatile;
    unsigned int exchange(unsigned int, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(unsigned int&, unsigned int, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(unsigned int&, unsigned int, memory_order,
                               memory_order);
    bool compare_exchange_strong(unsigned int&, unsigned int, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(unsigned int&, unsigned int, memory_order,
                                 memory_order);
    bool compare_exchange_weak(unsigned int&, unsigned int,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(unsigned int&, unsigned int,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(unsigned int&, unsigned int,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(unsigned int&, unsigned int,
                                 memory_order = memory_order_seq_cst);
    unsigned int fetch_add(unsigned int,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned int fetch_add(unsigned int, memory_order = memory_order_seq_cst);
    unsigned int fetch_sub(unsigned int,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned int fetch_sub(unsigned int, memory_order = memory_order_seq_cst);
    unsigned int fetch_and(unsigned int,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned int fetch_and(unsigned int, memory_order = memory_order_seq_cst);
    unsigned int fetch_or(unsigned int,
                          memory_order = memory_order_seq_cst) volatile;
    unsigned int fetch_or(unsigned int, memory_order = memory_order_seq_cst);
    unsigned int fetch_xor(unsigned int,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned int fetch_xor(unsigned int, memory_order = memory_order_seq_cst);
    atomic_uint() = default;
    constexpr atomic_uint(unsigned int);
    atomic_uint(const atomic_uint&) = delete;
    atomic_uint& operator=(const atomic_uint&) = delete;
    atomic_uint& operator=(const atomic_uint&) volatile = delete;
    unsigned int operator=(unsigned int) volatile;
    unsigned int operator=(unsigned int);
    unsigned int operator++(int) volatile;
    unsigned int operator++(int);
    unsigned int operator--(int) volatile;
    unsigned int operator--(int);
    unsigned int operator++() volatile;
    unsigned int operator++();
    unsigned int operator--() volatile;
    unsigned int operator--();
    unsigned int operator+=(unsigned int) volatile;
    unsigned int operator+=(unsigned int);
    unsigned int operator-=(unsigned int) volatile;
    unsigned int operator-=(unsigned int);
    unsigned int operator&=(unsigned int) volatile;
    unsigned int operator&=(unsigned int);
    unsigned int operator|=(unsigned int) volatile;
    unsigned int operator|=(unsigned int);
    unsigned int operator^=(unsigned int) volatile;
    unsigned int operator^=(unsigned int);
} atomic_uint;

bool atomic_is_lock_free(const volatile atomic_uint*);
bool atomic_is_lock_free(const atomic_uint*);
void atomic_init(volatile atomic_uint*, unsigned int);
void atomic_init(atomic_uint*, unsigned int);
void atomic_store(volatile atomic_uint*, unsigned int);
void atomic_store(atomic_uint*, unsigned int);
void atomic_store_explicit(volatile atomic_uint*, unsigned int, memory_order);
void atomic_store_explicit(atomic_uint*, unsigned int, memory_order);
unsigned int atomic_load(const volatile atomic_uint*);
unsigned int atomic_load(const atomic_uint*);
unsigned int atomic_load_explicit(const volatile atomic_uint*, memory_order);
unsigned int atomic_load_explicit(const atomic_uint*, memory_order);
unsigned int atomic_exchange(volatile atomic_uint*, unsigned int);
unsigned int atomic_exchange(atomic_uint*, unsigned int);
unsigned int atomic_exchange_explicit(volatile atomic_uint*, unsigned int,
                                      memory_order);
unsigned int atomic_exchange_explicit(atomic_uint*, unsigned int, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_uint*, unsigned int*,
                                  unsigned int);
bool atomic_compare_exchange_weak(atomic_uint*, unsigned int*, unsigned int);
bool atomic_compare_exchange_strong(volatile atomic_uint*, unsigned int*,
                                    unsigned int);
bool atomic_compare_exchange_strong(atomic_uint*, unsigned int*, unsigned int);
bool atomic_compare_exchange_weak_explicit(volatile atomic_uint*, unsigned int*,
                                           unsigned int, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_uint*, unsigned int*,
                                           unsigned int, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_uint*,
                                             unsigned int*, unsigned int,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_uint*, unsigned int*,
                                             unsigned int, memory_order, 
                                             memory_order);
unsigned int atomic_fetch_add(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_add(atomic_uint*, unsigned int);
unsigned int atomic_fetch_add_explicit(volatile atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_add_explicit(atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_sub(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_sub(atomic_uint*, unsigned int);
unsigned int atomic_fetch_sub_explicit(volatile atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_sub_explicit(atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_and(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_and(atomic_uint*, unsigned int);
unsigned int atomic_fetch_and_explicit(volatile atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_and_explicit(atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_or(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_or(atomic_uint*, unsigned int);
unsigned int atomic_fetch_or_explicit(volatile atomic_uint*, unsigned int,
                                      memory_order);
unsigned int atomic_fetch_or_explicit(atomic_uint*, unsigned int, memory_order);
unsigned int atomic_fetch_xor(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_xor(atomic_uint*, unsigned int);
unsigned int atomic_fetch_xor_explicit(volatile atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_xor_explicit(atomic_uint*, unsigned int,
                                       memory_order);

// atomic_long

typedef struct atomic_long
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(long, memory_order = memory_order_seq_cst) volatile;
    void store(long, memory_order = memory_order_seq_cst);
    long load(memory_order = memory_order_seq_cst) const volatile;
    long load(memory_order = memory_order_seq_cst) const;
    operator long() const volatile;
    operator long() const;
    long exchange(long, memory_order = memory_order_seq_cst) volatile;
    long exchange(long, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(long&, long, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(long&, long, memory_order, memory_order);
    bool compare_exchange_strong(long&, long, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(long&, long, memory_order, memory_order);
    bool compare_exchange_weak(long&, long,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(long&, long,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(long&, long,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(long&, long,
                                 memory_order = memory_order_seq_cst);
    long fetch_add(long, memory_order = memory_order_seq_cst) volatile;
    long fetch_add(long, memory_order = memory_order_seq_cst);
    long fetch_sub(long, memory_order = memory_order_seq_cst) volatile;
    long fetch_sub(long, memory_order = memory_order_seq_cst);
    long fetch_and(long, memory_order = memory_order_seq_cst) volatile;
    long fetch_and(long, memory_order = memory_order_seq_cst);
    long fetch_or(long, memory_order = memory_order_seq_cst) volatile;
    long fetch_or(long, memory_order = memory_order_seq_cst);
    long fetch_xor(long, memory_order = memory_order_seq_cst) volatile;
    long fetch_xor(long, memory_order = memory_order_seq_cst);
    atomic_long() = default;
    constexpr atomic_long(long);
    atomic_long(const atomic_long&) = delete;
    atomic_long& operator=(const atomic_long&) = delete;
    atomic_long& operator=(const atomic_long&) volatile = delete;
    long operator=(long) volatile;
    long operator=(long);
    long operator++(int) volatile;
    long operator++(int);
    long operator--(int) volatile;
    long operator--(int);
    long operator++() volatile;
    long operator++();
    long operator--() volatile;
    long operator--();
    long operator+=(long) volatile;
    long operator+=(long);
    long operator-=(long) volatile;
    long operator-=(long);
    long operator&=(long) volatile;
    long operator&=(long);
    long operator|=(long) volatile;
    long operator|=(long);
    long operator^=(long) volatile;
    long operator^=(long);
} atomic_long;

bool atomic_is_lock_free(const volatile atomic_long*);
bool atomic_is_lock_free(const atomic_long*);
void atomic_init(volatile atomic_long*, long);
void atomic_init(atomic_long*, long);
void atomic_store(volatile atomic_long*, long);
void atomic_store(atomic_long*, long);
void atomic_store_explicit(volatile atomic_long*, long, memory_order);
void atomic_store_explicit(atomic_long*, long, memory_order);
long atomic_load(const volatile atomic_long*);
long atomic_load(const atomic_long*);
long atomic_load_explicit(const volatile atomic_long*, memory_order);
long atomic_load_explicit(const atomic_long*, memory_order);
long atomic_exchange(volatile atomic_long*, long);
long atomic_exchange(atomic_long*, long);
long atomic_exchange_explicit(volatile atomic_long*, long, memory_order);
long atomic_exchange_explicit(atomic_long*, long, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_long*, long*, long);
bool atomic_compare_exchange_weak(atomic_long*, long*, long);
bool atomic_compare_exchange_strong(volatile atomic_long*, long*, long);
bool atomic_compare_exchange_strong(atomic_long*, long*, long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_long*, long*, long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_long*, long*, long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_long*, long*, long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_long*, long*, long,
                                             memory_order, memory_order);
long atomic_fetch_add(volatile atomic_long*, long);
long atomic_fetch_add(atomic_long*, long);
long atomic_fetch_add_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_add_explicit(atomic_long*, long, memory_order);
long atomic_fetch_sub(volatile atomic_long*, long);
long atomic_fetch_sub(atomic_long*, long);
long atomic_fetch_sub_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_sub_explicit(atomic_long*, long, memory_order);
long atomic_fetch_and(volatile atomic_long*, long);
long atomic_fetch_and(atomic_long*, long);
long atomic_fetch_and_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_and_explicit(atomic_long*, long, memory_order);
long atomic_fetch_or(volatile atomic_long*, long);
long atomic_fetch_or(atomic_long*, long);
long atomic_fetch_or_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_or_explicit(atomic_long*, long, memory_order);
long atomic_fetch_xor(volatile atomic_long*, long);
long atomic_fetch_xor(atomic_long*, long);
long atomic_fetch_xor_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_xor_explicit(atomic_long*, long, memory_order);

// atomic_ulong

typedef struct atomic_ulong
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(unsigned long, memory_order = memory_order_seq_cst) volatile;
    void store(unsigned long, memory_order = memory_order_seq_cst);
    unsigned long load(memory_order = memory_order_seq_cst) const volatile;
    unsigned long load(memory_order = memory_order_seq_cst) const;
    operator unsigned long() const volatile;
    operator unsigned long() const;
    unsigned long exchange(unsigned long,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned long exchange(unsigned long, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(unsigned long&, unsigned long, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(unsigned long&, unsigned long, memory_order,
                               memory_order);
    bool compare_exchange_strong(unsigned long&, unsigned long, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(unsigned long&, unsigned long, memory_order,
                                 memory_order);
    bool compare_exchange_weak(unsigned long&, unsigned long,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(unsigned long&, unsigned long,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(unsigned long&, unsigned long,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(unsigned long&, unsigned long,
                                 memory_order = memory_order_seq_cst);
    unsigned long fetch_add(unsigned long,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned long fetch_add(unsigned long, memory_order = memory_order_seq_cst);
    unsigned long fetch_sub(unsigned long,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned long fetch_sub(unsigned long, memory_order = memory_order_seq_cst);
    unsigned long fetch_and(unsigned long,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned long fetch_and(unsigned long, memory_order = memory_order_seq_cst);
    unsigned long fetch_or(unsigned long,
                           memory_order = memory_order_seq_cst) volatile;
    unsigned long fetch_or(unsigned long, memory_order = memory_order_seq_cst);
    unsigned long fetch_xor(unsigned long,
                            memory_order = memory_order_seq_cst) volatile;
    unsigned long fetch_xor(unsigned long, memory_order = memory_order_seq_cst);
    atomic_ulong() = default;
    constexpr atomic_ulong(unsigned long);
    atomic_ulong(const atomic_ulong&) = delete;
    atomic_ulong& operator=(const atomic_ulong&) = delete;
    atomic_ulong& operator=(const atomic_ulong&) volatile = delete;
    unsigned long operator=(unsigned long) volatile;
    unsigned long operator=(unsigned long);
    unsigned long operator++(int) volatile;
    unsigned long operator++(int);
    unsigned long operator--(int) volatile;
    unsigned long operator--(int);
    unsigned long operator++() volatile;
    unsigned long operator++();
    unsigned long operator--() volatile;
    unsigned long operator--();
    unsigned long operator+=(unsigned long) volatile;
    unsigned long operator+=(unsigned long);
    unsigned long operator-=(unsigned long) volatile;
    unsigned long operator-=(unsigned long);
    unsigned long operator&=(unsigned long) volatile;
    unsigned long operator&=(unsigned long);
    unsigned long operator|=(unsigned long) volatile;
    unsigned long operator|=(unsigned long);
    unsigned long operator^=(unsigned long) volatile;
    unsigned long operator^=(unsigned long);
} atomic_ulong;

bool atomic_is_lock_free(const volatile atomic_ulong*);
bool atomic_is_lock_free(const atomic_ulong*);
void atomic_init(volatile atomic_ulong*, unsigned long);
void atomic_init(atomic_ulong*, unsigned long);
void atomic_store(volatile atomic_ulong*, unsigned long);
void atomic_store(atomic_ulong*, unsigned long);
void atomic_store_explicit(volatile atomic_ulong*, unsigned long, memory_order);
void atomic_store_explicit(atomic_ulong*, unsigned long, memory_order);
unsigned long atomic_load(const volatile atomic_ulong*);
unsigned long atomic_load(const atomic_ulong*);
unsigned long atomic_load_explicit(const volatile atomic_ulong*, memory_order);
unsigned long atomic_load_explicit(const atomic_ulong*, memory_order);
unsigned long atomic_exchange(volatile atomic_ulong*, unsigned long);
unsigned long atomic_exchange(atomic_ulong*, unsigned long);
unsigned long atomic_exchange_explicit(volatile atomic_ulong*, unsigned long,
                                       memory_order);
unsigned long atomic_exchange_explicit(atomic_ulong*, unsigned long,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ulong*, unsigned long*,
                                  unsigned long);
bool atomic_compare_exchange_weak(atomic_ulong*, unsigned long*, unsigned long);
bool atomic_compare_exchange_strong(volatile atomic_ulong*, unsigned long*,
                                    unsigned long);
bool atomic_compare_exchange_strong(atomic_ulong*, unsigned long*,
                                    unsigned long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ulong*,
                                           unsigned long*, unsigned long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ulong*, unsigned long*,
                                           unsigned long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ulong*,
                                             unsigned long*, unsigned long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ulong*, unsigned long*,
                                             unsigned long, memory_order,
                                             memory_order);
unsigned long atomic_fetch_add(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_add(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_add_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_add_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_sub(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_sub(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_sub_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_sub_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_and(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_and(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_and_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_and_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_or(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_or(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_or_explicit(volatile atomic_ulong*, unsigned long,
                                       memory_order);
unsigned long atomic_fetch_or_explicit(atomic_ulong*, unsigned long,
                                       memory_order);
unsigned long atomic_fetch_xor(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_xor(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_xor_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_xor_explicit(atomic_ulong*, unsigned long,
                                        memory_order);

// atomic_llong

typedef struct atomic_llong
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(long long, memory_order = memory_order_seq_cst) volatile;
    void store(long long, memory_order = memory_order_seq_cst);
    long long load(memory_order = memory_order_seq_cst) const volatile;
    long long load(memory_order = memory_order_seq_cst) const;
    operator long long() const volatile;
    operator long long() const;
    long long exchange(long long, memory_order = memory_order_seq_cst) volatile;
    long long exchange(long long, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(long long&, long long, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(long long&, long long, memory_order,
                               memory_order);
    bool compare_exchange_strong(long long&, long long, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(long long&, long long, memory_order,
                                 memory_order);
    bool compare_exchange_weak(long long&, long long,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(long long&, long long,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(long long&, long long,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(long long&, long long,
                                 memory_order = memory_order_seq_cst);
    long long fetch_add(long long,
                        memory_order = memory_order_seq_cst) volatile;
    long long fetch_add(long long, memory_order = memory_order_seq_cst);
    long long fetch_sub(long long,
                        memory_order = memory_order_seq_cst) volatile;
    long long fetch_sub(long long, memory_order = memory_order_seq_cst);
    long long fetch_and(long long,
                        memory_order = memory_order_seq_cst) volatile;
    long long fetch_and(long long, memory_order = memory_order_seq_cst);
    long long fetch_or(long long, memory_order = memory_order_seq_cst) volatile;
    long long fetch_or(long long, memory_order = memory_order_seq_cst);
    long long fetch_xor(long long,
                        memory_order = memory_order_seq_cst) volatile;
    long long fetch_xor(long long, memory_order = memory_order_seq_cst);
    atomic_llong() = default;
    constexpr atomic_llong(long long);
    atomic_llong(const atomic_llong&) = delete;
    atomic_llong& operator=(const atomic_llong&) = delete;
    atomic_llong& operator=(const atomic_llong&) volatile = delete;
    long long operator=(long long) volatile;
    long long operator=(long long);
    long long operator++(int) volatile;
    long long operator++(int);
    long long operator--(int) volatile;
    long long operator--(int);
    long long operator++() volatile;
    long long operator++();
    long long operator--() volatile;
    long long operator--();
    long long operator+=(long long) volatile;
    long long operator+=(long long);
    long long operator-=(long long) volatile;
    long long operator-=(long long);
    long long operator&=(long long) volatile;
    long long operator&=(long long);
    long long operator|=(long long) volatile;
    long long operator|=(long long);
    long long operator^=(long long) volatile;
    long long operator^=(long long);
} atomic_llong;

bool atomic_is_lock_free(const volatile atomic_llong*);
bool atomic_is_lock_free(const atomic_llong*);
void atomic_init(volatile atomic_llong*, long long);
void atomic_init(atomic_llong*, long long);
void atomic_store(volatile atomic_llong*, long long);
void atomic_store(atomic_llong*, long long);
void atomic_store_explicit(volatile atomic_llong*, long long, memory_order);
void atomic_store_explicit(atomic_llong*, long long, memory_order);
long long atomic_load(const volatile atomic_llong*);
long long atomic_load(const atomic_llong*);
long long atomic_load_explicit(const volatile atomic_llong*, memory_order);
long long atomic_load_explicit(const atomic_llong*, memory_order);
long long atomic_exchange(volatile atomic_llong*, long long);
long long atomic_exchange(atomic_llong*, long long);
long long atomic_exchange_explicit(volatile atomic_llong*, long long,
                                   memory_order);
long long atomic_exchange_explicit(atomic_llong*, long long, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_llong*, long long*,
                                  long long);
bool atomic_compare_exchange_weak(atomic_llong*, long long*, long long);
bool atomic_compare_exchange_strong(volatile atomic_llong*, long long*,
                                    long long);
bool atomic_compare_exchange_strong(atomic_llong*, long long*, long long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_llong*, long long*,
                                           long long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_llong*, long long*, long long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_llong*, long long*,
                                             long long, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_llong*, long long*,
                                             long long, memory_order,
                                             memory_order);
long long atomic_fetch_add(volatile atomic_llong*, long long);
long long atomic_fetch_add(atomic_llong*, long long);
long long atomic_fetch_add_explicit(volatile atomic_llong*, long long,
                                    memory_order);
long long atomic_fetch_add_explicit(atomic_llong*, long long, memory_order);
long long atomic_fetch_sub(volatile atomic_llong*, long long);
long long atomic_fetch_sub(atomic_llong*, long long);
long long atomic_fetch_sub_explicit(volatile atomic_llong*, long long,
                                    memory_order);
long long atomic_fetch_sub_explicit(atomic_llong*, long long, memory_order);
long long atomic_fetch_and(volatile atomic_llong*, long long);
long long atomic_fetch_and(atomic_llong*, long long);
long long atomic_fetch_and_explicit(volatile atomic_llong*, long long,
                                    memory_order);
long long atomic_fetch_and_explicit(atomic_llong*, long long, memory_order);
long long atomic_fetch_or(volatile atomic_llong*, long long);
long long atomic_fetch_or(atomic_llong*, long long);
long long atomic_fetch_or_explicit(volatile atomic_llong*, long long,
                                   memory_order);
long long atomic_fetch_or_explicit(atomic_llong*, long long, memory_order);
long long atomic_fetch_xor(volatile atomic_llong*, long long);
long long atomic_fetch_xor(atomic_llong*, long long);
long long atomic_fetch_xor_explicit(volatile atomic_llong*, long long,
                                    memory_order);
long long atomic_fetch_xor_explicit(atomic_llong*, long long, memory_order);

// atomic_ullong

typedef struct atomic_ullong
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(unsigned long long,
               memory_order = memory_order_seq_cst) volatile;
    void store(unsigned long long, memory_order = memory_order_seq_cst);
    unsigned long long load(memory_order = memory_order_seq_cst) const volatile;
    unsigned long long load(memory_order = memory_order_seq_cst) const;
    operator unsigned long long() const volatile;
    operator unsigned long long() const;
    unsigned long long exchange(unsigned long long,
                                memory_order = memory_order_seq_cst) volatile;
    unsigned long long exchange(unsigned long long,
                                memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(unsigned long long&, unsigned long long,
                               memory_order, memory_order) volatile;
    bool compare_exchange_weak(unsigned long long&, unsigned long long,
                               memory_order, memory_order);
    bool compare_exchange_strong(unsigned long long&, unsigned long long,
                                 memory_order, memory_order) volatile;
    bool compare_exchange_strong(unsigned long long&, unsigned long long,
                                 memory_order, memory_order);
    bool compare_exchange_weak(unsigned long long&, unsigned long long,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(unsigned long long&, unsigned long long,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(unsigned long long&, unsigned long long,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(unsigned long long&, unsigned long long,
                                 memory_order = memory_order_seq_cst);
    unsigned long long fetch_add(unsigned long long,
                                 memory_order = memory_order_seq_cst) volatile;
    unsigned long long fetch_add(unsigned long long,
                                 memory_order = memory_order_seq_cst);
    unsigned long long fetch_sub(unsigned long long,
                                 memory_order = memory_order_seq_cst) volatile;
    unsigned long long fetch_sub(unsigned long long,
                                 memory_order = memory_order_seq_cst);
    unsigned long long fetch_and(unsigned long long,
                                 memory_order = memory_order_seq_cst) volatile;
    unsigned long long fetch_and(unsigned long long,
                                 memory_order = memory_order_seq_cst);
    unsigned long long fetch_or(unsigned long long,
                                memory_order = memory_order_seq_cst) volatile;
    unsigned long long fetch_or(unsigned long long,
                                memory_order = memory_order_seq_cst);
    unsigned long long fetch_xor(unsigned long long,
                                 memory_order = memory_order_seq_cst) volatile;
    unsigned long long fetch_xor(unsigned long long,
                                 memory_order = memory_order_seq_cst);
    atomic_ullong() = default;
    constexpr atomic_ullong(unsigned long long);
    atomic_ullong(const atomic_ullong&) = delete;
    atomic_ullong& operator=(const atomic_ullong&) = delete;
    atomic_ullong& operator=(const atomic_ullong&) volatile = delete;
    unsigned long long operator=(unsigned long long) volatile;
    unsigned long long operator=(unsigned long long);
    unsigned long long operator++(int) volatile;
    unsigned long long operator++(int);
    unsigned long long operator--(int) volatile;
    unsigned long long operator--(int);
    unsigned long long operator++() volatile;
    unsigned long long operator++();
    unsigned long long operator--() volatile;
    unsigned long long operator--();
    unsigned long long operator+=(unsigned long long) volatile;
    unsigned long long operator+=(unsigned long long);
    unsigned long long operator-=(unsigned long long) volatile;
    unsigned long long operator-=(unsigned long long);
    unsigned long long operator&=(unsigned long long) volatile;
    unsigned long long operator&=(unsigned long long);
    unsigned long long operator|=(unsigned long long) volatile;
    unsigned long long operator|=(unsigned long long);
    unsigned long long operator^=(unsigned long long) volatile;
    unsigned long long operator^=(unsigned long long);
} atomic_ullong;

bool atomic_is_lock_free(const volatile atomic_ullong*);
bool atomic_is_lock_free(const atomic_ullong*);
void atomic_init(volatile atomic_ullong*, unsigned long long);
void atomic_init(atomic_ullong*, unsigned long long);
void atomic_store(volatile atomic_ullong*, unsigned long long);
void atomic_store(atomic_ullong*, unsigned long long);
void atomic_store_explicit(volatile atomic_ullong*, unsigned long long,
                           memory_order);
void atomic_store_explicit(atomic_ullong*, unsigned long long, memory_order);
unsigned long long atomic_load(const volatile atomic_ullong*);
unsigned long long atomic_load(const atomic_ullong*);
unsigned long long atomic_load_explicit(const volatile atomic_ullong*,
                                        memory_order);
unsigned long long atomic_load_explicit(const atomic_ullong*, memory_order);
unsigned long long atomic_exchange(volatile atomic_ullong*, unsigned long long);
unsigned long long atomic_exchange(atomic_ullong*, unsigned long long);
unsigned long long atomic_exchange_explicit(volatile atomic_ullong*,
                                            unsigned long long, memory_order);
unsigned long long atomic_exchange_explicit(atomic_ullong*, unsigned long long,
                                            memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ullong*, unsigned long long*,
                                  unsigned long long);
bool atomic_compare_exchange_weak(atomic_ullong*, unsigned long long*,
                                  unsigned long long);
bool atomic_compare_exchange_strong(volatile atomic_ullong*,
                                    unsigned long long*, unsigned long long);
bool atomic_compare_exchange_strong(atomic_ullong*, unsigned long long*,
                                    unsigned long long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ullong*,
                                           unsigned long long*,
                                           unsigned long long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ullong*, unsigned long long*,
                                           unsigned long long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ullong*,
                                             unsigned long long*,
                                             unsigned long long, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ullong*,
                                             unsigned long long*,
                                             unsigned long long, memory_order,
                                             memory_order);
unsigned long long atomic_fetch_add(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_add(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_add_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_add_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_sub(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_sub(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_sub_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_sub_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_and(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_and(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_and_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_and_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_or(volatile atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_or(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_or_explicit(volatile atomic_ullong*,
                                            unsigned long long, memory_order);
unsigned long long atomic_fetch_or_explicit(atomic_ullong*, unsigned long long,
                                            memory_order);
unsigned long long atomic_fetch_xor(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_xor(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_xor_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_xor_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);

// atomic_char16_t

typedef struct atomic_char16_t
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(char16_t, memory_order = memory_order_seq_cst) volatile;
    void store(char16_t, memory_order = memory_order_seq_cst);
    char16_t load(memory_order = memory_order_seq_cst) const volatile;
    char16_t load(memory_order = memory_order_seq_cst) const;
    operator char16_t() const volatile;
    operator char16_t() const;
    char16_t exchange(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t exchange(char16_t, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(char16_t&, char16_t, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(char16_t&, char16_t, memory_order, memory_order);
    bool compare_exchange_strong(char16_t&, char16_t, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(char16_t&, char16_t,
                                 memory_order, memory_order);
    bool compare_exchange_weak(char16_t&, char16_t,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(char16_t&, char16_t,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(char16_t&, char16_t,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(char16_t&, char16_t,
                                 memory_order = memory_order_seq_cst);
    char16_t fetch_add(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t fetch_add(char16_t, memory_order = memory_order_seq_cst);
    char16_t fetch_sub(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t fetch_sub(char16_t, memory_order = memory_order_seq_cst);
    char16_t fetch_and(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t fetch_and(char16_t, memory_order = memory_order_seq_cst);
    char16_t fetch_or(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t fetch_or(char16_t, memory_order = memory_order_seq_cst);
    char16_t fetch_xor(char16_t, memory_order = memory_order_seq_cst) volatile;
    char16_t fetch_xor(char16_t, memory_order = memory_order_seq_cst);
    atomic_char16_t() = default;
    constexpr atomic_char16_t(char16_t);
    atomic_char16_t(const atomic_char16_t&) = delete;
    atomic_char16_t& operator=(const atomic_char16_t&) = delete;
    atomic_char16_t& operator=(const atomic_char16_t&) volatile = delete;
    char16_t operator=(char16_t) volatile;
    char16_t operator=(char16_t);
    char16_t operator++(int) volatile;
    char16_t operator++(int);
    char16_t operator--(int) volatile;
    char16_t operator--(int);
    char16_t operator++() volatile;
    char16_t operator++();
    char16_t operator--() volatile;
    char16_t operator--();
    char16_t operator+=(char16_t) volatile;
    char16_t operator+=(char16_t);
    char16_t operator-=(char16_t) volatile;
    char16_t operator-=(char16_t);
    char16_t operator&=(char16_t) volatile;
    char16_t operator&=(char16_t);
    char16_t operator|=(char16_t) volatile;
    char16_t operator|=(char16_t);
    char16_t operator^=(char16_t) volatile;
    char16_t operator^=(char16_t);
} atomic_char16_t;

bool atomic_is_lock_free(const volatile atomic_char16_t*);
bool atomic_is_lock_free(const atomic_char16_t*);
void atomic_init(volatile atomic_char16_t*, char16_t);
void atomic_init(atomic_char16_t*, char16_t);
void atomic_store(volatile atomic_char16_t*, char16_t);
void atomic_store(atomic_char16_t*, char16_t);
void atomic_store_explicit(volatile atomic_char16_t*, char16_t, memory_order);
void atomic_store_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_load(const volatile atomic_char16_t*);
char16_t atomic_load(const atomic_char16_t*);
char16_t atomic_load_explicit(const volatile atomic_char16_t*, memory_order);
char16_t atomic_load_explicit(const atomic_char16_t*, memory_order);
char16_t atomic_exchange(volatile atomic_char16_t*, char16_t);
char16_t atomic_exchange(atomic_char16_t*, char16_t);
char16_t atomic_exchange_explicit(volatile atomic_char16_t*, char16_t,
                                  memory_order);
char16_t atomic_exchange_explicit(atomic_char16_t*, char16_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char16_t*, char16_t*,
                                  char16_t);
bool atomic_compare_exchange_weak(atomic_char16_t*, char16_t*, char16_t);
bool atomic_compare_exchange_strong(volatile atomic_char16_t*, char16_t*,
                                    char16_t);
bool atomic_compare_exchange_strong(atomic_char16_t*, char16_t*, char16_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char16_t*, char16_t*,
                                           char16_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char16_t*, char16_t*,
                                           char16_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char16_t*,
                                             char16_t*, char16_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char16_t*, char16_t*,
                                             char16_t, memory_order,
                                             memory_order);
char16_t atomic_fetch_add(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_add(atomic_char16_t*, char16_t);
char16_t atomic_fetch_add_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_add_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_sub(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_sub(atomic_char16_t*, char16_t);
char16_t atomic_fetch_sub_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_sub_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_and(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_and(atomic_char16_t*, char16_t);
char16_t atomic_fetch_and_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_and_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_or(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_or(atomic_char16_t*, char16_t);
char16_t atomic_fetch_or_explicit(volatile atomic_char16_t*, char16_t,
                                  memory_order);
char16_t atomic_fetch_or_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_xor(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_xor(atomic_char16_t*, char16_t);
char16_t atomic_fetch_xor_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_xor_explicit(atomic_char16_t*, char16_t, memory_order);

// atomic_char32_t

typedef struct atomic_char32_t
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(char32_t, memory_order = memory_order_seq_cst) volatile;
    void store(char32_t, memory_order = memory_order_seq_cst);
    char32_t load(memory_order = memory_order_seq_cst) const volatile;
    char32_t load(memory_order = memory_order_seq_cst) const;
    operator char32_t() const volatile;
    operator char32_t() const;
    char32_t exchange(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t exchange(char32_t, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(char32_t&, char32_t, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(char32_t&, char32_t, memory_order, memory_order);
    bool compare_exchange_strong(char32_t&, char32_t, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(char32_t&, char32_t,
                                 memory_order, memory_order);
    bool compare_exchange_weak(char32_t&, char32_t,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(char32_t&, char32_t,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(char32_t&, char32_t,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(char32_t&, char32_t,
                                 memory_order = memory_order_seq_cst);
    char32_t fetch_add(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t fetch_add(char32_t, memory_order = memory_order_seq_cst);
    char32_t fetch_sub(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t fetch_sub(char32_t, memory_order = memory_order_seq_cst);
    char32_t fetch_and(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t fetch_and(char32_t, memory_order = memory_order_seq_cst);
    char32_t fetch_or(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t fetch_or(char32_t, memory_order = memory_order_seq_cst);
    char32_t fetch_xor(char32_t, memory_order = memory_order_seq_cst) volatile;
    char32_t fetch_xor(char32_t, memory_order = memory_order_seq_cst);
    atomic_char32_t() = default;
    constexpr atomic_char32_t(char32_t);
    atomic_char32_t(const atomic_char32_t&) = delete;
    atomic_char32_t& operator=(const atomic_char32_t&) = delete;
    atomic_char32_t& operator=(const atomic_char32_t&) volatile = delete;
    char32_t operator=(char32_t) volatile;
    char32_t operator=(char32_t);
    char32_t operator++(int) volatile;
    char32_t operator++(int);
    char32_t operator--(int) volatile;
    char32_t operator--(int);
    char32_t operator++() volatile;
    char32_t operator++();
    char32_t operator--() volatile;
    char32_t operator--();
    char32_t operator+=(char32_t) volatile;
    char32_t operator+=(char32_t);
    char32_t operator-=(char32_t) volatile;
    char32_t operator-=(char32_t);
    char32_t operator&=(char32_t) volatile;
    char32_t operator&=(char32_t);
    char32_t operator|=(char32_t) volatile;
    char32_t operator|=(char32_t);
    char32_t operator^=(char32_t) volatile;
    char32_t operator^=(char32_t);
} atomic_char32_t;

bool atomic_is_lock_free(const volatile atomic_char32_t*);
bool atomic_is_lock_free(const atomic_char32_t*);
void atomic_init(volatile atomic_char32_t*, char32_t);
void atomic_init(atomic_char32_t*, char32_t);
void atomic_store(volatile atomic_char32_t*, char32_t);
void atomic_store(atomic_char32_t*, char32_t);
void atomic_store_explicit(volatile atomic_char32_t*, char32_t, memory_order);
void atomic_store_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_load(const volatile atomic_char32_t*);
char32_t atomic_load(const atomic_char32_t*);
char32_t atomic_load_explicit(const volatile atomic_char32_t*, memory_order);
char32_t atomic_load_explicit(const atomic_char32_t*, memory_order);
char32_t atomic_exchange(volatile atomic_char32_t*, char32_t);
char32_t atomic_exchange(atomic_char32_t*, char32_t);
char32_t atomic_exchange_explicit(volatile atomic_char32_t*, char32_t,
                                  memory_order);
char32_t atomic_exchange_explicit(atomic_char32_t*, char32_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char32_t*, char32_t*,
                                  char32_t);
bool atomic_compare_exchange_weak(atomic_char32_t*, char32_t*, char32_t);
bool atomic_compare_exchange_strong(volatile atomic_char32_t*, char32_t*,
                                    char32_t);
bool atomic_compare_exchange_strong(atomic_char32_t*, char32_t*, char32_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char32_t*, char32_t*,
                                           char32_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char32_t*, char32_t*,
                                           char32_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char32_t*,
                                             char32_t*, char32_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char32_t*, char32_t*,
                                             char32_t, memory_order,
                                             memory_order);
char32_t atomic_fetch_add(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_add(atomic_char32_t*, char32_t);
char32_t atomic_fetch_add_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_add_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_sub(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_sub(atomic_char32_t*, char32_t);
char32_t atomic_fetch_sub_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_sub_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_and(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_and(atomic_char32_t*, char32_t);
char32_t atomic_fetch_and_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_and_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_or(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_or(atomic_char32_t*, char32_t);
char32_t atomic_fetch_or_explicit(volatile atomic_char32_t*, char32_t,
                                  memory_order);
char32_t atomic_fetch_or_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_xor(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_xor(atomic_char32_t*, char32_t);
char32_t atomic_fetch_xor_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_xor_explicit(atomic_char32_t*, char32_t, memory_order);

// atomic_wchar_t

typedef struct atomic_wchar_t
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(wchar_t, memory_order = memory_order_seq_cst) volatile;
    void store(wchar_t, memory_order = memory_order_seq_cst);
    wchar_t load(memory_order = memory_order_seq_cst) const volatile;
    wchar_t load(memory_order = memory_order_seq_cst) const;
    operator wchar_t() const volatile;
    operator wchar_t() const;
    wchar_t exchange(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t exchange(wchar_t, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(wchar_t&, wchar_t, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(wchar_t&, wchar_t, memory_order, memory_order);
    bool compare_exchange_strong(wchar_t&, wchar_t, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(wchar_t&, wchar_t, memory_order, memory_order);
    bool compare_exchange_weak(wchar_t&, wchar_t,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(wchar_t&, wchar_t,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(wchar_t&, wchar_t,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(wchar_t&, wchar_t,
                                 memory_order = memory_order_seq_cst);
    wchar_t fetch_add(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t fetch_add(wchar_t, memory_order = memory_order_seq_cst);
    wchar_t fetch_sub(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t fetch_sub(wchar_t, memory_order = memory_order_seq_cst);
    wchar_t fetch_and(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t fetch_and(wchar_t, memory_order = memory_order_seq_cst);
    wchar_t fetch_or(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t fetch_or(wchar_t, memory_order = memory_order_seq_cst);
    wchar_t fetch_xor(wchar_t, memory_order = memory_order_seq_cst) volatile;
    wchar_t fetch_xor(wchar_t, memory_order = memory_order_seq_cst);
    atomic_wchar_t() = default;
    constexpr atomic_wchar_t(wchar_t);
    atomic_wchar_t(const atomic_wchar_t&) = delete;
    atomic_wchar_t& operator=(const atomic_wchar_t&) = delete;
    atomic_wchar_t& operator=(const atomic_wchar_t&) volatile = delete;
    wchar_t operator=(wchar_t) volatile;
    wchar_t operator=(wchar_t);
    wchar_t operator++(int) volatile;
    wchar_t operator++(int);
    wchar_t operator--(int) volatile;
    wchar_t operator--(int);
    wchar_t operator++() volatile;
    wchar_t operator++();
    wchar_t operator--() volatile;
    wchar_t operator--();
    wchar_t operator+=(wchar_t) volatile;
    wchar_t operator+=(wchar_t);
    wchar_t operator-=(wchar_t) volatile;
    wchar_t operator-=(wchar_t);
    wchar_t operator&=(wchar_t) volatile;
    wchar_t operator&=(wchar_t);
    wchar_t operator|=(wchar_t) volatile;
    wchar_t operator|=(wchar_t);
    wchar_t operator^=(wchar_t) volatile;
    wchar_t operator^=(wchar_t);
} atomic_wchar_t;

bool atomic_is_lock_free(const volatile atomic_wchar_t*);
bool atomic_is_lock_free(const atomic_wchar_t*);
void atomic_init(volatile atomic_wchar_t*, wchar_t);
void atomic_init(atomic_wchar_t*, wchar_t);
void atomic_store(volatile atomic_wchar_t*, wchar_t);
void atomic_store(atomic_wchar_t*, wchar_t);
void atomic_store_explicit(volatile atomic_wchar_t*, wchar_t, memory_order);
void atomic_store_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_load(const volatile atomic_wchar_t*);
wchar_t atomic_load(const atomic_wchar_t*);
wchar_t atomic_load_explicit(const volatile atomic_wchar_t*, memory_order);
wchar_t atomic_load_explicit(const atomic_wchar_t*, memory_order);
wchar_t atomic_exchange(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_exchange(atomic_wchar_t*, wchar_t);
wchar_t atomic_exchange_explicit(volatile atomic_wchar_t*,
                                 wchar_t, memory_order);
wchar_t atomic_exchange_explicit(atomic_wchar_t*, wchar_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_wchar_t*, wchar_t*, wchar_t);
bool atomic_compare_exchange_weak(atomic_wchar_t*, wchar_t*, wchar_t);
bool atomic_compare_exchange_strong(volatile atomic_wchar_t*, wchar_t*,
                                    wchar_t);
bool atomic_compare_exchange_strong(atomic_wchar_t*, wchar_t*, wchar_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_wchar_t*, wchar_t*,
                                           wchar_t, memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_wchar_t*, wchar_t*, wchar_t,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_wchar_t*, wchar_t*,
                                             wchar_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_wchar_t*, wchar_t*, wchar_t,
                                             memory_order, memory_order);
wchar_t atomic_fetch_add(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_add(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_add_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_fetch_add_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_sub(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_sub(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_sub_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_fetch_sub_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_and(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_and(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_and_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_fetch_and_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_or(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_or(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_or_explicit(volatile atomic_wchar_t*, wchar_t,
                                 memory_order);
wchar_t atomic_fetch_or_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_xor(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_xor(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_xor_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_fetch_xor_explicit(atomic_wchar_t*, wchar_t, memory_order);

// Atomics for standard typedef types

typedef atomic_schar  atomic_int_least8_t;
typedef atomic_uchar  atomic_uint_least8_t;
typedef atomic_short  atomic_int_least16_t;
typedef atomic_ushort atomic_uint_least16_t;
typedef atomic_int    atomic_int_least32_t;
typedef atomic_uint   atomic_uint_least32_t;
typedef atomic_llong  atomic_int_least64_t;
typedef atomic_ullong atomic_uint_least64_t;

typedef atomic_schar  atomic_int_fast8_t;
typedef atomic_uchar  atomic_uint_fast8_t;
typedef atomic_short  atomic_int_fast16_t;
typedef atomic_ushort atomic_uint_fast16_t;
typedef atomic_int    atomic_int_fast32_t;
typedef atomic_uint   atomic_uint_fast32_t;
typedef atomic_llong  atomic_int_fast64_t;
typedef atomic_ullong atomic_uint_fast64_t;

typedef atomic_long   atomic_intptr_t;
typedef atomic_ulong  atomic_uintptr_t;
typedef atomic_ulong  atomic_size_t;
typedef atomic_long   atomic_ptrdiff_t;
typedef atomic_llong  atomic_intmax_t;
typedef atomic_ullong atomic_uintmax_t;

// address types

typedef struct atomic_address
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(void*, memory_order = memory_order_seq_cst) volatile;
    void store(void*, memory_order = memory_order_seq_cst);
    void* load(memory_order = memory_order_seq_cst) const volatile;
    void* load(memory_order = memory_order_seq_cst) const;
    operator void*() const volatile;
    operator void*() const;
    void* exchange(void*, memory_order = memory_order_seq_cst) volatile;
    void* exchange(void*, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(void*&, void*, memory_order,
                               memory_order) volatile;
    bool compare_exchange_weak(void*&, void*, memory_order, memory_order);
    bool compare_exchange_strong(void*&, void*, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(void*&, void*, memory_order, memory_order);
    bool compare_exchange_weak(void*&, void*,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(void*&, void*,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(void*&, void*,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(void*&, void*,
                                 memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(const void*&, const void*,
                               memory_order, memory_order) volatile;
    bool compare_exchange_weak(const void*&, const void*, memory_order,
                               memory_order);
    bool compare_exchange_strong(const void*&, const void*, memory_order,
                                 memory_order) volatile;
    bool compare_exchange_strong(const void*&, const void*, memory_order,
                                 memory_order);
    bool compare_exchange_weak(const void*&, const void*,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(const void*&, const void*,
                               memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(const void*&, const void*,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(const void*&, const void*,
                                 memory_order = memory_order_seq_cst);
    void* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;
    void* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst);
    void* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;
    void* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst);
    atomic_address() = default;
    constexpr atomic_address(void*);
    atomic_address(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) volatile = delete;
    void* operator=(const void*) volatile;
    void* operator=(const void*);
    void* operator+=(ptrdiff_t) volatile;
    void* operator+=(ptrdiff_t);
    void* operator-=(ptrdiff_t) volatile;
    void* operator-=(ptrdiff_t);
} atomic_address;

bool atomic_is_lock_free(const volatile atomic_address*);
bool atomic_is_lock_free(const atomic_address*);
void atomic_init(volatile atomic_address*, void*);
void atomic_init(atomic_address*, void*);
void atomic_store(volatile atomic_address*, void*);
void atomic_store(atomic_address*, void*);
void atomic_store_explicit(volatile atomic_address*, void*, memory_order);
void atomic_store_explicit(atomic_address*, void*, memory_order);
void* atomic_load(const volatile atomic_address*);
void* atomic_load(const atomic_address*);
void* atomic_load_explicit(const volatile atomic_address*, memory_order);
void* atomic_load_explicit(const atomic_address*, memory_order);
void* atomic_exchange(volatile atomic_address*, void*);
void* atomic_exchange(atomic_address*, void*);
void* atomic_exchange_explicit(volatile atomic_address*, void*, memory_order);
void* atomic_exchange_explicit(atomic_address*, void*, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_address*, void**, void*);
bool atomic_compare_exchange_weak(atomic_address*, void**, void*);
bool atomic_compare_exchange_strong(volatile atomic_address*, void**, void*);
bool atomic_compare_exchange_strong(atomic_address*, void**, void*);
bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, void**,
                                           void*, memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_address*, void**, void*,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, void**,
                                             void*, memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_address*, void**, void*,
                                             memory_order, memory_order);
void* atomic_fetch_add(volatile atomic_address*, ptrdiff_t);
void* atomic_fetch_add(atomic_address*, ptrdiff_t);
void* atomic_fetch_add_explicit(volatile atomic_address*, ptrdiff_t,
                                memory_order);
void* atomic_fetch_add_explicit(atomic_address*, ptrdiff_t, memory_order);
void* atomic_fetch_sub(volatile atomic_address*, ptrdiff_t);
void* atomic_fetch_sub(atomic_address*, ptrdiff_t);
void* atomic_fetch_sub_explicit(volatile atomic_address*, ptrdiff_t,
                                memory_order);
void* atomic_fetch_sub_explicit(atomic_address*, ptrdiff_t, memory_order);

// generic types

template <class T>
struct atomic
{
    bool is_lock_free() const volatile;
    bool is_lock_free() const;
    void store(T, memory_order = memory_order_seq_cst) volatile;
    void store(T, memory_order = memory_order_seq_cst);
    T load(memory_order = memory_order_seq_cst) const volatile;
    T load(memory_order = memory_order_seq_cst) const;
    operator T() const volatile;
    operator T() const;
    T exchange(T, memory_order = memory_order_seq_cst) volatile;
    T exchange(T, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(T&, T, memory_order, memory_order) volatile;
    bool compare_exchange_weak(T&, T, memory_order, memory_order);
    bool compare_exchange_strong(T&, T, memory_order, memory_order) volatile;
    bool compare_exchange_strong(T&, T, memory_order, memory_order);
    bool compare_exchange_weak(T&, T,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(T&, T, memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(T&, T,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(T&, T, memory_order = memory_order_seq_cst);

    atomic() = default;
    constexpr atomic(T);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T operator=(T) volatile;
    T operator=(T);
};

template <>
struct atomic<bool>
    : public atomic_bool
{
    atomic() = default;
    constexpr atomic(bool);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    bool operator=(bool) volatile;
    bool operator=(bool);
    operator bool() const volatile;
    operator bool() const;
};

template <>
struct atomic<char>
    : public atomic_char
{
    atomic() = default;
    constexpr atomic(char);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    char operator=(char) volatile;
    char operator=(char);
    operator char() const volatile;
    operator char() const;
};

template <>
struct atomic<signed char>
    : public atomic_schar
{
    atomic() = default;
    constexpr atomic(signed char);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    signed char operator=(signed char) volatile;
    signed char operator=(signed char);
    operator signed char() const volatile;
    operator signed char() const;
};

template <>
struct atomic<unsigned char>
    : public atomic_uchar
{
    atomic() = default;
    constexpr atomic(unsigned char);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    unsigned char operator=(unsigned char) volatile;
    unsigned char operator=(unsigned char);
    operator unsigned char() const volatile;
    operator unsigned char() const;
};

template <>
struct atomic<short>
    : public atomic_short
{
    atomic() = default;
    constexpr atomic(short);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    short operator=(short) volatile;
    short operator=(short);
    operator short() const volatile;
    operator short() const;
};

template <>
struct atomic<unsigned short>
    : public atomic_ushort
{
    atomic() = default;
    constexpr atomic(unsigned short);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    unsigned short operator=(unsigned short) volatile;
    unsigned short operator=(unsigned short);
    operator unsigned short() const volatile;
    operator unsigned short() const;
};

template <>
struct atomic<int>
    : public atomic_int
{
    atomic() = default;
    constexpr atomic(int);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    int operator=(int) volatile;
    int operator=(int);
    operator int() const volatile;
    operator int() const;
};

template <>
struct atomic<unsigned int>
    : public atomic_uint
{
    atomic() = default;
    constexpr atomic(unsigned int);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    unsigned int operator=(unsigned int) volatile;
    unsigned int operator=(unsigned int);
    operator unsigned int() const volatile;
    operator unsigned int() const;
};

template <>
struct atomic<long>
    : public atomic_long
{
    atomic() = default;
    constexpr atomic(long);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    long operator=(long) volatile;
    long operator=(long);
    operator long() const volatile;
    operator long() const;
};

template <>
struct atomic<unsigned long>
    : public atomic_ulong
{
    atomic() = default;
    constexpr atomic(unsigned long);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    unsigned long operator=(unsigned long) volatile;
    unsigned long operator=(unsigned long);
    operator unsigned long() const volatile;
    operator unsigned long() const;
};

template <>
struct atomic<long long>
    : public atomic_llong
{
    atomic() = default;
    constexpr atomic(long long);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    long long operator=(long long) volatile;
    long long operator=(long long);
    operator long long() const volatile;
    operator long long() const;
};

template <>
struct atomic<unsigned long long>
    : public atomic_ullong
{
    atomic() = default;
    constexpr atomic(unsigned long long);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    unsigned long long operator=(unsigned long long) volatile;
    unsigned long long operator=(unsigned long long);
    operator unsigned long long() const volatile;
    operator unsigned long long() const;
};

template <>
struct atomic<char16_t>
    : public atomic_char16_t
{
    atomic() = default;
    constexpr atomic(char16_t);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    char16_t operator=(char16_t) volatile;
    char16_t operator=(char16_t);
    operator char16_t() const volatile;
    operator char16_t() const;
};

template <>
struct atomic<char32_t>
    : public atomic_char32_t
{
    atomic() = default;
    constexpr atomic(char32_t);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    char32_t operator=(char32_t) volatile;
    char32_t operator=(char32_t);
    operator char32_t() const volatile;
    operator char32_t() const;
};

template <>
struct atomic<wchar_t>
    : public atomic_wchar_t
{
    atomic() = default;
    constexpr atomic(wchar_t);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    wchar_t operator=(wchar_t) volatile;
    wchar_t operator=(wchar_t);
    operator wchar_t() const volatile;
    operator wchar_t() const;
};

template <class T>
struct atomic<T*>
    : public atomic_address
{
    void store(T*, memory_order = memory_order_seq_cst) volatile;
    void store(T*, memory_order = memory_order_seq_cst);
    T* load(memory_order = memory_order_seq_cst) const volatile;
    T* load(memory_order = memory_order_seq_cst) const;
    operator T*() const volatile;
    operator T*() const;
    T* exchange(T*, memory_order = memory_order_seq_cst) volatile;
    T* exchange(T*, memory_order = memory_order_seq_cst);
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order) volatile;
    bool compare_exchange_weak(T*&, T*, memory_order, memory_order);
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order) volatile;
    bool compare_exchange_strong(T*&, T*, memory_order, memory_order);
    bool compare_exchange_weak(T*&, T*,
                               memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_weak(T*&, T*, memory_order = memory_order_seq_cst);
    bool compare_exchange_strong(T*&, T*,
                                 memory_order = memory_order_seq_cst) volatile;
    bool compare_exchange_strong(T*&, T*, memory_order = memory_order_seq_cst);
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;
    T* fetch_add(ptrdiff_t, memory_order = memory_order_seq_cst);
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst) volatile;
    T* fetch_sub(ptrdiff_t, memory_order = memory_order_seq_cst);
    atomic() = default;
    constexpr atomic(T*);
    atomic(const atomic&) = delete;
    atomic& operator=(const atomic&) = delete;
    atomic& operator=(const atomic&) volatile = delete;
    T* operator=(T*) volatile;
    T* operator=(T*);
    T* operator++(int) volatile;
    T* operator++(int);
    T* operator--(int) volatile;
    T* operator--(int);
    T* operator++() volatile;
    T* operator++();
    T* operator--() volatile;
    T* operator--();
    T* operator+=(ptrdiff_t) volatile;
    T* operator+=(ptrdiff_t);
    T* operator-=(ptrdiff_t) volatile;
    T* operator-=(ptrdiff_t);
};

// fences

void atomic_thread_fence(memory_order);
void atomic_signal_fence(memory_order);

}  // std

*/

#include <__config>

#pragma GCC system_header

_LIBCPP_BEGIN_NAMESPACE_STD

typedef enum memory_order
{
    memory_order_relaxed, memory_order_consume, memory_order_acquire,
    memory_order_release, memory_order_acq_rel, memory_order_seq_cst
} memory_order;

template <class _Tp>
inline _LIBCPP_INLINE_VISIBILITY
_Tp
kill_dependency(_Tp __y)
{
    return __y;
}

// flag type and operations

typedef bool __atomic_flag__;

struct atomic_flag;

bool atomic_flag_test_and_set(volatile atomic_flag*);
bool atomic_flag_test_and_set(atomic_flag*);
bool atomic_flag_test_and_set_explicit(volatile atomic_flag*, memory_order);
bool atomic_flag_test_and_set_explicit(atomic_flag*, memory_order);
void atomic_flag_clear(volatile atomic_flag*);
void atomic_flag_clear(atomic_flag*);
void atomic_flag_clear_explicit(volatile atomic_flag*, memory_order);
void atomic_flag_clear_explicit(atomic_flag*, memory_order);

typedef struct _LIBCPP_VISIBLE atomic_flag
{
    __atomic_flag__ __flg_;

    _LIBCPP_INLINE_VISIBILITY
    bool test_and_set(memory_order __o = memory_order_seq_cst) volatile
        {return atomic_flag_test_and_set_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool test_and_set(memory_order __o = memory_order_seq_cst)
        {return atomic_flag_test_and_set_explicit(this, __o);}

    _LIBCPP_INLINE_VISIBILITY
    void clear(memory_order __o = memory_order_seq_cst) volatile
        {atomic_flag_clear_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void clear(memory_order __o = memory_order_seq_cst)
        {atomic_flag_clear_explicit(this, __o);}

#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_flag() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_flag() {};
#endif

#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_flag(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) = delete;
    atomic_flag& operator=(const atomic_flag&) volatile = delete;
#else
private:
    atomic_flag(const atomic_flag&);
    atomic_flag& operator=(const atomic_flag&);
    atomic_flag& operator=(const atomic_flag&) volatile;
public:
#endif
} atomic_flag;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_flag_test_and_set(volatile atomic_flag* __f)
{
    return __atomic_exchange(&__f->__flg_, __atomic_flag__(true),
                             memory_order_seq_cst)
            == __atomic_flag__(true);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_flag_test_and_set(atomic_flag* __f)
{
    return atomic_flag_test_and_set(const_cast<volatile atomic_flag*>(__f));
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_flag_test_and_set_explicit(volatile atomic_flag* __f, memory_order __o)
{
    return __atomic_exchange(&__f->__flg_, __atomic_flag__(true), __o)
            == __atomic_flag__(true);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_flag_test_and_set_explicit(atomic_flag* __f, memory_order __o)
{
    return atomic_flag_test_and_set_explicit(const_cast<volatile atomic_flag*>
                                                                    (__f), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_flag_clear(volatile atomic_flag* __f)
{
    __atomic_store(&__f->__flg_, __atomic_flag__(false), memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_flag_clear(atomic_flag* __f)
{
    atomic_flag_clear(const_cast<volatile atomic_flag*>(__f));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_flag_clear_explicit(volatile atomic_flag* __f, memory_order __o)
{
    __atomic_store(&__f->__flg_, __atomic_flag__(false), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_flag_clear_explicit(atomic_flag* __f, memory_order __o)
{
    atomic_flag_clear_explicit(const_cast<volatile atomic_flag*>(__f), __o);
}

#define ATOMIC_FLAG_INIT {false}
#define ATOMIC_VAR_INIT(__v) {__v}

inline _LIBCPP_INLINE_VISIBILITY
memory_order
__translate_memory_order(memory_order __o)
{
    switch (__o)
    {
    case memory_order_acq_rel:
        return memory_order_acquire;
    case memory_order_release:
        return memory_order_relaxed;
    }
    return __o;
}

// atomic_bool

struct atomic_bool;

bool atomic_is_lock_free(const volatile atomic_bool*);
bool atomic_is_lock_free(const atomic_bool*);
void atomic_init(volatile atomic_bool*, bool);
void atomic_init(atomic_bool*, bool);
void atomic_store(volatile atomic_bool*, bool);
void atomic_store(atomic_bool*, bool);
void atomic_store_explicit(volatile atomic_bool*, bool, memory_order);
void atomic_store_explicit(atomic_bool*, bool, memory_order);
bool atomic_load(const volatile atomic_bool*);
bool atomic_load(const atomic_bool*);
bool atomic_load_explicit(const volatile atomic_bool*, memory_order);
bool atomic_load_explicit(const atomic_bool*, memory_order);
bool atomic_exchange(volatile atomic_bool*, bool);
bool atomic_exchange(atomic_bool*, bool);
bool atomic_exchange_explicit(volatile atomic_bool*, bool, memory_order);
bool atomic_exchange_explicit(atomic_bool*, bool, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_bool*, bool*, bool);
bool atomic_compare_exchange_weak(atomic_bool*, bool*, bool);
bool atomic_compare_exchange_strong(volatile atomic_bool*, bool*, bool);
bool atomic_compare_exchange_strong(atomic_bool*, bool*, bool);
bool atomic_compare_exchange_weak_explicit(volatile atomic_bool*, bool*, bool,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_bool*, bool*, bool,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_bool*, bool*, bool,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_bool*, bool*, bool,
                                             memory_order, memory_order);

typedef struct atomic_bool
{
    bool __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(bool __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(bool __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator bool() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator bool() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    bool exchange(bool __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool exchange(bool __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(bool& __v, bool __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(bool& __v, bool __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(bool& __v, bool __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(bool& __v, bool __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(bool& __v, bool __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(bool& __v, bool __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(bool& __v, bool __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(bool& __v, bool __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_bool() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_bool() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_bool(bool __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_bool(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) = delete;
    atomic_bool& operator=(const atomic_bool&) volatile = delete;
#else
private:
    atomic_bool(const atomic_bool&);
    atomic_bool& operator=(const atomic_bool&);
    atomic_bool& operator=(const atomic_bool&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    bool operator=(bool __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    bool operator=(bool __v)
        {store(__v); return __v;}
} atomic_bool;

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_is_lock_free(const volatile atomic_bool*)
{
    typedef bool type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_is_lock_free(const atomic_bool* __obj)
{
    return atomic_is_lock_free(const_cast<const volatile atomic_bool*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_init(volatile atomic_bool* __obj, bool __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_init(atomic_bool* __obj, bool __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_store(volatile atomic_bool* __obj, bool __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_store(atomic_bool* __obj, bool __desr)
{
    atomic_store(const_cast<volatile atomic_bool*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_store_explicit(volatile atomic_bool* __obj, bool __desr,
                           memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void atomic_store_explicit(atomic_bool* __obj, bool __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_bool*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_load(const volatile atomic_bool* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_load(const atomic_bool* __obj)
{
    return atomic_load(const_cast<const volatile atomic_bool*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_load_explicit(const volatile atomic_bool* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_load_explicit(const atomic_bool* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_bool*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_exchange(volatile atomic_bool* __obj, bool __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_exchange(atomic_bool* __obj, bool __desr)
{
    return atomic_exchange(const_cast<volatile atomic_bool*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_exchange_explicit(volatile atomic_bool* __obj, bool __desr,
                              memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_exchange_explicit(atomic_bool* __obj, bool __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_bool*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_weak(volatile atomic_bool* __obj, bool* __exp,
                                  bool __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_weak(atomic_bool* __obj, bool* __exp, bool __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_bool*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_weak_explicit(volatile atomic_bool* __obj,
                                           bool* __exp, bool __desr,
                                           memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_weak_explicit(atomic_bool* __obj, bool* __exp,
                                           bool __desr,
                                           memory_order __s, memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_bool*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_strong(volatile atomic_bool* __obj, bool* __exp,
                                    bool __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_strong(atomic_bool* __obj, bool* __exp,
                                    bool __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_bool*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_strong_explicit(volatile atomic_bool* __obj,
                                             bool* __exp, bool __desr,
                                             memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool atomic_compare_exchange_strong_explicit(atomic_bool* __obj, bool* __exp,
                                             bool __desr,
                                             memory_order __s, memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_bool*>(__obj), __exp, __desr, __s, __f);
}

// atomic_char

struct atomic_char;

bool atomic_is_lock_free(const volatile atomic_char*);
bool atomic_is_lock_free(const atomic_char*);
void atomic_init(volatile atomic_char*, char);
void atomic_init(atomic_char*, char);
void atomic_store(volatile atomic_char*, char);
void atomic_store(atomic_char*, char);
void atomic_store_explicit(volatile atomic_char*, char, memory_order);
void atomic_store_explicit(atomic_char*, char, memory_order);
char atomic_load(const volatile atomic_char*);
char atomic_load(const atomic_char*);
char atomic_load_explicit(const volatile atomic_char*, memory_order);
char atomic_load_explicit(const atomic_char*, memory_order);
char atomic_exchange(volatile atomic_char*, char);
char atomic_exchange(atomic_char*, char);
char atomic_exchange_explicit(volatile atomic_char*, char, memory_order);
char atomic_exchange_explicit(atomic_char*, char, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char*, char*, char);
bool atomic_compare_exchange_weak(atomic_char*, char*, char);
bool atomic_compare_exchange_strong(volatile atomic_char*, char*, char);
bool atomic_compare_exchange_strong(atomic_char*, char*, char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char*, char*, char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char*, char*, char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char*, char*, char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char*, char*, char,
                                             memory_order, memory_order);
char atomic_fetch_add(volatile atomic_char*, char);
char atomic_fetch_add(atomic_char*, char);
char atomic_fetch_add_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_add_explicit(atomic_char*, char, memory_order);
char atomic_fetch_sub(volatile atomic_char*, char);
char atomic_fetch_sub(atomic_char*, char);
char atomic_fetch_sub_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_sub_explicit(atomic_char*, char, memory_order);
char atomic_fetch_and(volatile atomic_char*, char);
char atomic_fetch_and(atomic_char*, char);
char atomic_fetch_and_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_and_explicit(atomic_char*, char, memory_order);
char atomic_fetch_or(volatile atomic_char*, char);
char atomic_fetch_or(atomic_char*, char);
char atomic_fetch_or_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_or_explicit(atomic_char*, char, memory_order);
char atomic_fetch_xor(volatile atomic_char*, char);
char atomic_fetch_xor(atomic_char*, char);
char atomic_fetch_xor_explicit(volatile atomic_char*, char, memory_order);
char atomic_fetch_xor_explicit(atomic_char*, char, memory_order);

typedef struct atomic_char
{
    char __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator char() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator char() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    char exchange(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char exchange(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char& __v, char __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char& __v, char __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char& __v, char __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char& __v, char __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char& __v, char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char& __v, char __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char& __v, char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char& __v, char __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_add(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_add(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_sub(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_sub(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_and(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_and(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_or(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_or(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_xor(char __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char fetch_xor(char __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_char() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_char() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_char(char __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_char(const atomic_char&) = delete;
    atomic_char& operator=(const atomic_char&) = delete;
    atomic_char& operator=(const atomic_char&) volatile = delete;
#else
private:
    atomic_char(const atomic_char&);
    atomic_char& operator=(const atomic_char&);
    atomic_char& operator=(const atomic_char&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    char operator=(char __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char operator=(char __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char operator++(int) volatile
        {return fetch_add(char(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++(int)
        {return fetch_add(char(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int) volatile
        {return fetch_sub(char(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int)
        {return fetch_sub(char(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++() volatile
        {return char(fetch_add(char(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator++()
        {return char(fetch_add(char(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--() volatile
        {return char(fetch_sub(char(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--()
        {return char(fetch_sub(char(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v) volatile
        {return char(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v)
        {return char(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v) volatile
        {return char(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v)
        {return char(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v) volatile
        {return char(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v)
        {return char(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v) volatile
        {return char(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v)
        {return char(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v) volatile
        {return char(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v)
        {return char(fetch_xor(__v) ^ __v);}
} atomic_char;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_char*)
{
    typedef char type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_char* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_char*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_char* __obj, char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_char* __obj, char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_char* __obj, char __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_char* __obj, char __desr)
{
    atomic_store(const_cast<volatile atomic_char*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_char* __obj, char __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_char* __obj, char __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_char*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_load(const volatile atomic_char* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_load(const atomic_char* __obj)
{
    return atomic_load(const_cast<const volatile atomic_char*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_load_explicit(const volatile atomic_char* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_load_explicit(const atomic_char* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_char*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_exchange(volatile atomic_char* __obj, char __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_exchange(atomic_char* __obj, char __desr)
{
    return atomic_exchange(const_cast<volatile atomic_char*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_exchange_explicit(volatile atomic_char* __obj, char __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_exchange_explicit(atomic_char* __obj, char __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_char*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_char* __obj, char* __exp,
                             char __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_char* __obj, char* __exp, char __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_char*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_char* __obj, char* __exp,
                               char __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_char* __obj, char* __exp, char __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_char*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_char* __obj, char* __exp,
                                      char __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_char* __obj, char* __exp,
                                      char __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_char*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_char* __obj,
                                        char* __exp, char __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_char* __obj, char* __exp,
                                        char __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_char*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_add(volatile atomic_char* __obj, char __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_add(atomic_char* __obj, char __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_char*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_add_explicit(volatile atomic_char* __obj, char __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_add_explicit(atomic_char* __obj, char __v, memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_char*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_sub(volatile atomic_char* __obj, char __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_sub(atomic_char* __obj, char __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_char*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_sub_explicit(volatile atomic_char* __obj, char __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_sub_explicit(atomic_char* __obj, char __v, memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_char*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_and(volatile atomic_char* __obj, char __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_and(atomic_char* __obj, char __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_char*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_and_explicit(volatile atomic_char* __obj, char __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_and_explicit(atomic_char* __obj, char __v, memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_char*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_or(volatile atomic_char* __obj, char __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_or(atomic_char* __obj, char __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_char*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_or_explicit(volatile atomic_char* __obj, char __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_or_explicit(atomic_char* __obj, char __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_char*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_xor(volatile atomic_char* __obj, char __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_xor(atomic_char* __obj, char __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_char*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_xor_explicit(volatile atomic_char* __obj, char __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char
atomic_fetch_xor_explicit(atomic_char* __obj, char __v, memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_char*>(__obj),
                                                                      __v, __o);
}

// atomic_schar

struct atomic_schar;

bool atomic_is_lock_free(const volatile atomic_schar*);
bool atomic_is_lock_free(const atomic_schar*);
void atomic_init(volatile atomic_schar*, signed char);
void atomic_init(atomic_schar*, signed char);
void atomic_store(volatile atomic_schar*, signed char);
void atomic_store(atomic_schar*, signed char);
void atomic_store_explicit(volatile atomic_schar*, signed char, memory_order);
void atomic_store_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_load(const volatile atomic_schar*);
signed char atomic_load(const atomic_schar*);
signed char atomic_load_explicit(const volatile atomic_schar*, memory_order);
signed char atomic_load_explicit(const atomic_schar*, memory_order);
signed char atomic_exchange(volatile atomic_schar*, signed char);
signed char atomic_exchange(atomic_schar*, signed char);
signed char atomic_exchange_explicit(volatile atomic_schar*, signed char,
                                     memory_order);
signed char atomic_exchange_explicit(atomic_schar*, signed char, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_schar*, signed char*,
                                  signed char);
bool atomic_compare_exchange_weak(atomic_schar*, signed char*, signed char);
bool atomic_compare_exchange_strong(volatile atomic_schar*, signed char*,
                                    signed char);
bool atomic_compare_exchange_strong(atomic_schar*, signed char*, signed char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_schar*, signed char*,
                                           signed char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_schar*, signed char*,
                                           signed char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_schar*,
                                             signed char*, signed char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_schar*, signed char*,
                                             signed char, memory_order,
                                             memory_order);
signed char atomic_fetch_add(volatile atomic_schar*, signed char);
signed char atomic_fetch_add(atomic_schar*, signed char);
signed char atomic_fetch_add_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_add_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_sub(volatile atomic_schar*, signed char);
signed char atomic_fetch_sub(atomic_schar*, signed char);
signed char atomic_fetch_sub_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_sub_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_and(volatile atomic_schar*, signed char);
signed char atomic_fetch_and(atomic_schar*, signed char);
signed char atomic_fetch_and_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_and_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_or(volatile atomic_schar*, signed char);
signed char atomic_fetch_or(atomic_schar*, signed char);
signed char atomic_fetch_or_explicit(volatile atomic_schar*, signed char,
                                     memory_order);
signed char atomic_fetch_or_explicit(atomic_schar*, signed char, memory_order);
signed char atomic_fetch_xor(volatile atomic_schar*, signed char);
signed char atomic_fetch_xor(atomic_schar*, signed char);
signed char atomic_fetch_xor_explicit(volatile atomic_schar*, signed char,
                                      memory_order);
signed char atomic_fetch_xor_explicit(atomic_schar*, signed char, memory_order);

typedef struct atomic_schar
{
    signed char __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(signed char __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(signed char __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator signed char() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator signed char() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    signed char exchange(signed char __v,
                         memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char exchange(signed char __v,
                         memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(signed char& __v, signed char __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(signed char& __v, signed char __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(signed char& __v, signed char __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(signed char& __v, signed char __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(signed char& __v, signed char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(signed char& __v, signed char __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(signed char& __v, signed char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(signed char& __v, signed char __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_add(signed char __v,
                          memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_add(signed char __v,
                          memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_sub(signed char __v,
                          memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_sub(signed char __v,
                          memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_and(signed char __v,
                          memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_and(signed char __v,
                          memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_or(signed char __v,
                         memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_or(signed char __v,
                         memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_xor(signed char __v,
                          memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    signed char fetch_xor(signed char __v,
                          memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_schar() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_schar() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_schar(signed char __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_schar(const atomic_schar&) = delete;
    atomic_schar& operator=(const atomic_schar&) = delete;
    atomic_schar& operator=(const atomic_schar&) volatile = delete;
#else
private:
    atomic_schar(const atomic_schar&);
    atomic_schar& operator=(const atomic_schar&);
    atomic_schar& operator=(const atomic_schar&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    signed char operator=(signed char __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    signed char operator=(signed char __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    signed char operator++(int) volatile
        {typedef signed char type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++(int)
        {typedef signed char type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int) volatile
        {typedef signed char type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int)
        {typedef signed char type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++() volatile
        {typedef signed char type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator++()
        {typedef signed char type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--() volatile
        {typedef signed char type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--()
        {typedef signed char type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v) volatile
        {typedef signed char type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v)
        {typedef signed char type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v) volatile
        {typedef signed char type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v)
        {typedef signed char type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v) volatile
        {typedef signed char type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v)
        {typedef signed char type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v) volatile
        {typedef signed char type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v)
        {typedef signed char type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v) volatile
        {typedef signed char type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v)
        {typedef signed char type; return type(fetch_xor(__v) ^ __v);}
} atomic_schar;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_schar*)
{
    typedef signed char type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_schar* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_schar*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_schar* __obj, signed char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_schar* __obj, signed char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_schar* __obj, signed char __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_schar* __obj, signed char __desr)
{
    atomic_store(const_cast<volatile atomic_schar*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_schar* __obj, signed char __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_schar* __obj, signed char __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_schar*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_load(const volatile atomic_schar* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_load(const atomic_schar* __obj)
{
    return atomic_load(const_cast<const volatile atomic_schar*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_load_explicit(const volatile atomic_schar* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_load_explicit(const atomic_schar* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_schar*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_exchange(volatile atomic_schar* __obj, signed char __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_exchange(atomic_schar* __obj, signed char __desr)
{
    return atomic_exchange(const_cast<volatile atomic_schar*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_exchange_explicit(volatile atomic_schar* __obj, signed char __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_exchange_explicit(atomic_schar* __obj, signed char __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_schar*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_schar* __obj, signed char* __exp,
                             signed char __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_schar* __obj, signed char* __exp,
                             signed char __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_schar*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_schar* __obj, signed char* __exp,
                               signed char __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_schar* __obj, signed char* __exp,
                               signed char __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_schar*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_schar* __obj,
                                      signed char* __exp, signed char __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_schar* __obj, signed char* __exp,
                                      signed char __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_schar*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_schar* __obj,
                                        signed char* __exp, signed char __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_schar* __obj, signed char* __exp,
                                        signed char __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_schar*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_add(volatile atomic_schar* __obj, signed char __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_add(atomic_schar* __obj, signed char __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_schar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_add_explicit(volatile atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_add_explicit(atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_schar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_sub(volatile atomic_schar* __obj, signed char __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_sub(atomic_schar* __obj, signed char __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_schar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_sub_explicit(volatile atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_sub_explicit(atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_schar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_and(volatile atomic_schar* __obj, signed char __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_and(atomic_schar* __obj, signed char __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_schar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_and_explicit(volatile atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_and_explicit(atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_schar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_or(volatile atomic_schar* __obj, signed char __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_or(atomic_schar* __obj, signed char __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_schar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_or_explicit(volatile atomic_schar* __obj, signed char __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_or_explicit(atomic_schar* __obj, signed char __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_schar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_xor(volatile atomic_schar* __obj, signed char __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_xor(atomic_schar* __obj, signed char __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_schar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_xor_explicit(volatile atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
signed char
atomic_fetch_xor_explicit(atomic_schar* __obj, signed char __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_schar*>(__obj),
                                                                      __v, __o);
}

// atomic_uchar

struct atomic_uchar;

bool atomic_is_lock_free(const volatile atomic_uchar*);
bool atomic_is_lock_free(const atomic_uchar*);
void atomic_init(volatile atomic_uchar*, unsigned char);
void atomic_init(atomic_uchar*, unsigned char);
void atomic_store(volatile atomic_uchar*, unsigned char);
void atomic_store(atomic_uchar*, unsigned char);
void atomic_store_explicit(volatile atomic_uchar*, unsigned char, memory_order);
void atomic_store_explicit(atomic_uchar*, unsigned char, memory_order);
unsigned char atomic_load(const volatile atomic_uchar*);
unsigned char atomic_load(const atomic_uchar*);
unsigned char atomic_load_explicit(const volatile atomic_uchar*, memory_order);
unsigned char atomic_load_explicit(const atomic_uchar*, memory_order);
unsigned char atomic_exchange(volatile atomic_uchar*, unsigned char);
unsigned char atomic_exchange(atomic_uchar*, unsigned char);
unsigned char atomic_exchange_explicit(volatile atomic_uchar*, unsigned char,
                                     memory_order);
unsigned char atomic_exchange_explicit(atomic_uchar*, unsigned char,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_uchar*, unsigned char*,
                                  unsigned char);
bool atomic_compare_exchange_weak(atomic_uchar*, unsigned char*, unsigned char);
bool atomic_compare_exchange_strong(volatile atomic_uchar*, unsigned char*,
                                    unsigned char);
bool atomic_compare_exchange_strong(atomic_uchar*, unsigned char*,
                                    unsigned char);
bool atomic_compare_exchange_weak_explicit(volatile atomic_uchar*,
                                           unsigned char*, unsigned char,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_uchar*, unsigned char*,
                                           unsigned char, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_uchar*,
                                             unsigned char*, unsigned char,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_uchar*, unsigned char*,
                                             unsigned char, memory_order,
                                             memory_order);
unsigned char atomic_fetch_add(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_add(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_add_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_add_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_sub(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_sub(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_sub_explicit(volatile atomic_uchar*, unsigned char,
                                      memory_order);
unsigned char atomic_fetch_sub_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_and(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_and(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_and_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_and_explicit(atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_or(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_or(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_or_explicit(volatile atomic_uchar*, unsigned char,
                                       memory_order);
unsigned char atomic_fetch_or_explicit(atomic_uchar*, unsigned char,
                                       memory_order);
unsigned char atomic_fetch_xor(volatile atomic_uchar*, unsigned char);
unsigned char atomic_fetch_xor(atomic_uchar*, unsigned char);
unsigned char atomic_fetch_xor_explicit(volatile atomic_uchar*, unsigned char,
                                        memory_order);
unsigned char atomic_fetch_xor_explicit(atomic_uchar*, unsigned char,
                                        memory_order);

typedef struct atomic_uchar
{
    unsigned char __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned char __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned char __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned char() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned char() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char exchange(unsigned char __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char exchange(unsigned char __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned char& __v, unsigned char __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned char& __v, unsigned char __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned char& __v, unsigned char __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned char& __v, unsigned char __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned char& __v, unsigned char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned char& __v, unsigned char __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned char& __v, unsigned char __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned char& __v, unsigned char __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_add(unsigned char __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_add(unsigned char __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_sub(unsigned char __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_sub(unsigned char __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_and(unsigned char __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_and(unsigned char __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_or(unsigned char __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_or(unsigned char __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_xor(unsigned char __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char fetch_xor(unsigned char __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_uchar() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_uchar() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_uchar(unsigned char __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_uchar(const atomic_uchar&) = delete;
    atomic_uchar& operator=(const atomic_uchar&) = delete;
    atomic_uchar& operator=(const atomic_uchar&) volatile = delete;
#else
private:
    atomic_uchar(const atomic_uchar&);
    atomic_uchar& operator=(const atomic_uchar&);
    atomic_uchar& operator=(const atomic_uchar&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    unsigned char operator=(unsigned char __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char operator=(unsigned char __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned char operator++(int) volatile
        {typedef unsigned char type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++(int)
        {typedef unsigned char type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int) volatile
        {typedef unsigned char type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator--(int)
        {typedef unsigned char type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    char operator++() volatile
        {typedef unsigned char type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator++()
        {typedef unsigned char type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--() volatile
        {typedef unsigned char type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator--()
        {typedef unsigned char type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v) volatile
        {typedef unsigned char type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator+=(char __v)
        {typedef unsigned char type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v) volatile
        {typedef unsigned char type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator-=(char __v)
        {typedef unsigned char type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v) volatile
        {typedef unsigned char type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator&=(char __v)
        {typedef unsigned char type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v) volatile
        {typedef unsigned char type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator|=(char __v)
        {typedef unsigned char type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v) volatile
        {typedef unsigned char type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    char operator^=(char __v)
        {typedef unsigned char type; return type(fetch_xor(__v) ^ __v);}
} atomic_uchar;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_uchar*)
{
    typedef unsigned char type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_uchar* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_uchar*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_uchar* __obj, unsigned char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_uchar* __obj, unsigned char __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_uchar* __obj, unsigned char __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_uchar* __obj, unsigned char __desr)
{
    atomic_store(const_cast<volatile atomic_uchar*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_uchar* __obj, unsigned char __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_uchar* __obj, unsigned char __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_uchar*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_load(const volatile atomic_uchar* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_load(const atomic_uchar* __obj)
{
    return atomic_load(const_cast<const volatile atomic_uchar*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_load_explicit(const volatile atomic_uchar* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_load_explicit(const atomic_uchar* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_uchar*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_exchange(volatile atomic_uchar* __obj, unsigned char __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_exchange(atomic_uchar* __obj, unsigned char __desr)
{
    return atomic_exchange(const_cast<volatile atomic_uchar*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_exchange_explicit(volatile atomic_uchar* __obj, unsigned char __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_exchange_explicit(atomic_uchar* __obj, unsigned char __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_uchar*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_uchar* __obj, unsigned char* __exp,
                             unsigned char __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_uchar* __obj, unsigned char* __exp,
                             unsigned char __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_uchar*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_uchar* __obj,
                               unsigned char* __exp, unsigned char __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_uchar* __obj, unsigned char* __exp,
                               unsigned char __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_uchar*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_uchar* __obj,
                                      unsigned char* __exp,
                                      unsigned char __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_uchar* __obj, unsigned char* __exp,
                                      unsigned char __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_uchar*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_uchar* __obj,
                                        unsigned char* __exp,
                                        unsigned char __desr, memory_order __s,
                                        memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_uchar* __obj,
                                        unsigned char* __exp,
                                        unsigned char __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_uchar*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_add(volatile atomic_uchar* __obj, unsigned char __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_add(atomic_uchar* __obj, unsigned char __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_uchar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_add_explicit(volatile atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_add_explicit(atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_uchar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_sub(volatile atomic_uchar* __obj, unsigned char __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_sub(atomic_uchar* __obj, unsigned char __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_uchar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_sub_explicit(volatile atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_sub_explicit(atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_uchar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_and(volatile atomic_uchar* __obj, unsigned char __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_and(atomic_uchar* __obj, unsigned char __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_uchar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_and_explicit(volatile atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_and_explicit(atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_uchar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_or(volatile atomic_uchar* __obj, unsigned char __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_or(atomic_uchar* __obj, unsigned char __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_uchar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_or_explicit(volatile atomic_uchar* __obj, unsigned char __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_or_explicit(atomic_uchar* __obj, unsigned char __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_uchar*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_xor(volatile atomic_uchar* __obj, unsigned char __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_xor(atomic_uchar* __obj, unsigned char __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_uchar*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_xor_explicit(volatile atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned char
atomic_fetch_xor_explicit(atomic_uchar* __obj, unsigned char __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_uchar*>(__obj),
                                                                      __v, __o);
}

// atomic_short

struct atomic_short;

bool atomic_is_lock_free(const volatile atomic_short*);
bool atomic_is_lock_free(const atomic_short*);
void atomic_init(volatile atomic_short*, short);
void atomic_init(atomic_short*, short);
void atomic_store(volatile atomic_short*, short);
void atomic_store(atomic_short*, short);
void atomic_store_explicit(volatile atomic_short*, short, memory_order);
void atomic_store_explicit(atomic_short*, short, memory_order);
short atomic_load(const volatile atomic_short*);
short atomic_load(const atomic_short*);
short atomic_load_explicit(const volatile atomic_short*, memory_order);
short atomic_load_explicit(const atomic_short*, memory_order);
short atomic_exchange(volatile atomic_short*, short);
short atomic_exchange(atomic_short*, short);
short atomic_exchange_explicit(volatile atomic_short*, short, memory_order);
short atomic_exchange_explicit(atomic_short*, short, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_short*, short*, short);
bool atomic_compare_exchange_weak(atomic_short*, short*, short);
bool atomic_compare_exchange_strong(volatile atomic_short*, short*, short);
bool atomic_compare_exchange_strong(atomic_short*, short*, short);
bool atomic_compare_exchange_weak_explicit(volatile atomic_short*, short*,
                                           short, memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_short*, short*, short,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_short*, short*,
                                             short, memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_short*, short*, short,
                                             memory_order, memory_order);
short atomic_fetch_add(volatile atomic_short*, short);
short atomic_fetch_add(atomic_short*, short);
short atomic_fetch_add_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_add_explicit(atomic_short*, short, memory_order);
short atomic_fetch_sub(volatile atomic_short*, short);
short atomic_fetch_sub(atomic_short*, short);
short atomic_fetch_sub_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_sub_explicit(atomic_short*, short, memory_order);
short atomic_fetch_and(volatile atomic_short*, short);
short atomic_fetch_and(atomic_short*, short);
short atomic_fetch_and_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_and_explicit(atomic_short*, short, memory_order);
short atomic_fetch_or(volatile atomic_short*, short);
short atomic_fetch_or(atomic_short*, short);
short atomic_fetch_or_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_or_explicit(atomic_short*, short, memory_order);
short atomic_fetch_xor(volatile atomic_short*, short);
short atomic_fetch_xor(atomic_short*, short);
short atomic_fetch_xor_explicit(volatile atomic_short*, short, memory_order);
short atomic_fetch_xor_explicit(atomic_short*, short, memory_order);

typedef struct atomic_short
{
    short __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(short __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(short __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator short() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator short() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    short exchange(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short exchange(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(short& __v, short __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(short& __v, short __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(short& __v, short __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(short& __v, short __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(short& __v, short __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(short& __v, short __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(short& __v, short __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(short& __v, short __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_add(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_add(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_sub(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_sub(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_and(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_and(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_or(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_or(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_xor(short __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    short fetch_xor(short __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_short() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_short() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_short(short __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_short(const atomic_short&) = delete;
    atomic_short& operator=(const atomic_short&) = delete;
    atomic_short& operator=(const atomic_short&) volatile = delete;
#else
private:
    atomic_short(const atomic_short&);
    atomic_short& operator=(const atomic_short&);
    atomic_short& operator=(const atomic_short&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    short operator=(short __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    short operator=(short __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    short operator++(int) volatile
        {return fetch_add(short(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator++(int)
        {return fetch_add(short(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator--(int) volatile
        {return fetch_sub(short(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator--(int)
        {return fetch_sub(short(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator++() volatile
        {return short(fetch_add(short(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator++()
        {return short(fetch_add(short(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator--() volatile
        {return short(fetch_sub(short(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator--()
        {return short(fetch_sub(short(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator+=(short __v) volatile
        {return short(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator+=(short __v)
        {return short(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator-=(short __v) volatile
        {return short(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator-=(short __v)
        {return short(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator&=(short __v) volatile
        {return short(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator&=(short __v)
        {return short(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator|=(short __v) volatile
        {return short(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator|=(short __v)
        {return short(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator^=(short __v) volatile
        {return short(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator^=(short __v)
        {return short(fetch_xor(__v) ^ __v);}
} atomic_short;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_short*)
{
    typedef short type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_short* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_short*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_short* __obj, short __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_short* __obj, short __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_short* __obj, short __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_short* __obj, short __desr)
{
    atomic_store(const_cast<volatile atomic_short*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_short* __obj, short __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_short* __obj, short __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_short*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_load(const volatile atomic_short* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_load(const atomic_short* __obj)
{
    return atomic_load(const_cast<const volatile atomic_short*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_load_explicit(const volatile atomic_short* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_load_explicit(const atomic_short* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_short*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_exchange(volatile atomic_short* __obj, short __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_exchange(atomic_short* __obj, short __desr)
{
    return atomic_exchange(const_cast<volatile atomic_short*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_exchange_explicit(volatile atomic_short* __obj, short __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_exchange_explicit(atomic_short* __obj, short __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_short*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_short* __obj, short* __exp,
                             short __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_short* __obj, short* __exp, short __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_short*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_short* __obj, short* __exp,
                               short __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_short* __obj, short* __exp, short __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_short*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_short* __obj,
                                      short* __exp, short __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_short* __obj, short* __exp,
                                      short __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_short*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_short* __obj,
                                        short* __exp, short __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_short* __obj, short* __exp,
                                        short __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_short*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_add(volatile atomic_short* __obj, short __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_add(atomic_short* __obj, short __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_short*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_add_explicit(volatile atomic_short* __obj, short __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_add_explicit(atomic_short* __obj, short __v, memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_short*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_sub(volatile atomic_short* __obj, short __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_sub(atomic_short* __obj, short __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_short*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_sub_explicit(volatile atomic_short* __obj, short __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_sub_explicit(atomic_short* __obj, short __v, memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_short*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_and(volatile atomic_short* __obj, short __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_and(atomic_short* __obj, short __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_short*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_and_explicit(volatile atomic_short* __obj, short __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_and_explicit(atomic_short* __obj, short __v, memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_short*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_or(volatile atomic_short* __obj, short __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_or(atomic_short* __obj, short __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_short*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_or_explicit(volatile atomic_short* __obj, short __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_or_explicit(atomic_short* __obj, short __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_short*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_xor(volatile atomic_short* __obj, short __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_xor(atomic_short* __obj, short __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_short*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_xor_explicit(volatile atomic_short* __obj, short __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
short
atomic_fetch_xor_explicit(atomic_short* __obj, short __v, memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_short*>(__obj),
                                                                      __v, __o);
}

// atomic_ushort

struct atomic_ushort;

bool atomic_is_lock_free(const volatile atomic_ushort*);
bool atomic_is_lock_free(const atomic_ushort*);
void atomic_init(volatile atomic_ushort*, unsigned short);
void atomic_init(atomic_ushort*, unsigned short);
void atomic_store(volatile atomic_ushort*, unsigned short);
void atomic_store(atomic_ushort*, unsigned short);
void atomic_store_explicit(volatile atomic_ushort*, unsigned short,
                           memory_order);
void atomic_store_explicit(atomic_ushort*, unsigned short, memory_order);
unsigned short atomic_load(const volatile atomic_ushort*);
unsigned short atomic_load(const atomic_ushort*);
unsigned short atomic_load_explicit(const volatile atomic_ushort*,
                                    memory_order);
unsigned short atomic_load_explicit(const atomic_ushort*, memory_order);
unsigned short atomic_exchange(volatile atomic_ushort*, unsigned short);
unsigned short atomic_exchange(atomic_ushort*, unsigned short);
unsigned short atomic_exchange_explicit(volatile atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_exchange_explicit(atomic_ushort*, unsigned short,
                                        memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ushort*, unsigned short*,
                                  unsigned short);
bool atomic_compare_exchange_weak(atomic_ushort*, unsigned short*,
                                  unsigned short);
bool atomic_compare_exchange_strong(volatile atomic_ushort*, unsigned short*,
                                    unsigned short);
bool atomic_compare_exchange_strong(atomic_ushort*, unsigned short*,
                                    unsigned short);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ushort*,
                                           unsigned short*, unsigned short,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ushort*, unsigned short*,
                                           unsigned short, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ushort*,
                                             unsigned short*, unsigned short,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ushort*, unsigned short*,
                                             unsigned short, memory_order,
                                             memory_order);
unsigned short atomic_fetch_add(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_add(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_add_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_add_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_sub(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_sub(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_sub_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_sub_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_and(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_and(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_and_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_and_explicit(atomic_ushort*, unsigned short,
                                         memory_order);
unsigned short atomic_fetch_or(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_or(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_or_explicit(volatile atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_fetch_or_explicit(atomic_ushort*, unsigned short,
                                        memory_order);
unsigned short atomic_fetch_xor(volatile atomic_ushort*, unsigned short);
unsigned short atomic_fetch_xor(atomic_ushort*, unsigned short);
unsigned short atomic_fetch_xor_explicit(volatile atomic_ushort*,
                                         unsigned short, memory_order);
unsigned short atomic_fetch_xor_explicit(atomic_ushort*, unsigned short,
                                         memory_order);

typedef struct atomic_ushort
{
    unsigned short __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned short __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned short __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned short() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned short() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short exchange(unsigned short __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short exchange(unsigned short __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned short& __v, unsigned short __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned short& __v, unsigned short __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned short& __v, unsigned short __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned short& __v, unsigned short __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned short& __v, unsigned short __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned short& __v, unsigned short __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned short& __v, unsigned short __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned short& __v, unsigned short __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_add(unsigned short __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_add(unsigned short __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_sub(unsigned short __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_sub(unsigned short __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_and(unsigned short __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_and(unsigned short __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_or(unsigned short __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_or(unsigned short __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_xor(unsigned short __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short fetch_xor(unsigned short __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_ushort() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_ushort() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_ushort(unsigned short __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_ushort(const atomic_ushort&) = delete;
    atomic_ushort& operator=(const atomic_ushort&) = delete;
    atomic_ushort& operator=(const atomic_ushort&) volatile = delete;
#else
private:
    atomic_ushort(const atomic_ushort&);
    atomic_ushort& operator=(const atomic_ushort&);
    atomic_ushort& operator=(const atomic_ushort&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    unsigned short operator=(unsigned short __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short operator=(unsigned short __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned short operator++(int) volatile
        {typedef unsigned short type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator++(int)
        {typedef unsigned short type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator--(int) volatile
        {typedef unsigned short type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator--(int)
        {typedef unsigned short type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    short operator++() volatile
        {typedef unsigned short type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator++()
        {typedef unsigned short type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator--() volatile
        {typedef unsigned short type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator--()
        {typedef unsigned short type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    short operator+=(short __v) volatile
        {typedef unsigned short type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator+=(short __v)
        {typedef unsigned short type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator-=(short __v) volatile
        {typedef unsigned short type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator-=(short __v)
        {typedef unsigned short type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator&=(short __v) volatile
        {typedef unsigned short type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator&=(short __v)
        {typedef unsigned short type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator|=(short __v) volatile
        {typedef unsigned short type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator|=(short __v)
        {typedef unsigned short type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator^=(short __v) volatile
        {typedef unsigned short type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    short operator^=(short __v)
        {typedef unsigned short type; return type(fetch_xor(__v) ^ __v);}
} atomic_ushort;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_ushort*)
{
    typedef unsigned short type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_ushort* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_ushort*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_ushort* __obj, unsigned short __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_ushort* __obj, unsigned short __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_ushort* __obj, unsigned short __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_ushort* __obj, unsigned short __desr)
{
    atomic_store(const_cast<volatile atomic_ushort*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_ushort* __obj, unsigned short __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_ushort* __obj, unsigned short __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_ushort*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_load(const volatile atomic_ushort* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_load(const atomic_ushort* __obj)
{
    return atomic_load(const_cast<const volatile atomic_ushort*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_load_explicit(const volatile atomic_ushort* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_load_explicit(const atomic_ushort* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_ushort*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_exchange(volatile atomic_ushort* __obj, unsigned short __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_exchange(atomic_ushort* __obj, unsigned short __desr)
{
    return atomic_exchange(const_cast<volatile atomic_ushort*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_exchange_explicit(volatile atomic_ushort* __obj, unsigned short __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_exchange_explicit(atomic_ushort* __obj, unsigned short __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_ushort*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_ushort* __obj,
                             unsigned short* __exp, unsigned short __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_ushort* __obj, unsigned short* __exp,
                             unsigned short __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_ushort*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_ushort* __obj,
                               unsigned short* __exp, unsigned short __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_ushort* __obj, unsigned short* __exp,
                               unsigned short __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_ushort*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_ushort* __obj,
                                      unsigned short* __exp,
                                      unsigned short __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_ushort* __obj,
                                      unsigned short* __exp,
                                      unsigned short __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_ushort*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_ushort* __obj,
                                        unsigned short* __exp,
                                        unsigned short __desr, memory_order __s,
                                        memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_ushort* __obj,
                                        unsigned short* __exp,
                                        unsigned short __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_ushort*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_add(volatile atomic_ushort* __obj, unsigned short __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_add(atomic_ushort* __obj, unsigned short __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_ushort*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_add_explicit(volatile atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_add_explicit(atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_ushort*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_sub(volatile atomic_ushort* __obj, unsigned short __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_sub(atomic_ushort* __obj, unsigned short __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_ushort*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_sub_explicit(volatile atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_sub_explicit(atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_ushort*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_and(volatile atomic_ushort* __obj, unsigned short __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_and(atomic_ushort* __obj, unsigned short __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_ushort*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_and_explicit(volatile atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_and_explicit(atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_ushort*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_or(volatile atomic_ushort* __obj, unsigned short __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_or(atomic_ushort* __obj, unsigned short __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_ushort*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_or_explicit(volatile atomic_ushort* __obj, unsigned short __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_or_explicit(atomic_ushort* __obj, unsigned short __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_ushort*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_xor(volatile atomic_ushort* __obj, unsigned short __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_xor(atomic_ushort* __obj, unsigned short __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_ushort*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_xor_explicit(volatile atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned short
atomic_fetch_xor_explicit(atomic_ushort* __obj, unsigned short __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_ushort*>(__obj),
                                                                      __v, __o);
}

// atomic_int

struct atomic_int;

bool atomic_is_lock_free(const volatile atomic_int*);
bool atomic_is_lock_free(const atomic_int*);
void atomic_init(volatile atomic_int*, int);
void atomic_init(atomic_int*, int);
void atomic_store(volatile atomic_int*, int);
void atomic_store(atomic_int*, int);
void atomic_store_explicit(volatile atomic_int*, int, memory_order);
void atomic_store_explicit(atomic_int*, int, memory_order);
int atomic_load(const volatile atomic_int*);
int atomic_load(const atomic_int*);
int atomic_load_explicit(const volatile atomic_int*, memory_order);
int atomic_load_explicit(const atomic_int*, memory_order);
int atomic_exchange(volatile atomic_int*, int);
int atomic_exchange(atomic_int*, int);
int atomic_exchange_explicit(volatile atomic_int*, int, memory_order);
int atomic_exchange_explicit(atomic_int*, int, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_int*, int*, int);
bool atomic_compare_exchange_weak(atomic_int*, int*, int);
bool atomic_compare_exchange_strong(volatile atomic_int*, int*, int);
bool atomic_compare_exchange_strong(atomic_int*, int*, int);
bool atomic_compare_exchange_weak_explicit(volatile atomic_int*, int*, int,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_int*, int*, int,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_int*, int*, int,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_int*, int*, int,
                                             memory_order, memory_order);
int atomic_fetch_add(volatile atomic_int*, int);
int atomic_fetch_add(atomic_int*, int);
int atomic_fetch_add_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_add_explicit(atomic_int*, int, memory_order);
int atomic_fetch_sub(volatile atomic_int*, int);
int atomic_fetch_sub(atomic_int*, int);
int atomic_fetch_sub_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_sub_explicit(atomic_int*, int, memory_order);
int atomic_fetch_and(volatile atomic_int*, int);
int atomic_fetch_and(atomic_int*, int);
int atomic_fetch_and_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_and_explicit(atomic_int*, int, memory_order);
int atomic_fetch_or(volatile atomic_int*, int);
int atomic_fetch_or(atomic_int*, int);
int atomic_fetch_or_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_or_explicit(atomic_int*, int, memory_order);
int atomic_fetch_xor(volatile atomic_int*, int);
int atomic_fetch_xor(atomic_int*, int);
int atomic_fetch_xor_explicit(volatile atomic_int*, int, memory_order);
int atomic_fetch_xor_explicit(atomic_int*, int, memory_order);

typedef struct atomic_int
{
    int __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(int __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(int __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator int() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator int() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    int exchange(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int exchange(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(int& __v, int __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(int& __v, int __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(int& __v, int __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(int& __v, int __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(int& __v, int __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(int& __v, int __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(int& __v, int __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(int& __v, int __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_add(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_add(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_sub(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_sub(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_and(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_and(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_or(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_or(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_xor(int __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    int fetch_xor(int __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_int() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_int() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_int(int __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_int(const atomic_int&) = delete;
    atomic_int& operator=(const atomic_int&) = delete;
    atomic_int& operator=(const atomic_int&) volatile = delete;
#else
private:
    atomic_int(const atomic_int&);
    atomic_int& operator=(const atomic_int&);
    atomic_int& operator=(const atomic_int&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    int operator=(int __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    int operator=(int __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    int operator++(int) volatile
        {return fetch_add(int(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator++(int)
        {return fetch_add(int(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator--(int) volatile
        {return fetch_sub(int(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator--(int)
        {return fetch_sub(int(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator++() volatile
        {return int(fetch_add(int(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator++()
        {return int(fetch_add(int(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator--() volatile
        {return int(fetch_sub(int(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator--()
        {return int(fetch_sub(int(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator+=(int __v) volatile
        {return int(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator+=(int __v)
        {return int(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator-=(int __v) volatile
        {return int(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator-=(int __v)
        {return int(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator&=(int __v) volatile
        {return int(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator&=(int __v)
        {return int(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator|=(int __v) volatile
        {return int(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator|=(int __v)
        {return int(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator^=(int __v) volatile
        {return int(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator^=(int __v)
        {return int(fetch_xor(__v) ^ __v);}
} atomic_int;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_int*)
{
    typedef int type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_int* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_int*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_int* __obj, int __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_int* __obj, int __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_int* __obj, int __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_int* __obj, int __desr)
{
    atomic_store(const_cast<volatile atomic_int*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_int* __obj, int __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_int* __obj, int __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_int*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_load(const volatile atomic_int* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_load(const atomic_int* __obj)
{
    return atomic_load(const_cast<const volatile atomic_int*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_load_explicit(const volatile atomic_int* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_load_explicit(const atomic_int* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_int*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_exchange(volatile atomic_int* __obj, int __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_exchange(atomic_int* __obj, int __desr)
{
    return atomic_exchange(const_cast<volatile atomic_int*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_exchange_explicit(volatile atomic_int* __obj, int __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_exchange_explicit(atomic_int* __obj, int __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_int*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_int* __obj, int* __exp,
                             int __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_int* __obj, int* __exp, int __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_int*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_int* __obj, int* __exp,
                               int __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_int* __obj, int* __exp, int __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_int*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_int* __obj, int* __exp,
                                      int __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_int* __obj, int* __exp,
                                      int __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_int*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_int* __obj,
                                        int* __exp, int __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_int* __obj, int* __exp,
                                        int __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_int*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_add(volatile atomic_int* __obj, int __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_add(atomic_int* __obj, int __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_int*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_add_explicit(volatile atomic_int* __obj, int __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_add_explicit(atomic_int* __obj, int __v, memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_int*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_sub(volatile atomic_int* __obj, int __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_sub(atomic_int* __obj, int __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_int*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_sub_explicit(volatile atomic_int* __obj, int __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_sub_explicit(atomic_int* __obj, int __v, memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_int*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_and(volatile atomic_int* __obj, int __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_and(atomic_int* __obj, int __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_int*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_and_explicit(volatile atomic_int* __obj, int __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_and_explicit(atomic_int* __obj, int __v, memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_int*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_or(volatile atomic_int* __obj, int __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_or(atomic_int* __obj, int __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_int*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_or_explicit(volatile atomic_int* __obj, int __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_or_explicit(atomic_int* __obj, int __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_int*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_xor(volatile atomic_int* __obj, int __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_xor(atomic_int* __obj, int __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_int*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_xor_explicit(volatile atomic_int* __obj, int __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
int
atomic_fetch_xor_explicit(atomic_int* __obj, int __v, memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_int*>(__obj),
                                                                      __v, __o);
}

// atomic_uint

struct atomic_uint;

bool atomic_is_lock_free(const volatile atomic_uint*);
bool atomic_is_lock_free(const atomic_uint*);
void atomic_init(volatile atomic_uint*, unsigned int);
void atomic_init(atomic_uint*, unsigned int);
void atomic_store(volatile atomic_uint*, unsigned int);
void atomic_store(atomic_uint*, unsigned int);
void atomic_store_explicit(volatile atomic_uint*, unsigned int, memory_order);
void atomic_store_explicit(atomic_uint*, unsigned int, memory_order);
unsigned int atomic_load(const volatile atomic_uint*);
unsigned int atomic_load(const atomic_uint*);
unsigned int atomic_load_explicit(const volatile atomic_uint*, memory_order);
unsigned int atomic_load_explicit(const atomic_uint*, memory_order);
unsigned int atomic_exchange(volatile atomic_uint*, unsigned int);
unsigned int atomic_exchange(atomic_uint*, unsigned int);
unsigned int atomic_exchange_explicit(volatile atomic_uint*, unsigned int,
                                     memory_order);
unsigned int atomic_exchange_explicit(atomic_uint*, unsigned int,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_uint*, unsigned int*,
                                  unsigned int);
bool atomic_compare_exchange_weak(atomic_uint*, unsigned int*, unsigned int);
bool atomic_compare_exchange_strong(volatile atomic_uint*, unsigned int*,
                                    unsigned int);
bool atomic_compare_exchange_strong(atomic_uint*, unsigned int*,
                                    unsigned int);
bool atomic_compare_exchange_weak_explicit(volatile atomic_uint*,
                                           unsigned int*, unsigned int,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_uint*, unsigned int*,
                                           unsigned int, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_uint*,
                                             unsigned int*, unsigned int,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_uint*, unsigned int*,
                                             unsigned int, memory_order,
                                             memory_order);
unsigned int atomic_fetch_add(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_add(atomic_uint*, unsigned int);
unsigned int atomic_fetch_add_explicit(volatile atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_add_explicit(atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_sub(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_sub(atomic_uint*, unsigned int);
unsigned int atomic_fetch_sub_explicit(volatile atomic_uint*, unsigned int,
                                      memory_order);
unsigned int atomic_fetch_sub_explicit(atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_and(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_and(atomic_uint*, unsigned int);
unsigned int atomic_fetch_and_explicit(volatile atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_and_explicit(atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_or(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_or(atomic_uint*, unsigned int);
unsigned int atomic_fetch_or_explicit(volatile atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_or_explicit(atomic_uint*, unsigned int,
                                       memory_order);
unsigned int atomic_fetch_xor(volatile atomic_uint*, unsigned int);
unsigned int atomic_fetch_xor(atomic_uint*, unsigned int);
unsigned int atomic_fetch_xor_explicit(volatile atomic_uint*, unsigned int,
                                        memory_order);
unsigned int atomic_fetch_xor_explicit(atomic_uint*, unsigned int,
                                        memory_order);

typedef struct atomic_uint
{
    unsigned int __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned int __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned int __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned int() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned int() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int exchange(unsigned int __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int exchange(unsigned int __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned int& __v, unsigned int __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned int& __v, unsigned int __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned int& __v, unsigned int __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned int& __v, unsigned int __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned int& __v, unsigned int __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned int& __v, unsigned int __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned int& __v, unsigned int __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned int& __v, unsigned int __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_add(unsigned int __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_add(unsigned int __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_sub(unsigned int __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_sub(unsigned int __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_and(unsigned int __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_and(unsigned int __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_or(unsigned int __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_or(unsigned int __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_xor(unsigned int __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int fetch_xor(unsigned int __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_uint() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_uint() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_uint(unsigned int __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_uint(const atomic_uint&) = delete;
    atomic_uint& operator=(const atomic_uint&) = delete;
    atomic_uint& operator=(const atomic_uint&) volatile = delete;
#else
private:
    atomic_uint(const atomic_uint&);
    atomic_uint& operator=(const atomic_uint&);
    atomic_uint& operator=(const atomic_uint&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    unsigned int operator=(unsigned int __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int operator=(unsigned int __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned int operator++(int) volatile
        {typedef unsigned int type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator++(int)
        {typedef unsigned int type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator--(int) volatile
        {typedef unsigned int type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator--(int)
        {typedef unsigned int type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    int operator++() volatile
        {typedef unsigned int type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator++()
        {typedef unsigned int type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator--() volatile
        {typedef unsigned int type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator--()
        {typedef unsigned int type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    int operator+=(int __v) volatile
        {typedef unsigned int type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator+=(int __v)
        {typedef unsigned int type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator-=(int __v) volatile
        {typedef unsigned int type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator-=(int __v)
        {typedef unsigned int type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator&=(int __v) volatile
        {typedef unsigned int type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator&=(int __v)
        {typedef unsigned int type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator|=(int __v) volatile
        {typedef unsigned int type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator|=(int __v)
        {typedef unsigned int type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator^=(int __v) volatile
        {typedef unsigned int type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    int operator^=(int __v)
        {typedef unsigned int type; return type(fetch_xor(__v) ^ __v);}
} atomic_uint;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_uint*)
{
    typedef unsigned int type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_uint* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_uint*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_uint* __obj, unsigned int __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_uint* __obj, unsigned int __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_uint* __obj, unsigned int __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_uint* __obj, unsigned int __desr)
{
    atomic_store(const_cast<volatile atomic_uint*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_uint* __obj, unsigned int __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_uint* __obj, unsigned int __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_uint*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_load(const volatile atomic_uint* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_load(const atomic_uint* __obj)
{
    return atomic_load(const_cast<const volatile atomic_uint*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_load_explicit(const volatile atomic_uint* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_load_explicit(const atomic_uint* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_uint*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_exchange(volatile atomic_uint* __obj, unsigned int __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_exchange(atomic_uint* __obj, unsigned int __desr)
{
    return atomic_exchange(const_cast<volatile atomic_uint*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_exchange_explicit(volatile atomic_uint* __obj, unsigned int __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_exchange_explicit(atomic_uint* __obj, unsigned int __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_uint*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_uint* __obj, unsigned int* __exp,
                             unsigned int __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_uint* __obj, unsigned int* __exp,
                             unsigned int __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_uint*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_uint* __obj,
                               unsigned int* __exp, unsigned int __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_uint* __obj, unsigned int* __exp,
                               unsigned int __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_uint*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_uint* __obj,
                                      unsigned int* __exp,
                                      unsigned int __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_uint* __obj, unsigned int* __exp,
                                      unsigned int __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_uint*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_uint* __obj,
                                        unsigned int* __exp,
                                        unsigned int __desr, memory_order __s,
                                        memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_uint* __obj,
                                        unsigned int* __exp,
                                        unsigned int __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_uint*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_add(volatile atomic_uint* __obj, unsigned int __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_add(atomic_uint* __obj, unsigned int __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_uint*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_add_explicit(volatile atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_add_explicit(atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_uint*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_sub(volatile atomic_uint* __obj, unsigned int __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_sub(atomic_uint* __obj, unsigned int __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_uint*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_sub_explicit(volatile atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_sub_explicit(atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_uint*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_and(volatile atomic_uint* __obj, unsigned int __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_and(atomic_uint* __obj, unsigned int __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_uint*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_and_explicit(volatile atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_and_explicit(atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_uint*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_or(volatile atomic_uint* __obj, unsigned int __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_or(atomic_uint* __obj, unsigned int __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_uint*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_or_explicit(volatile atomic_uint* __obj, unsigned int __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_or_explicit(atomic_uint* __obj, unsigned int __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_uint*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_xor(volatile atomic_uint* __obj, unsigned int __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_xor(atomic_uint* __obj, unsigned int __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_uint*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_xor_explicit(volatile atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned int
atomic_fetch_xor_explicit(atomic_uint* __obj, unsigned int __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_uint*>(__obj),
                                                                      __v, __o);
}

// atomic_long

struct atomic_long;

bool atomic_is_lock_free(const volatile atomic_long*);
bool atomic_is_lock_free(const atomic_long*);
void atomic_init(volatile atomic_long*, long);
void atomic_init(atomic_long*, long);
void atomic_store(volatile atomic_long*, long);
void atomic_store(atomic_long*, long);
void atomic_store_explicit(volatile atomic_long*, long, memory_order);
void atomic_store_explicit(atomic_long*, long, memory_order);
long atomic_load(const volatile atomic_long*);
long atomic_load(const atomic_long*);
long atomic_load_explicit(const volatile atomic_long*, memory_order);
long atomic_load_explicit(const atomic_long*, memory_order);
long atomic_exchange(volatile atomic_long*, long);
long atomic_exchange(atomic_long*, long);
long atomic_exchange_explicit(volatile atomic_long*, long, memory_order);
long atomic_exchange_explicit(atomic_long*, long, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_long*, long*, long);
bool atomic_compare_exchange_weak(atomic_long*, long*, long);
bool atomic_compare_exchange_strong(volatile atomic_long*, long*, long);
bool atomic_compare_exchange_strong(atomic_long*, long*, long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_long*, long*, long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_long*, long*, long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_long*, long*, long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_long*, long*, long,
                                             memory_order, memory_order);
long atomic_fetch_add(volatile atomic_long*, long);
long atomic_fetch_add(atomic_long*, long);
long atomic_fetch_add_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_add_explicit(atomic_long*, long, memory_order);
long atomic_fetch_sub(volatile atomic_long*, long);
long atomic_fetch_sub(atomic_long*, long);
long atomic_fetch_sub_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_sub_explicit(atomic_long*, long, memory_order);
long atomic_fetch_and(volatile atomic_long*, long);
long atomic_fetch_and(atomic_long*, long);
long atomic_fetch_and_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_and_explicit(atomic_long*, long, memory_order);
long atomic_fetch_or(volatile atomic_long*, long);
long atomic_fetch_or(atomic_long*, long);
long atomic_fetch_or_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_or_explicit(atomic_long*, long, memory_order);
long atomic_fetch_xor(volatile atomic_long*, long);
long atomic_fetch_xor(atomic_long*, long);
long atomic_fetch_xor_explicit(volatile atomic_long*, long, memory_order);
long atomic_fetch_xor_explicit(atomic_long*, long, memory_order);

typedef struct atomic_long
{
    long __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(long __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(long __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator long() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator long() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    long exchange(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long exchange(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long& __v, long __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long& __v, long __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long& __v, long __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long& __v, long __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long& __v, long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long& __v, long __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long& __v, long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long& __v, long __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_add(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_add(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_sub(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_sub(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_and(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_and(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_or(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_or(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_xor(long __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long fetch_xor(long __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_long() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_long() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_long(long __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_long(const atomic_long&) = delete;
    atomic_long& operator=(const atomic_long&) = delete;
    atomic_long& operator=(const atomic_long&) volatile = delete;
#else
private:
    atomic_long(const atomic_long&);
    atomic_long& operator=(const atomic_long&);
    atomic_long& operator=(const atomic_long&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    long operator=(long __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    long operator=(long __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    long operator++(int) volatile
        {return fetch_add(long(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++(int)
        {return fetch_add(long(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int) volatile
        {return fetch_sub(long(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int)
        {return fetch_sub(long(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++() volatile
        {return long(fetch_add(long(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator++()
        {return long(fetch_add(long(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--() volatile
        {return long(fetch_sub(long(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--()
        {return long(fetch_sub(long(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v) volatile
        {return long(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v)
        {return long(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v) volatile
        {return long(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v)
        {return long(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v) volatile
        {return long(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v)
        {return long(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v) volatile
        {return long(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v)
        {return long(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v) volatile
        {return long(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v)
        {return long(fetch_xor(__v) ^ __v);}
} atomic_long;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_long*)
{
    typedef long type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_long* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_long*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_long* __obj, long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_long* __obj, long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_long* __obj, long __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_long* __obj, long __desr)
{
    atomic_store(const_cast<volatile atomic_long*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_long* __obj, long __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_long* __obj, long __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_long*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_load(const volatile atomic_long* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_load(const atomic_long* __obj)
{
    return atomic_load(const_cast<const volatile atomic_long*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_load_explicit(const volatile atomic_long* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_load_explicit(const atomic_long* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_long*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_exchange(volatile atomic_long* __obj, long __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_exchange(atomic_long* __obj, long __desr)
{
    return atomic_exchange(const_cast<volatile atomic_long*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_exchange_explicit(volatile atomic_long* __obj, long __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_exchange_explicit(atomic_long* __obj, long __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_long*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_long* __obj, long* __exp,
                             long __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_long* __obj, long* __exp, long __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_long*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_long* __obj, long* __exp,
                               long __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_long* __obj, long* __exp, long __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_long*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_long* __obj, long* __exp,
                                      long __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_long* __obj, long* __exp,
                                      long __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_long*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_long* __obj,
                                        long* __exp, long __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_long* __obj, long* __exp,
                                        long __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_long*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_add(volatile atomic_long* __obj, long __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_add(atomic_long* __obj, long __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_long*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_add_explicit(volatile atomic_long* __obj, long __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_add_explicit(atomic_long* __obj, long __v, memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_long*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_sub(volatile atomic_long* __obj, long __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_sub(atomic_long* __obj, long __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_long*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_sub_explicit(volatile atomic_long* __obj, long __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_sub_explicit(atomic_long* __obj, long __v, memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_long*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_and(volatile atomic_long* __obj, long __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_and(atomic_long* __obj, long __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_long*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_and_explicit(volatile atomic_long* __obj, long __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_and_explicit(atomic_long* __obj, long __v, memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_long*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_or(volatile atomic_long* __obj, long __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_or(atomic_long* __obj, long __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_long*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_or_explicit(volatile atomic_long* __obj, long __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_or_explicit(atomic_long* __obj, long __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_long*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_xor(volatile atomic_long* __obj, long __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_xor(atomic_long* __obj, long __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_long*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_xor_explicit(volatile atomic_long* __obj, long __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long
atomic_fetch_xor_explicit(atomic_long* __obj, long __v, memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_long*>(__obj),
                                                                      __v, __o);
}

// atomic_ulong

struct atomic_ulong;

bool atomic_is_lock_free(const volatile atomic_ulong*);
bool atomic_is_lock_free(const atomic_ulong*);
void atomic_init(volatile atomic_ulong*, unsigned long);
void atomic_init(atomic_ulong*, unsigned long);
void atomic_store(volatile atomic_ulong*, unsigned long);
void atomic_store(atomic_ulong*, unsigned long);
void atomic_store_explicit(volatile atomic_ulong*, unsigned long, memory_order);
void atomic_store_explicit(atomic_ulong*, unsigned long, memory_order);
unsigned long atomic_load(const volatile atomic_ulong*);
unsigned long atomic_load(const atomic_ulong*);
unsigned long atomic_load_explicit(const volatile atomic_ulong*, memory_order);
unsigned long atomic_load_explicit(const atomic_ulong*, memory_order);
unsigned long atomic_exchange(volatile atomic_ulong*, unsigned long);
unsigned long atomic_exchange(atomic_ulong*, unsigned long);
unsigned long atomic_exchange_explicit(volatile atomic_ulong*, unsigned long,
                                     memory_order);
unsigned long atomic_exchange_explicit(atomic_ulong*, unsigned long,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ulong*, unsigned long*,
                                  unsigned long);
bool atomic_compare_exchange_weak(atomic_ulong*, unsigned long*, unsigned long);
bool atomic_compare_exchange_strong(volatile atomic_ulong*, unsigned long*,
                                    unsigned long);
bool atomic_compare_exchange_strong(atomic_ulong*, unsigned long*,
                                    unsigned long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ulong*,
                                           unsigned long*, unsigned long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ulong*, unsigned long*,
                                           unsigned long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ulong*,
                                             unsigned long*, unsigned long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ulong*, unsigned long*,
                                             unsigned long, memory_order,
                                             memory_order);
unsigned long atomic_fetch_add(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_add(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_add_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_add_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_sub(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_sub(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_sub_explicit(volatile atomic_ulong*, unsigned long,
                                      memory_order);
unsigned long atomic_fetch_sub_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_and(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_and(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_and_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_and_explicit(atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_or(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_or(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_or_explicit(volatile atomic_ulong*, unsigned long,
                                       memory_order);
unsigned long atomic_fetch_or_explicit(atomic_ulong*, unsigned long,
                                       memory_order);
unsigned long atomic_fetch_xor(volatile atomic_ulong*, unsigned long);
unsigned long atomic_fetch_xor(atomic_ulong*, unsigned long);
unsigned long atomic_fetch_xor_explicit(volatile atomic_ulong*, unsigned long,
                                        memory_order);
unsigned long atomic_fetch_xor_explicit(atomic_ulong*, unsigned long,
                                        memory_order);

typedef struct atomic_ulong
{
    unsigned long __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned long __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned long __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned long() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned long() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long exchange(unsigned long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long exchange(unsigned long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long& __v, unsigned long __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long& __v, unsigned long __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long& __v, unsigned long __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long& __v, unsigned long __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long& __v, unsigned long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long& __v, unsigned long __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long& __v, unsigned long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long& __v, unsigned long __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_add(unsigned long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_add(unsigned long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_sub(unsigned long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_sub(unsigned long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_and(unsigned long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_and(unsigned long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_or(unsigned long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_or(unsigned long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_xor(unsigned long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long fetch_xor(unsigned long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_ulong() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_ulong() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_ulong(unsigned long __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_ulong(const atomic_ulong&) = delete;
    atomic_ulong& operator=(const atomic_ulong&) = delete;
    atomic_ulong& operator=(const atomic_ulong&) volatile = delete;
#else
private:
    atomic_ulong(const atomic_ulong&);
    atomic_ulong& operator=(const atomic_ulong&);
    atomic_ulong& operator=(const atomic_ulong&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    unsigned long operator=(unsigned long __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long operator=(unsigned long __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long operator++(int) volatile
        {typedef unsigned long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++(int)
        {typedef unsigned long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int) volatile
        {typedef unsigned long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int)
        {typedef unsigned long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++() volatile
        {typedef unsigned long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator++()
        {typedef unsigned long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--() volatile
        {typedef unsigned long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--()
        {typedef unsigned long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v) volatile
        {typedef unsigned long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v)
        {typedef unsigned long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v) volatile
        {typedef unsigned long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v)
        {typedef unsigned long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v) volatile
        {typedef unsigned long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v)
        {typedef unsigned long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v) volatile
        {typedef unsigned long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v)
        {typedef unsigned long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v) volatile
        {typedef unsigned long type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v)
        {typedef unsigned long type; return type(fetch_xor(__v) ^ __v);}
} atomic_ulong;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_ulong*)
{
    typedef unsigned long type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_ulong* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_ulong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_ulong* __obj, unsigned long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_ulong* __obj, unsigned long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_ulong* __obj, unsigned long __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_ulong* __obj, unsigned long __desr)
{
    atomic_store(const_cast<volatile atomic_ulong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_ulong* __obj, unsigned long __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_ulong* __obj, unsigned long __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_ulong*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_load(const volatile atomic_ulong* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_load(const atomic_ulong* __obj)
{
    return atomic_load(const_cast<const volatile atomic_ulong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_load_explicit(const volatile atomic_ulong* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_load_explicit(const atomic_ulong* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_ulong*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_exchange(volatile atomic_ulong* __obj, unsigned long __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_exchange(atomic_ulong* __obj, unsigned long __desr)
{
    return atomic_exchange(const_cast<volatile atomic_ulong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_exchange_explicit(volatile atomic_ulong* __obj, unsigned long __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_exchange_explicit(atomic_ulong* __obj, unsigned long __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_ulong*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_ulong* __obj, unsigned long* __exp,
                             unsigned long __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_ulong* __obj, unsigned long* __exp,
                             unsigned long __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_ulong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_ulong* __obj,
                               unsigned long* __exp, unsigned long __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_ulong* __obj, unsigned long* __exp,
                               unsigned long __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_ulong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_ulong* __obj,
                                      unsigned long* __exp,
                                      unsigned long __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_ulong* __obj, unsigned long* __exp,
                                      unsigned long __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_ulong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_ulong* __obj,
                                        unsigned long* __exp,
                                        unsigned long __desr, memory_order __s,
                                        memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_ulong* __obj,
                                        unsigned long* __exp,
                                        unsigned long __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_ulong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_add(volatile atomic_ulong* __obj, unsigned long __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_add(atomic_ulong* __obj, unsigned long __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_ulong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_add_explicit(volatile atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_add_explicit(atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_ulong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_sub(volatile atomic_ulong* __obj, unsigned long __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_sub(atomic_ulong* __obj, unsigned long __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_ulong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_sub_explicit(volatile atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_sub_explicit(atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_ulong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_and(volatile atomic_ulong* __obj, unsigned long __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_and(atomic_ulong* __obj, unsigned long __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_ulong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_and_explicit(volatile atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_and_explicit(atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_ulong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_or(volatile atomic_ulong* __obj, unsigned long __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_or(atomic_ulong* __obj, unsigned long __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_ulong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_or_explicit(volatile atomic_ulong* __obj, unsigned long __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_or_explicit(atomic_ulong* __obj, unsigned long __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_ulong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_xor(volatile atomic_ulong* __obj, unsigned long __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_xor(atomic_ulong* __obj, unsigned long __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_ulong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_xor_explicit(volatile atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long
atomic_fetch_xor_explicit(atomic_ulong* __obj, unsigned long __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_ulong*>(__obj),
                                                                      __v, __o);
}

// atomic_llong

struct atomic_llong;

bool atomic_is_lock_free(const volatile atomic_llong*);
bool atomic_is_lock_free(const atomic_llong*);
void atomic_init(volatile atomic_llong*, long long);
void atomic_init(atomic_llong*, long long);
void atomic_store(volatile atomic_llong*, long long);
void atomic_store(atomic_llong*, long long);
void atomic_store_explicit(volatile atomic_llong*, long long, memory_order);
void atomic_store_explicit(atomic_llong*, long long, memory_order);
long long atomic_load(const volatile atomic_llong*);
long long atomic_load(const atomic_llong*);
long long atomic_load_explicit(const volatile atomic_llong*, memory_order);
long long atomic_load_explicit(const atomic_llong*, memory_order);
long long atomic_exchange(volatile atomic_llong*, long long);
long long atomic_exchange(atomic_llong*, long long);
long long atomic_exchange_explicit(volatile atomic_llong*, long long,
                                     memory_order);
long long atomic_exchange_explicit(atomic_llong*, long long,
                                       memory_order);
bool atomic_compare_exchange_weak(volatile atomic_llong*, long long*,
                                  long long);
bool atomic_compare_exchange_weak(atomic_llong*, long long*, long long);
bool atomic_compare_exchange_strong(volatile atomic_llong*, long long*,
                                    long long);
bool atomic_compare_exchange_strong(atomic_llong*, long long*,
                                    long long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_llong*,
                                           long long*, long long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_llong*, long long*,
                                           long long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_llong*,
                                             long long*, long long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_llong*, long long*,
                                             long long, memory_order,
                                             memory_order);
long long atomic_fetch_add(volatile atomic_llong*, long long);
long long atomic_fetch_add(atomic_llong*, long long);
long long atomic_fetch_add_explicit(volatile atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_add_explicit(atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_sub(volatile atomic_llong*, long long);
long long atomic_fetch_sub(atomic_llong*, long long);
long long atomic_fetch_sub_explicit(volatile atomic_llong*, long long,
                                      memory_order);
long long atomic_fetch_sub_explicit(atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_and(volatile atomic_llong*, long long);
long long atomic_fetch_and(atomic_llong*, long long);
long long atomic_fetch_and_explicit(volatile atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_and_explicit(atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_or(volatile atomic_llong*, long long);
long long atomic_fetch_or(atomic_llong*, long long);
long long atomic_fetch_or_explicit(volatile atomic_llong*, long long,
                                       memory_order);
long long atomic_fetch_or_explicit(atomic_llong*, long long,
                                       memory_order);
long long atomic_fetch_xor(volatile atomic_llong*, long long);
long long atomic_fetch_xor(atomic_llong*, long long);
long long atomic_fetch_xor_explicit(volatile atomic_llong*, long long,
                                        memory_order);
long long atomic_fetch_xor_explicit(atomic_llong*, long long,
                                        memory_order);

typedef struct atomic_llong
{
    long long __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(long long __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(long long __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator long long() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator long long() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    long long exchange(long long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long exchange(long long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long long& __v, long long __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long long& __v, long long __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long long& __v, long long __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long long& __v, long long __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long long& __v, long long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(long long& __v, long long __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long long& __v, long long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(long long& __v, long long __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_add(long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_add(long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_sub(long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_sub(long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_and(long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_and(long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_or(long long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_or(long long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_xor(long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    long long fetch_xor(long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_llong() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_llong() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_llong(long long __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_llong(const atomic_llong&) = delete;
    atomic_llong& operator=(const atomic_llong&) = delete;
    atomic_llong& operator=(const atomic_llong&) volatile = delete;
#else
private:
    atomic_llong(const atomic_llong&);
    atomic_llong& operator=(const atomic_llong&);
    atomic_llong& operator=(const atomic_llong&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    long long operator=(long long __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    long long operator=(long long __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    long long operator++(int) volatile
        {typedef long long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++(int)
        {typedef long long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int) volatile
        {typedef long long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int)
        {typedef long long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++() volatile
        {typedef long long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator++()
        {typedef long long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--() volatile
        {typedef long long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--()
        {typedef long long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v) volatile
        {typedef long long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v)
        {typedef long long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v) volatile
        {typedef long long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v)
        {typedef long long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v) volatile
        {typedef long long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v)
        {typedef long long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v) volatile
        {typedef long long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v)
        {typedef long long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v) volatile
        {typedef long long type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v)
        {typedef long long type; return type(fetch_xor(__v) ^ __v);}
} atomic_llong;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_llong*)
{
    typedef long long type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_llong* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_llong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_llong* __obj, long long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_llong* __obj, long long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_llong* __obj, long long __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_llong* __obj, long long __desr)
{
    atomic_store(const_cast<volatile atomic_llong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_llong* __obj, long long __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_llong* __obj, long long __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_llong*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_load(const volatile atomic_llong* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_load(const atomic_llong* __obj)
{
    return atomic_load(const_cast<const volatile atomic_llong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_load_explicit(const volatile atomic_llong* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_load_explicit(const atomic_llong* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_llong*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_exchange(volatile atomic_llong* __obj, long long __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_exchange(atomic_llong* __obj, long long __desr)
{
    return atomic_exchange(const_cast<volatile atomic_llong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_exchange_explicit(volatile atomic_llong* __obj, long long __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_exchange_explicit(atomic_llong* __obj, long long __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_llong*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_llong* __obj, long long* __exp,
                             long long __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_llong* __obj, long long* __exp,
                             long long __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_llong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_llong* __obj,
                               long long* __exp, long long __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_llong* __obj, long long* __exp,
                               long long __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_llong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_llong* __obj,
                                      long long* __exp,
                                      long long __desr, memory_order __s,
                                      memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_llong* __obj, long long* __exp,
                                      long long __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_llong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_llong* __obj,
                                        long long* __exp,
                                        long long __desr, memory_order __s,
                                        memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_llong* __obj,
                                        long long* __exp,
                                        long long __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_llong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_add(volatile atomic_llong* __obj, long long __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_add(atomic_llong* __obj, long long __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_llong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_add_explicit(volatile atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_add_explicit(atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_llong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_sub(volatile atomic_llong* __obj, long long __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_sub(atomic_llong* __obj, long long __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_llong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_sub_explicit(volatile atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_sub_explicit(atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_llong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_and(volatile atomic_llong* __obj, long long __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_and(atomic_llong* __obj, long long __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_llong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_and_explicit(volatile atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_and_explicit(atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_llong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_or(volatile atomic_llong* __obj, long long __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_or(atomic_llong* __obj, long long __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_llong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_or_explicit(volatile atomic_llong* __obj, long long __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_or_explicit(atomic_llong* __obj, long long __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_llong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_xor(volatile atomic_llong* __obj, long long __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_xor(atomic_llong* __obj, long long __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_llong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_xor_explicit(volatile atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
long long
atomic_fetch_xor_explicit(atomic_llong* __obj, long long __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_llong*>(__obj),
                                                                      __v, __o);
}

// atomic_ullong

struct atomic_ullong;

bool atomic_is_lock_free(const volatile atomic_ullong*);
bool atomic_is_lock_free(const atomic_ullong*);
void atomic_init(volatile atomic_ullong*, unsigned long long);
void atomic_init(atomic_ullong*, unsigned long long);
void atomic_store(volatile atomic_ullong*, unsigned long long);
void atomic_store(atomic_ullong*, unsigned long long);
void atomic_store_explicit(volatile atomic_ullong*, unsigned long long,
                           memory_order);
void atomic_store_explicit(atomic_ullong*, unsigned long long, memory_order);
unsigned long long atomic_load(const volatile atomic_ullong*);
unsigned long long atomic_load(const atomic_ullong*);
unsigned long long atomic_load_explicit(const volatile atomic_ullong*,
                                        memory_order);
unsigned long long atomic_load_explicit(const atomic_ullong*, memory_order);
unsigned long long atomic_exchange(volatile atomic_ullong*, unsigned long long);
unsigned long long atomic_exchange(atomic_ullong*, unsigned long long);
unsigned long long atomic_exchange_explicit(volatile atomic_ullong*,
                                            unsigned long long, memory_order);
unsigned long long atomic_exchange_explicit(atomic_ullong*, unsigned long long,
                                            memory_order);
bool atomic_compare_exchange_weak(volatile atomic_ullong*, unsigned long long*,
                                  unsigned long long);
bool atomic_compare_exchange_weak(atomic_ullong*, unsigned long long*,
                                  unsigned long long);
bool atomic_compare_exchange_strong(volatile atomic_ullong*,
                                    unsigned long long*, unsigned long long);
bool atomic_compare_exchange_strong(atomic_ullong*, unsigned long long*,
                                    unsigned long long);
bool atomic_compare_exchange_weak_explicit(volatile atomic_ullong*,
                                           unsigned long long*,
                                           unsigned long long,
                                           memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_ullong*, unsigned long long*,
                                           unsigned long long, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_ullong*,
                                             unsigned long long*,
                                             unsigned long long,
                                             memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_ullong*,
                                             unsigned long long*,
                                             unsigned long long, memory_order,
                                             memory_order);
unsigned long long atomic_fetch_add(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_add(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_add_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_add_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_sub(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_sub(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_sub_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_sub_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_and(volatile atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_and(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_and_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_and_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);
unsigned long long atomic_fetch_or(volatile atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_or(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_or_explicit(volatile atomic_ullong*,
                                            unsigned long long, memory_order);
unsigned long long atomic_fetch_or_explicit(atomic_ullong*, unsigned long long,
                                            memory_order);
unsigned long long atomic_fetch_xor(volatile atomic_ullong*,
                                    unsigned long long);
unsigned long long atomic_fetch_xor(atomic_ullong*, unsigned long long);
unsigned long long atomic_fetch_xor_explicit(volatile atomic_ullong*,
                                             unsigned long long, memory_order);
unsigned long long atomic_fetch_xor_explicit(atomic_ullong*, unsigned long long,
                                             memory_order);

typedef struct atomic_ullong
{
    unsigned long long __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned long long __v,
               memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(unsigned long long __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long load(memory_order __o = memory_order_seq_cst) const
                                                                        volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned long long() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator unsigned long long() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long exchange(unsigned long long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long exchange(unsigned long long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long long& __v, unsigned long long __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long long& __v, unsigned long long __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long long& __v, unsigned long long __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long long& __v, unsigned long long __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long long& __v, unsigned long long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(unsigned long long& __v, unsigned long long __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long long& __v, unsigned long long __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(unsigned long long& __v, unsigned long long __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_add(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_add(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_sub(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_sub(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_and(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_and(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_or(unsigned long long __v,
                           memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_or(unsigned long long __v,
                           memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_xor(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long fetch_xor(unsigned long long __v,
                            memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_ullong() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_ullong() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_ullong(unsigned long long __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_ullong(const atomic_ullong&) = delete;
    atomic_ullong& operator=(const atomic_ullong&) = delete;
    atomic_ullong& operator=(const atomic_ullong&) volatile = delete;
#else
private:
    atomic_ullong(const atomic_ullong&);
    atomic_ullong& operator=(const atomic_ullong&);
    atomic_ullong& operator=(const atomic_ullong&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long operator=(unsigned long long __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long operator=(unsigned long long __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    unsigned long long operator++(int) volatile
        {typedef unsigned long long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++(int)
        {typedef unsigned long long type; return fetch_add(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int) volatile
        {typedef unsigned long long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator--(int)
        {typedef unsigned long long type; return fetch_sub(type(1));}
    _LIBCPP_INLINE_VISIBILITY
    long operator++() volatile
        {typedef unsigned long long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator++()
        {typedef unsigned long long type; return type(fetch_add(type(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--() volatile
        {typedef unsigned long long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator--()
        {typedef unsigned long long type; return type(fetch_sub(type(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v) volatile
        {typedef unsigned long long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator+=(long __v)
        {typedef unsigned long long type; return type(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v) volatile
        {typedef unsigned long long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator-=(long __v)
        {typedef unsigned long long type; return type(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v) volatile
        {typedef unsigned long long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator&=(long __v)
        {typedef unsigned long long type; return type(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v) volatile
        {typedef unsigned long long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator|=(long __v)
        {typedef unsigned long long type; return type(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v) volatile
        {typedef unsigned long long type; return type(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    long operator^=(long __v)
        {typedef unsigned long long type; return type(fetch_xor(__v) ^ __v);}
} atomic_ullong;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_ullong*)
{
    typedef unsigned long long type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_ullong* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_ullong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_ullong* __obj, unsigned long long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_ullong* __obj, unsigned long long __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_ullong* __obj, unsigned long long __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_ullong* __obj, unsigned long long __desr)
{
    atomic_store(const_cast<volatile atomic_ullong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_ullong* __obj, unsigned long long __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_ullong* __obj, unsigned long long __desr,
                      memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_ullong*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_load(const volatile atomic_ullong* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_load(const atomic_ullong* __obj)
{
    return atomic_load(const_cast<const volatile atomic_ullong*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_load_explicit(const volatile atomic_ullong* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_load_explicit(const atomic_ullong* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_ullong*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_exchange(volatile atomic_ullong* __obj, unsigned long long __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_exchange(atomic_ullong* __obj, unsigned long long __desr)
{
    return atomic_exchange(const_cast<volatile atomic_ullong*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_exchange_explicit(volatile atomic_ullong* __obj,
                         unsigned long long __desr, memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_exchange_explicit(atomic_ullong* __obj, unsigned long long __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_ullong*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_ullong* __obj,
                             unsigned long long* __exp,
                             unsigned long long __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_ullong* __obj, unsigned long long* __exp,
                             unsigned long long __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_ullong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_ullong* __obj,
                               unsigned long long* __exp,
                               unsigned long long __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_ullong* __obj, unsigned long long* __exp,
                               unsigned long long __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_ullong*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_ullong* __obj,
                                      unsigned long long* __exp,
                                      unsigned long long __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_ullong* __obj,
                                      unsigned long long* __exp,
                                      unsigned long long __desr,
                                      memory_order __s, memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_ullong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_ullong* __obj,
                                        unsigned long long* __exp,
                                        unsigned long long __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_ullong* __obj,
                                        unsigned long long* __exp,
                                        unsigned long long __desr,
                                        memory_order __s, memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_ullong*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_add(volatile atomic_ullong* __obj, unsigned long long __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_add(atomic_ullong* __obj, unsigned long long __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_ullong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_add_explicit(volatile atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_add_explicit(atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_ullong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_sub(volatile atomic_ullong* __obj, unsigned long long __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_sub(atomic_ullong* __obj, unsigned long long __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_ullong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_sub_explicit(volatile atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_sub_explicit(atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_ullong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_and(volatile atomic_ullong* __obj, unsigned long long __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_and(atomic_ullong* __obj, unsigned long long __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_ullong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_and_explicit(volatile atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_and_explicit(atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_ullong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_or(volatile atomic_ullong* __obj, unsigned long long __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_or(atomic_ullong* __obj, unsigned long long __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_ullong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_or_explicit(volatile atomic_ullong* __obj, unsigned long long __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_or_explicit(atomic_ullong* __obj, unsigned long long __v,
                         memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_ullong*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_xor(volatile atomic_ullong* __obj, unsigned long long __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_xor(atomic_ullong* __obj, unsigned long long __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_ullong*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_xor_explicit(volatile atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
unsigned long long
atomic_fetch_xor_explicit(atomic_ullong* __obj, unsigned long long __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_ullong*>(__obj),
                                                                      __v, __o);
}

#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS

// atomic_char16_t

struct atomic_char16_t;

bool atomic_is_lock_free(const volatile atomic_char16_t*);
bool atomic_is_lock_free(const atomic_char16_t*);
void atomic_init(volatile atomic_char16_t*, char16_t);
void atomic_init(atomic_char16_t*, char16_t);
void atomic_store(volatile atomic_char16_t*, char16_t);
void atomic_store(atomic_char16_t*, char16_t);
void atomic_store_explicit(volatile atomic_char16_t*, char16_t, memory_order);
void atomic_store_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_load(const volatile atomic_char16_t*);
char16_t atomic_load(const atomic_char16_t*);
char16_t atomic_load_explicit(const volatile atomic_char16_t*, memory_order);
char16_t atomic_load_explicit(const atomic_char16_t*, memory_order);
char16_t atomic_exchange(volatile atomic_char16_t*, char16_t);
char16_t atomic_exchange(atomic_char16_t*, char16_t);
char16_t atomic_exchange_explicit(volatile atomic_char16_t*, char16_t,
                                  memory_order);
char16_t atomic_exchange_explicit(atomic_char16_t*, char16_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char16_t*, char16_t*,
                                  char16_t);
bool atomic_compare_exchange_weak(atomic_char16_t*, char16_t*, char16_t);
bool atomic_compare_exchange_strong(volatile atomic_char16_t*, char16_t*,
                                    char16_t);
bool atomic_compare_exchange_strong(atomic_char16_t*, char16_t*, char16_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char16_t*, char16_t*,
                                           char16_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char16_t*, char16_t*,
                                           char16_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char16_t*,
                                             char16_t*, char16_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char16_t*, char16_t*,
                                             char16_t, memory_order,
                                             memory_order);
char16_t atomic_fetch_add(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_add(atomic_char16_t*, char16_t);
char16_t atomic_fetch_add_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_add_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_sub(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_sub(atomic_char16_t*, char16_t);
char16_t atomic_fetch_sub_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_sub_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_and(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_and(atomic_char16_t*, char16_t);
char16_t atomic_fetch_and_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_and_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_or(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_or(atomic_char16_t*, char16_t);
char16_t atomic_fetch_or_explicit(volatile atomic_char16_t*, char16_t,
                                  memory_order);
char16_t atomic_fetch_or_explicit(atomic_char16_t*, char16_t, memory_order);
char16_t atomic_fetch_xor(volatile atomic_char16_t*, char16_t);
char16_t atomic_fetch_xor(atomic_char16_t*, char16_t);
char16_t atomic_fetch_xor_explicit(volatile atomic_char16_t*, char16_t,
                                   memory_order);
char16_t atomic_fetch_xor_explicit(atomic_char16_t*, char16_t, memory_order);

typedef struct atomic_char16_t
{
    char16_t __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char16_t __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char16_t __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator char16_t() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator char16_t() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    char16_t exchange(char16_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t exchange(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char16_t& __v, char16_t __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char16_t& __v, char16_t __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char16_t& __v, char16_t __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char16_t& __v, char16_t __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char16_t& __v, char16_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char16_t& __v, char16_t __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char16_t& __v, char16_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char16_t& __v, char16_t __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_add(char16_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_add(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_sub(char16_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_sub(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_and(char16_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_and(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_or(char16_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_or(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_xor(char16_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t fetch_xor(char16_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_char16_t() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_char16_t() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_char16_t(char16_t __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_char16_t(const atomic_char16_t&) = delete;
    atomic_char16_t& operator=(const atomic_char16_t&) = delete;
    atomic_char16_t& operator=(const atomic_char16_t&) volatile = delete;
#else
private:
    atomic_char16_t(const atomic_char16_t&);
    atomic_char16_t& operator=(const atomic_char16_t&);
    atomic_char16_t& operator=(const atomic_char16_t&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator=(char16_t __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator=(char16_t __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator++(int) volatile
        {return fetch_add(char16_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator++(int)
        {return fetch_add(char16_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator--(int) volatile
        {return fetch_sub(char16_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator--(int)
        {return fetch_sub(char16_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator++() volatile
        {return char16_t(fetch_add(char16_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator++()
        {return char16_t(fetch_add(char16_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator--() volatile
        {return char16_t(fetch_sub(char16_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator--()
        {return char16_t(fetch_sub(char16_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator+=(char16_t __v) volatile
        {return char16_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator+=(char16_t __v)
        {return char16_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator-=(char16_t __v) volatile
        {return char16_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator-=(char16_t __v)
        {return char16_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator&=(char16_t __v) volatile
        {return char16_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator&=(char16_t __v)
        {return char16_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator|=(char16_t __v) volatile
        {return char16_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator|=(char16_t __v)
        {return char16_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator^=(char16_t __v) volatile
        {return char16_t(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    char16_t operator^=(char16_t __v)
        {return char16_t(fetch_xor(__v) ^ __v);}
} atomic_char16_t;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_char16_t*)
{
    typedef char16_t type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_char16_t* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_char16_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_char16_t* __obj, char16_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_char16_t* __obj, char16_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_char16_t* __obj, char16_t __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_char16_t* __obj, char16_t __desr)
{
    atomic_store(const_cast<volatile atomic_char16_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_char16_t* __obj, char16_t __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_char16_t* __obj, char16_t __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_char16_t*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_load(const volatile atomic_char16_t* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_load(const atomic_char16_t* __obj)
{
    return atomic_load(const_cast<const volatile atomic_char16_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_load_explicit(const volatile atomic_char16_t* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_load_explicit(const atomic_char16_t* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_char16_t*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_exchange(volatile atomic_char16_t* __obj, char16_t __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_exchange(atomic_char16_t* __obj, char16_t __desr)
{
    return atomic_exchange(const_cast<volatile atomic_char16_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_exchange_explicit(volatile atomic_char16_t* __obj, char16_t __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_exchange_explicit(atomic_char16_t* __obj, char16_t __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_char16_t*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_char16_t* __obj, char16_t* __exp,
                             char16_t __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_char16_t* __obj, char16_t* __exp,
                             char16_t __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_char16_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_char16_t* __obj, char16_t* __exp,
                               char16_t __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_char16_t* __obj, char16_t* __exp,
                               char16_t __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_char16_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_char16_t* __obj,
                                      char16_t* __exp, char16_t __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_char16_t* __obj, char16_t* __exp,
                                      char16_t __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_char16_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_char16_t* __obj,
                                        char16_t* __exp, char16_t __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_char16_t* __obj, char16_t* __exp,
                                        char16_t __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_char16_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_add(volatile atomic_char16_t* __obj, char16_t __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_add(atomic_char16_t* __obj, char16_t __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_char16_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_add_explicit(volatile atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_add_explicit(atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_char16_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_sub(volatile atomic_char16_t* __obj, char16_t __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_sub(atomic_char16_t* __obj, char16_t __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_char16_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_sub_explicit(volatile atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_sub_explicit(atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_char16_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_and(volatile atomic_char16_t* __obj, char16_t __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_and(atomic_char16_t* __obj, char16_t __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_char16_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_and_explicit(volatile atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_and_explicit(atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_char16_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_or(volatile atomic_char16_t* __obj, char16_t __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_or(atomic_char16_t* __obj, char16_t __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_char16_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_or_explicit(volatile atomic_char16_t* __obj, char16_t __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_or_explicit(atomic_char16_t* __obj, char16_t __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_char16_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_xor(volatile atomic_char16_t* __obj, char16_t __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_xor(atomic_char16_t* __obj, char16_t __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_char16_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_xor_explicit(volatile atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char16_t
atomic_fetch_xor_explicit(atomic_char16_t* __obj, char16_t __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_char16_t*>(__obj),
                                                                      __v, __o);
}

// atomic_char32_t

struct atomic_char32_t;

bool atomic_is_lock_free(const volatile atomic_char32_t*);
bool atomic_is_lock_free(const atomic_char32_t*);
void atomic_init(volatile atomic_char32_t*, char32_t);
void atomic_init(atomic_char32_t*, char32_t);
void atomic_store(volatile atomic_char32_t*, char32_t);
void atomic_store(atomic_char32_t*, char32_t);
void atomic_store_explicit(volatile atomic_char32_t*, char32_t, memory_order);
void atomic_store_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_load(const volatile atomic_char32_t*);
char32_t atomic_load(const atomic_char32_t*);
char32_t atomic_load_explicit(const volatile atomic_char32_t*, memory_order);
char32_t atomic_load_explicit(const atomic_char32_t*, memory_order);
char32_t atomic_exchange(volatile atomic_char32_t*, char32_t);
char32_t atomic_exchange(atomic_char32_t*, char32_t);
char32_t atomic_exchange_explicit(volatile atomic_char32_t*, char32_t,
                                  memory_order);
char32_t atomic_exchange_explicit(atomic_char32_t*, char32_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_char32_t*, char32_t*,
                                  char32_t);
bool atomic_compare_exchange_weak(atomic_char32_t*, char32_t*, char32_t);
bool atomic_compare_exchange_strong(volatile atomic_char32_t*, char32_t*,
                                    char32_t);
bool atomic_compare_exchange_strong(atomic_char32_t*, char32_t*, char32_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_char32_t*, char32_t*,
                                           char32_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_char32_t*, char32_t*,
                                           char32_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_char32_t*,
                                             char32_t*, char32_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_char32_t*, char32_t*,
                                             char32_t, memory_order,
                                             memory_order);
char32_t atomic_fetch_add(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_add(atomic_char32_t*, char32_t);
char32_t atomic_fetch_add_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_add_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_sub(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_sub(atomic_char32_t*, char32_t);
char32_t atomic_fetch_sub_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_sub_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_and(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_and(atomic_char32_t*, char32_t);
char32_t atomic_fetch_and_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_and_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_or(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_or(atomic_char32_t*, char32_t);
char32_t atomic_fetch_or_explicit(volatile atomic_char32_t*, char32_t,
                                  memory_order);
char32_t atomic_fetch_or_explicit(atomic_char32_t*, char32_t, memory_order);
char32_t atomic_fetch_xor(volatile atomic_char32_t*, char32_t);
char32_t atomic_fetch_xor(atomic_char32_t*, char32_t);
char32_t atomic_fetch_xor_explicit(volatile atomic_char32_t*, char32_t,
                                   memory_order);
char32_t atomic_fetch_xor_explicit(atomic_char32_t*, char32_t, memory_order);

typedef struct atomic_char32_t
{
    char32_t __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char32_t __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(char32_t __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator char32_t() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator char32_t() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    char32_t exchange(char32_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t exchange(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char32_t& __v, char32_t __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char32_t& __v, char32_t __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char32_t& __v, char32_t __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char32_t& __v, char32_t __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char32_t& __v, char32_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(char32_t& __v, char32_t __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char32_t& __v, char32_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(char32_t& __v, char32_t __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_add(char32_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_add(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_sub(char32_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_sub(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_and(char32_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_and(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_or(char32_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_or(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_xor(char32_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t fetch_xor(char32_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_char32_t() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_char32_t() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_char32_t(char32_t __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_char32_t(const atomic_char32_t&) = delete;
    atomic_char32_t& operator=(const atomic_char32_t&) = delete;
    atomic_char32_t& operator=(const atomic_char32_t&) volatile = delete;
#else
private:
    atomic_char32_t(const atomic_char32_t&);
    atomic_char32_t& operator=(const atomic_char32_t&);
    atomic_char32_t& operator=(const atomic_char32_t&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator=(char32_t __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator=(char32_t __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator++(int) volatile
        {return fetch_add(char32_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator++(int)
        {return fetch_add(char32_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator--(int) volatile
        {return fetch_sub(char32_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator--(int)
        {return fetch_sub(char32_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator++() volatile
        {return char32_t(fetch_add(char32_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator++()
        {return char32_t(fetch_add(char32_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator--() volatile
        {return char32_t(fetch_sub(char32_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator--()
        {return char32_t(fetch_sub(char32_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator+=(char32_t __v) volatile
        {return char32_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator+=(char32_t __v)
        {return char32_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator-=(char32_t __v) volatile
        {return char32_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator-=(char32_t __v)
        {return char32_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator&=(char32_t __v) volatile
        {return char32_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator&=(char32_t __v)
        {return char32_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator|=(char32_t __v) volatile
        {return char32_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator|=(char32_t __v)
        {return char32_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator^=(char32_t __v) volatile
        {return char32_t(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    char32_t operator^=(char32_t __v)
        {return char32_t(fetch_xor(__v) ^ __v);}
} atomic_char32_t;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_char32_t*)
{
    typedef char32_t type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_char32_t* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_char32_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_char32_t* __obj, char32_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_char32_t* __obj, char32_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_char32_t* __obj, char32_t __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_char32_t* __obj, char32_t __desr)
{
    atomic_store(const_cast<volatile atomic_char32_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_char32_t* __obj, char32_t __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_char32_t* __obj, char32_t __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_char32_t*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_load(const volatile atomic_char32_t* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_load(const atomic_char32_t* __obj)
{
    return atomic_load(const_cast<const volatile atomic_char32_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_load_explicit(const volatile atomic_char32_t* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_load_explicit(const atomic_char32_t* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_char32_t*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_exchange(volatile atomic_char32_t* __obj, char32_t __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_exchange(atomic_char32_t* __obj, char32_t __desr)
{
    return atomic_exchange(const_cast<volatile atomic_char32_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_exchange_explicit(volatile atomic_char32_t* __obj, char32_t __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_exchange_explicit(atomic_char32_t* __obj, char32_t __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_char32_t*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_char32_t* __obj, char32_t* __exp,
                             char32_t __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_char32_t* __obj, char32_t* __exp,
                             char32_t __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_char32_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_char32_t* __obj, char32_t* __exp,
                               char32_t __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_char32_t* __obj, char32_t* __exp,
                               char32_t __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_char32_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_char32_t* __obj,
                                      char32_t* __exp, char32_t __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_char32_t* __obj, char32_t* __exp,
                                      char32_t __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_char32_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_char32_t* __obj,
                                        char32_t* __exp, char32_t __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_char32_t* __obj, char32_t* __exp,
                                        char32_t __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_char32_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_add(volatile atomic_char32_t* __obj, char32_t __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_add(atomic_char32_t* __obj, char32_t __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_char32_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_add_explicit(volatile atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_add_explicit(atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_char32_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_sub(volatile atomic_char32_t* __obj, char32_t __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_sub(atomic_char32_t* __obj, char32_t __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_char32_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_sub_explicit(volatile atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_sub_explicit(atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_char32_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_and(volatile atomic_char32_t* __obj, char32_t __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_and(atomic_char32_t* __obj, char32_t __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_char32_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_and_explicit(volatile atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_and_explicit(atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_char32_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_or(volatile atomic_char32_t* __obj, char32_t __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_or(atomic_char32_t* __obj, char32_t __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_char32_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_or_explicit(volatile atomic_char32_t* __obj, char32_t __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_or_explicit(atomic_char32_t* __obj, char32_t __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_char32_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_xor(volatile atomic_char32_t* __obj, char32_t __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_xor(atomic_char32_t* __obj, char32_t __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_char32_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_xor_explicit(volatile atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
char32_t
atomic_fetch_xor_explicit(atomic_char32_t* __obj, char32_t __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_char32_t*>(__obj),
                                                                      __v, __o);
}

#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS

// atomic_wchar_t

struct atomic_wchar_t;

bool atomic_is_lock_free(const volatile atomic_wchar_t*);
bool atomic_is_lock_free(const atomic_wchar_t*);
void atomic_init(volatile atomic_wchar_t*, wchar_t);
void atomic_init(atomic_wchar_t*, wchar_t);
void atomic_store(volatile atomic_wchar_t*, wchar_t);
void atomic_store(atomic_wchar_t*, wchar_t);
void atomic_store_explicit(volatile atomic_wchar_t*, wchar_t, memory_order);
void atomic_store_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_load(const volatile atomic_wchar_t*);
wchar_t atomic_load(const atomic_wchar_t*);
wchar_t atomic_load_explicit(const volatile atomic_wchar_t*, memory_order);
wchar_t atomic_load_explicit(const atomic_wchar_t*, memory_order);
wchar_t atomic_exchange(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_exchange(atomic_wchar_t*, wchar_t);
wchar_t atomic_exchange_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_exchange_explicit(atomic_wchar_t*, wchar_t, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_wchar_t*, wchar_t*,
                                  wchar_t);
bool atomic_compare_exchange_weak(atomic_wchar_t*, wchar_t*, wchar_t);
bool atomic_compare_exchange_strong(volatile atomic_wchar_t*, wchar_t*,
                                    wchar_t);
bool atomic_compare_exchange_strong(atomic_wchar_t*, wchar_t*, wchar_t);
bool atomic_compare_exchange_weak_explicit(volatile atomic_wchar_t*, wchar_t*,
                                           wchar_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_wchar_t*, wchar_t*,
                                           wchar_t, memory_order,
                                           memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_wchar_t*,
                                             wchar_t*, wchar_t, memory_order,
                                             memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_wchar_t*, wchar_t*,
                                             wchar_t, memory_order,
                                             memory_order);
wchar_t atomic_fetch_add(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_add(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_add_explicit(volatile atomic_wchar_t*, wchar_t,
                                   memory_order);
wchar_t atomic_fetch_add_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_sub(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_sub(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_sub_explicit(volatile atomic_wchar_t*, wchar_t,
                                   memory_order);
wchar_t atomic_fetch_sub_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_and(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_and(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_and_explicit(volatile atomic_wchar_t*, wchar_t,
                                   memory_order);
wchar_t atomic_fetch_and_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_or(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_or(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_or_explicit(volatile atomic_wchar_t*, wchar_t,
                                  memory_order);
wchar_t atomic_fetch_or_explicit(atomic_wchar_t*, wchar_t, memory_order);
wchar_t atomic_fetch_xor(volatile atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_xor(atomic_wchar_t*, wchar_t);
wchar_t atomic_fetch_xor_explicit(volatile atomic_wchar_t*, wchar_t,
                                   memory_order);
wchar_t atomic_fetch_xor_explicit(atomic_wchar_t*, wchar_t, memory_order);

typedef struct atomic_wchar_t
{
    wchar_t __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(wchar_t __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator wchar_t() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator wchar_t() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t exchange(wchar_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t exchange(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(wchar_t& __v, wchar_t __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(wchar_t& __v, wchar_t __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(wchar_t& __v, wchar_t __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(wchar_t& __v, wchar_t __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(wchar_t& __v, wchar_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(wchar_t& __v, wchar_t __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(wchar_t& __v, wchar_t __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(wchar_t& __v, wchar_t __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_add(wchar_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_add(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_sub(wchar_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_sub(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_and(wchar_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_and(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_and_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_or(wchar_t __v,
                      memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_or(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_or_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_xor(wchar_t __v,
                       memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_xor_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t fetch_xor(wchar_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_xor_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_wchar_t() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_wchar_t() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_wchar_t(wchar_t __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_wchar_t(const atomic_wchar_t&) = delete;
    atomic_wchar_t& operator=(const atomic_wchar_t&) = delete;
    atomic_wchar_t& operator=(const atomic_wchar_t&) volatile = delete;
#else
private:
    atomic_wchar_t(const atomic_wchar_t&);
    atomic_wchar_t& operator=(const atomic_wchar_t&);
    atomic_wchar_t& operator=(const atomic_wchar_t&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator=(wchar_t __v) volatile
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator=(wchar_t __v)
        {store(__v); return __v;}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator++(int) volatile
        {return fetch_add(wchar_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator++(int)
        {return fetch_add(wchar_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator--(int) volatile
        {return fetch_sub(wchar_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator--(int)
        {return fetch_sub(wchar_t(1));}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator++() volatile
        {return wchar_t(fetch_add(wchar_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator++()
        {return wchar_t(fetch_add(wchar_t(1)) + 1);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator--() volatile
        {return wchar_t(fetch_sub(wchar_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator--()
        {return wchar_t(fetch_sub(wchar_t(1)) - 1);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator+=(wchar_t __v) volatile
        {return wchar_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator+=(wchar_t __v)
        {return wchar_t(fetch_add(__v) + __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator-=(wchar_t __v) volatile
        {return wchar_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator-=(wchar_t __v)
        {return wchar_t(fetch_sub(__v) - __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator&=(wchar_t __v) volatile
        {return wchar_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator&=(wchar_t __v)
        {return wchar_t(fetch_and(__v) & __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator|=(wchar_t __v) volatile
        {return wchar_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator|=(wchar_t __v)
        {return wchar_t(fetch_or(__v) | __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator^=(wchar_t __v) volatile
        {return wchar_t(fetch_xor(__v) ^ __v);}
    _LIBCPP_INLINE_VISIBILITY
    wchar_t operator^=(wchar_t __v)
        {return wchar_t(fetch_xor(__v) ^ __v);}
} atomic_wchar_t;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_wchar_t*)
{
    typedef wchar_t type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_wchar_t* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_wchar_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_wchar_t* __obj, wchar_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_wchar_t* __obj, wchar_t __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_wchar_t* __obj, wchar_t __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_wchar_t* __obj, wchar_t __desr)
{
    atomic_store(const_cast<volatile atomic_wchar_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_wchar_t* __obj, wchar_t __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_wchar_t* __obj, wchar_t __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_wchar_t*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_load(const volatile atomic_wchar_t* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_load(const atomic_wchar_t* __obj)
{
    return atomic_load(const_cast<const volatile atomic_wchar_t*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_load_explicit(const volatile atomic_wchar_t* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_load_explicit(const atomic_wchar_t* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_wchar_t*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_exchange(volatile atomic_wchar_t* __obj, wchar_t __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_exchange(atomic_wchar_t* __obj, wchar_t __desr)
{
    return atomic_exchange(const_cast<volatile atomic_wchar_t*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_exchange_explicit(volatile atomic_wchar_t* __obj, wchar_t __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_exchange_explicit(atomic_wchar_t* __obj, wchar_t __desr,
                         memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_wchar_t*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_wchar_t* __obj, wchar_t* __exp,
                             wchar_t __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_wchar_t* __obj, wchar_t* __exp,
                             wchar_t __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_wchar_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_wchar_t* __obj, wchar_t* __exp,
                               wchar_t __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_wchar_t* __obj, wchar_t* __exp,
                               wchar_t __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_wchar_t*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_wchar_t* __obj,
                                      wchar_t* __exp, wchar_t __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_wchar_t* __obj, wchar_t* __exp,
                                      wchar_t __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_wchar_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_wchar_t* __obj,
                                        wchar_t* __exp, wchar_t __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_wchar_t* __obj, wchar_t* __exp,
                                        wchar_t __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_wchar_t*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_add(volatile atomic_wchar_t* __obj, wchar_t __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_add(atomic_wchar_t* __obj, wchar_t __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_wchar_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_add_explicit(volatile atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_add_explicit(atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_wchar_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_sub(volatile atomic_wchar_t* __obj, wchar_t __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_sub(atomic_wchar_t* __obj, wchar_t __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_wchar_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_sub_explicit(volatile atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_sub_explicit(atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_wchar_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_and(volatile atomic_wchar_t* __obj, wchar_t __v)
{
    return __atomic_fetch_and(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_and(atomic_wchar_t* __obj, wchar_t __v)
{
    return atomic_fetch_and(const_cast<volatile atomic_wchar_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_and_explicit(volatile atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return __atomic_fetch_and(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_and_explicit(atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return atomic_fetch_and_explicit(const_cast<volatile atomic_wchar_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_or(volatile atomic_wchar_t* __obj, wchar_t __v)
{
    return __atomic_fetch_or(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_or(atomic_wchar_t* __obj, wchar_t __v)
{
    return atomic_fetch_or(const_cast<volatile atomic_wchar_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_or_explicit(volatile atomic_wchar_t* __obj, wchar_t __v,
                         memory_order __o)
{
    return __atomic_fetch_or(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_or_explicit(atomic_wchar_t* __obj, wchar_t __v, memory_order __o)
{
    return atomic_fetch_or_explicit(const_cast<volatile atomic_wchar_t*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_xor(volatile atomic_wchar_t* __obj, wchar_t __v)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_xor(atomic_wchar_t* __obj, wchar_t __v)
{
    return atomic_fetch_xor(const_cast<volatile atomic_wchar_t*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_xor_explicit(volatile atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return __atomic_fetch_xor(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
wchar_t
atomic_fetch_xor_explicit(atomic_wchar_t* __obj, wchar_t __v,
                          memory_order __o)
{
    return atomic_fetch_xor_explicit(const_cast<volatile atomic_wchar_t*>(__obj),
                                                                      __v, __o);
}

// atomic_address

struct atomic_address;

bool atomic_is_lock_free(const volatile atomic_address*);
bool atomic_is_lock_free(const atomic_address*);
void atomic_init(volatile atomic_address*, void*);
void atomic_init(atomic_address*, void*);
void atomic_store(volatile atomic_address*, void*);
void atomic_store(atomic_address*, void*);
void atomic_store_explicit(volatile atomic_address*, void*, memory_order);
void atomic_store_explicit(atomic_address*, void*, memory_order);
void* atomic_load(const volatile atomic_address*);
void* atomic_load(const atomic_address*);
void* atomic_load_explicit(const volatile atomic_address*, memory_order);
void* atomic_load_explicit(const atomic_address*, memory_order);
void* atomic_exchange(volatile atomic_address*, void*);
void* atomic_exchange(atomic_address*, void*);
void* atomic_exchange_explicit(volatile atomic_address*, void*, memory_order);
void* atomic_exchange_explicit(atomic_address*, void*, memory_order);
bool atomic_compare_exchange_weak(volatile atomic_address*, void**, void*);
bool atomic_compare_exchange_weak(atomic_address*, void**, void*);
bool atomic_compare_exchange_strong(volatile atomic_address*, void**, void*);
bool atomic_compare_exchange_strong(atomic_address*, void**, void*);
bool atomic_compare_exchange_weak_explicit(volatile atomic_address*, void**,
                                           void*, memory_order, memory_order);
bool atomic_compare_exchange_weak_explicit(atomic_address*, void**,
                                           void*, memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(volatile atomic_address*, void**, 
                                             void*, memory_order, memory_order);
bool atomic_compare_exchange_strong_explicit(atomic_address*, void**,
                                             void*, memory_order, memory_order);
void* atomic_fetch_add(volatile atomic_address*, ptrdiff_t);
void* atomic_fetch_add(atomic_address*, ptrdiff_t);
void* atomic_fetch_add_explicit(volatile atomic_address*, ptrdiff_t,
                                memory_order);
void* atomic_fetch_add_explicit(atomic_address*, ptrdiff_t, memory_order);
void* atomic_fetch_sub(volatile atomic_address*, ptrdiff_t);
void* atomic_fetch_sub(atomic_address*, ptrdiff_t);
void* atomic_fetch_sub_explicit(volatile atomic_address*, ptrdiff_t,
                                memory_order);
void* atomic_fetch_sub_explicit(atomic_address*, ptrdiff_t, memory_order);

typedef struct atomic_address
{
    void* __v_;

    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const volatile
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    bool is_lock_free() const
        {return atomic_is_lock_free(this);}
    _LIBCPP_INLINE_VISIBILITY
    void store(void* __v, memory_order __o = memory_order_seq_cst) volatile
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void store(void* __v, memory_order __o = memory_order_seq_cst)
        {atomic_store_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* load(memory_order __o = memory_order_seq_cst) const volatile
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* load(memory_order __o = memory_order_seq_cst) const
        {return atomic_load_explicit(this, __o);}
    _LIBCPP_INLINE_VISIBILITY
    operator void*() const volatile
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    operator void*() const
        {return load();}
    _LIBCPP_INLINE_VISIBILITY
    void* exchange(void* __v, memory_order __o = memory_order_seq_cst) volatile
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* exchange(void* __v, memory_order __o = memory_order_seq_cst)
        {return atomic_exchange_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(void*& __v, void* __e, memory_order __s,
                               memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(void*& __v, void* __e, memory_order __s,
                               memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(void*& __v, void* __e, memory_order __s,
                                 memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(void*& __v, void* __e, memory_order __s,
                                 memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                                          __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(void*& __v, void* __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(void*& __v, void* __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(void*& __v, void* __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(void*& __v, void* __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this, &__v, __e, __s,
                                                __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(const void*& __v, const void* __e,
                               memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_weak_explicit(this,
                   &const_cast<void*&>(__v), const_cast<void*>(__e), __s, __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(const void*& __v, const void* __e,
                               memory_order __s, memory_order __f)
        {return atomic_compare_exchange_weak_explicit(this,
                   &const_cast<void*&>(__v), const_cast<void*>(__e), __s, __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(const void*& __v, const void* __e,
                                 memory_order __s, memory_order __f) volatile
        {return atomic_compare_exchange_strong_explicit(this,
                   &const_cast<void*&>(__v), const_cast<void*>(__e), __s, __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(const void*& __v, const void* __e,
                                 memory_order __s, memory_order __f)
        {return atomic_compare_exchange_strong_explicit(this,
                   &const_cast<void*&>(__v), const_cast<void*>(__e), __s, __f);}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(const void*& __v, const void* __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_weak_explicit(this,
                               &const_cast<void*&>(__v), const_cast<void*>(__e),
                               __s, __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_weak(const void*& __v, const void* __e,
                               memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_weak_explicit(this,
                               &const_cast<void*&>(__v), const_cast<void*>(__e),
                               __s, __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(const void*& __v, const void* __e,
                               memory_order __s = memory_order_seq_cst) volatile
        {return atomic_compare_exchange_strong_explicit(this,
                               &const_cast<void*&>(__v), const_cast<void*>(__e),
                               __s, __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    bool compare_exchange_strong(const void*& __v, const void* __e,
                                 memory_order __s = memory_order_seq_cst)
        {return atomic_compare_exchange_strong_explicit(this,
                               &const_cast<void*&>(__v), const_cast<void*>(__e),
                               __s, __translate_memory_order(__s));}
    _LIBCPP_INLINE_VISIBILITY
    void* fetch_add(ptrdiff_t __v,
                    memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* fetch_add(ptrdiff_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_add_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* fetch_sub(ptrdiff_t __v,
                    memory_order __o = memory_order_seq_cst) volatile
        {return atomic_fetch_sub_explicit(this, __v, __o);}
    _LIBCPP_INLINE_VISIBILITY
    void* fetch_sub(ptrdiff_t __v, memory_order __o = memory_order_seq_cst)
        {return atomic_fetch_sub_explicit(this, __v, __o);}
#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS
    atomic_address() = default;
#else
    _LIBCPP_INLINE_VISIBILITY
    atomic_address() {}
#endif
    _LIBCPP_INLINE_VISIBILITY
    /*constexpr*/ atomic_address(void* __v)
        : __v_(__v) {}
#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS
    atomic_address(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) = delete;
    atomic_address& operator=(const atomic_address&) volatile = delete;
#else
private:
    atomic_address(const atomic_address&);
    atomic_address& operator=(const atomic_address&);
    atomic_address& operator=(const atomic_address&) volatile;
public:
#endif
    _LIBCPP_INLINE_VISIBILITY
    void* operator=(const void* __v) volatile
        {store(const_cast<void*>(__v)); return const_cast<void*>(__v);}
    _LIBCPP_INLINE_VISIBILITY
    void* operator=(const void* __v)
        {store(const_cast<void*>(__v)); return const_cast<void*>(__v);}
    _LIBCPP_INLINE_VISIBILITY
    void* operator+=(ptrdiff_t __v) volatile
        {return static_cast<char*>(fetch_add(__v)) + __v;}
    _LIBCPP_INLINE_VISIBILITY
    void* operator+=(ptrdiff_t __v)
        {return static_cast<char*>(fetch_add(__v)) + __v;}
    _LIBCPP_INLINE_VISIBILITY
    void* operator-=(ptrdiff_t __v) volatile
        {return static_cast<char*>(fetch_sub(__v)) - __v;}
    _LIBCPP_INLINE_VISIBILITY
    void* operator-=(ptrdiff_t __v)
        {return static_cast<char*>(fetch_sub(__v)) - __v;}
} atomic_address;

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const volatile atomic_address*)
{
    typedef void* type;
    return __atomic_is_lock_free(type);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_is_lock_free(const atomic_address* __obj)
{
    return atomic_is_lock_free(const_cast<volatile atomic_address*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(volatile atomic_address* __obj, void* __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_init(atomic_address* __obj, void* __desr)
{
    __obj->__v_ = __desr;
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(volatile atomic_address* __obj, void* __desr)
{
    __atomic_store(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store(atomic_address* __obj, void* __desr)
{
    atomic_store(const_cast<volatile atomic_address*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(volatile atomic_address* __obj, void* __desr,
                      memory_order __o)
{
    __atomic_store(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void
atomic_store_explicit(atomic_address* __obj, void* __desr, memory_order __o)
{
    atomic_store_explicit(const_cast<volatile atomic_address*>(__obj), __desr,
                                                                           __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_load(const volatile atomic_address* __obj)
{
    return __atomic_load(&__obj->__v_, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_load(const atomic_address* __obj)
{
    return atomic_load(const_cast<const volatile atomic_address*>(__obj));
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_load_explicit(const volatile atomic_address* __obj, memory_order __o)
{
    return __atomic_load(&__obj->__v_, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_load_explicit(const atomic_address* __obj, memory_order __o)
{
    return atomic_load_explicit(const_cast<const volatile atomic_address*>
                                                                  (__obj), __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_exchange(volatile atomic_address* __obj, void* __desr)
{
    return __atomic_exchange(&__obj->__v_, __desr, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_exchange(atomic_address* __obj, void* __desr)
{
    return atomic_exchange(const_cast<volatile atomic_address*>(__obj), __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_exchange_explicit(volatile atomic_address* __obj, void* __desr,
                         memory_order __o)
{
    return __atomic_exchange(&__obj->__v_, __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_exchange_explicit(atomic_address* __obj, void* __desr, memory_order __o)
{
    return atomic_exchange_explicit(const_cast<volatile atomic_address*>
                                                          (__obj), __desr, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(volatile atomic_address* __obj, void** __exp,
                             void* __desr)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak(atomic_address* __obj, void** __exp, void* __desr)
{
    return atomic_compare_exchange_weak(const_cast<volatile atomic_address*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(volatile atomic_address* __obj, void** __exp,
                               void* __desr)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr,
                                    memory_order_seq_cst, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong(atomic_address* __obj, void** __exp,
                               void* __desr)
{
    return atomic_compare_exchange_strong(const_cast<volatile atomic_address*>
                                                        (__obj), __exp, __desr);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(volatile atomic_address* __obj,
                                      void** __exp, void* __desr,
                                      memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_weak(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_weak_explicit(atomic_address* __obj, void** __exp,
                                      void* __desr, memory_order __s,
                                      memory_order __f)
{
    return atomic_compare_exchange_weak_explicit(
             const_cast<volatile atomic_address*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(volatile atomic_address* __obj,
                                        void** __exp, void* __desr,
                                        memory_order __s, memory_order __f)
{
    return __atomic_compare_exchange_strong(&__obj->__v_, __exp, __desr, __s,
                                                                           __f);
}

inline _LIBCPP_INLINE_VISIBILITY
bool
atomic_compare_exchange_strong_explicit(atomic_address* __obj, void** __exp,
                                        void* __desr, memory_order __s,
                                        memory_order __f)
{
    return atomic_compare_exchange_strong_explicit(
             const_cast<volatile atomic_address*>(__obj), __exp, __desr, __s, __f);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_add(volatile atomic_address* __obj, ptrdiff_t __v)
{
    return __atomic_fetch_add(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_add(atomic_address* __obj, ptrdiff_t __v)
{
    return atomic_fetch_add(const_cast<volatile atomic_address*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_add_explicit(volatile atomic_address* __obj, ptrdiff_t __v,
                          memory_order __o)
{
    return __atomic_fetch_add(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_add_explicit(atomic_address* __obj, ptrdiff_t __v,
                          memory_order __o)
{
    return atomic_fetch_add_explicit(const_cast<volatile atomic_address*>(__obj),
                                                                      __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_sub(volatile atomic_address* __obj, ptrdiff_t __v)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, memory_order_seq_cst);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_sub(atomic_address* __obj, ptrdiff_t __v)
{
    return atomic_fetch_sub(const_cast<volatile atomic_address*>(__obj), __v);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_sub_explicit(volatile atomic_address* __obj, ptrdiff_t __v,
                          memory_order __o)
{
    return __atomic_fetch_sub(&__obj->__v_, __v, __o);
}

inline _LIBCPP_INLINE_VISIBILITY
void*
atomic_fetch_sub_explicit(atomic_address* __obj, ptrdiff_t __v,
                          memory_order __o)
{
    return atomic_fetch_sub_explicit(const_cast<volatile atomic_address*>(__obj),
                                                                      __v, __o);
}

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_ATOMIC
