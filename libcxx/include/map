// -*- C++ -*-
//===----------------------------- map ------------------------------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//

#ifndef _LIBCPP_MAP
#define _LIBCPP_MAP

/*

    map synopsis

namespace std
{

template <class Key, class T, class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class map
{
public:
    // types:
    typedef Key                                      key_type;
    typedef T                                        mapped_type;
    typedef pair<const key_type, mapped_type>        value_type;
    typedef Compare                                  key_compare;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;

    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        value_compare(key_compare c);
    public:
        bool operator()(const value_type& x, const value_type& y) const;
    };

    // construct/copy/destroy:
    map();
    explicit map(const key_compare& comp);
    map(const key_compare& comp, const allocator_type& a);
    template <class InputIterator>
        map(InputIterator first, InputIterator last,
            const key_compare& comp = key_compare());
    template <class InputIterator>
        map(InputIterator first, InputIterator last,
            const key_compare& comp, const allocator_type& a);
    map(const map& m);
    map(map&& m);
    explicit map(const allocator_type& a);
    map(const map& m, const allocator_type& a);
    map(map&& m, const allocator_type& a);
    map(initializer_list<value_type> il, const key_compare& comp = key_compare());
    map(initializer_list<value_type> il, const key_compare& comp, const allocator_type& a);
    ~map();

    map& operator=(const map& m);
    map& operator=(map&& m);
    map& operator=(initializer_list<value_type> il);

    // iterators:
          iterator begin();
    const_iterator begin() const;
          iterator end();
    const_iterator end()   const;

          reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
          reverse_iterator rend();
    const_reverse_iterator rend()   const;

    const_iterator         cbegin()  const;
    const_iterator         cend()    const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend()   const;

    // capacity:
    bool      empty()    const;
    size_type size()     const;
    size_type max_size() const;

    // element access:
    mapped_type& operator[](const key_type& k);
    mapped_type& operator[](key_type&& k);

          mapped_type& at(const key_type& k);
    const mapped_type& at(const key_type& k) const;

    // modifiers:
    template <class... Args>
        pair<iterator, bool> emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    pair<iterator, bool> insert(const value_type& v);
    template <class P>
        pair<iterator, bool> insert(P&& p);
    iterator insert(const_iterator position, const value_type& v);
    template <class P>
        iterator insert(const_iterator position, P&& p);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type> il);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void clear();

    void swap(map& m);

    // observers:
    allocator_type get_allocator() const;
    key_compare    key_comp()      const;
    value_compare  value_comp()    const;

    // map operations:
          iterator find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
          iterator lower_bound(const key_type& k);
    const_iterator lower_bound(const key_type& k) const;
          iterator upper_bound(const key_type& k);
    const_iterator upper_bound(const key_type& k) const;
    pair<iterator,iterator>             equal_range(const key_type& k);
    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;
};

template <class Key, class T, class Compare, class Allocator>
bool
operator==(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator< (const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator!=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator> (const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator>=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator<=(const map<Key, T, Compare, Allocator>& x,
           const map<Key, T, Compare, Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>
void
swap(map<Key, T, Compare, Allocator>& x, map<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare = less<Key>,
          class Allocator = allocator<pair<const Key, T>>>
class multimap
{
public:
    // types:
    typedef Key                                      key_type;
    typedef T                                        mapped_type;
    typedef pair<const key_type,mapped_type>         value_type;
    typedef Compare                                  key_compare;
    typedef Allocator                                allocator_type;
    typedef typename allocator_type::reference       reference;
    typedef typename allocator_type::const_reference const_reference;
    typedef typename allocator_type::size_type       size_type;
    typedef typename allocator_type::difference_type difference_type;
    typedef typename allocator_type::pointer         pointer;
    typedef typename allocator_type::const_pointer   const_pointer;

    typedef implementation-defined                   iterator;
    typedef implementation-defined                   const_iterator;
    typedef std::reverse_iterator<iterator>          reverse_iterator;
    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;

    class value_compare
        : public binary_function<value_type,value_type,bool>
    {
        friend class multimap;
    protected:
        key_compare comp;
        value_compare(key_compare c);
    public:
        bool operator()(const value_type& x, const value_type& y) const;
    };

    // construct/copy/destroy:
    explicit multimap(const key_compare& comp = key_compare());
    multimap(const key_compare& comp, const allocator_type& a);
    template <class InputIterator>
        multimap(InputIterator first, InputIterator last, const key_compare& comp);
    template <class InputIterator>
        multimap(InputIterator first, InputIterator last, const key_compare& comp,
                 const allocator_type& a);
    multimap(const multimap& m);
    multimap(multimap&& m);
    explicit multimap(const allocator_type& a);
    multimap(const multimap& m, const allocator_type& a);
    multimap(multimap&& m, const allocator_type& a);
    multimap(initializer_list<value_type> il, const key_compare& comp = key_compare());
    multimap(initializer_list<value_type> il, const key_compare& comp,
             const allocator_type& a);
    ~multimap();

    multimap& operator=(const multimap& m);
    multimap& operator=(multimap&& m);
    multimap& operator=(initializer_list<value_type> il);

    // iterators:
          iterator begin();
    const_iterator begin() const;
          iterator end();
    const_iterator end()   const;

          reverse_iterator rbegin();
    const_reverse_iterator rbegin() const;
          reverse_iterator rend();
    const_reverse_iterator rend()   const;

    const_iterator         cbegin()  const;
    const_iterator         cend()    const;
    const_reverse_iterator crbegin() const;
    const_reverse_iterator crend()   const;

    // capacity:
    bool      empty()    const;
    size_type size()     const;
    size_type max_size() const;

    // modifiers:
    template <class... Args>
        iterator emplace(Args&&... args);
    template <class... Args>
        iterator emplace_hint(const_iterator position, Args&&... args);
    iterator insert(const value_type& v);
    template <class P>
        iterator insert(P&& p);
    iterator insert(const_iterator position, const value_type& v);
    template <class P>
        iterator insert(const_iterator position, P&& p);
    template <class InputIterator>
        void insert(InputIterator first, InputIterator last);
    void insert(initializer_list<value_type> il);

    iterator  erase(const_iterator position);
    size_type erase(const key_type& k);
    iterator  erase(const_iterator first, const_iterator last);
    void clear();

    void swap(multimap& m);

    // observers:
    allocator_type get_allocator() const;
    key_compare    key_comp()      const;
    value_compare  value_comp()    const;

    // map operations:
          iterator find(const key_type& k);
    const_iterator find(const key_type& k) const;
    size_type      count(const key_type& k) const;
          iterator lower_bound(const key_type& k);
    const_iterator lower_bound(const key_type& k) const;
          iterator upper_bound(const key_type& k);
    const_iterator upper_bound(const key_type& k) const;
    pair<iterator,iterator>             equal_range(const key_type& k);
    pair<const_iterator,const_iterator> equal_range(const key_type& k) const;
};

template <class Key, class T, class Compare, class Allocator>
bool
operator==(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator< (const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator!=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator> (const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator>=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

template <class Key, class T, class Compare, class Allocator>
bool
operator<=(const multimap<Key, T, Compare, Allocator>& x,
           const multimap<Key, T, Compare, Allocator>& y);

// specialized algorithms:
template <class Key, class T, class Compare, class Allocator>
void
swap(multimap<Key, T, Compare, Allocator>& x,
     multimap<Key, T, Compare, Allocator>& y);

}  // std

*/

#include <__config>
#include <__tree>
#include <iterator>
#include <memory>
#include <utility>
#include <functional>
#include <initializer_list>

#pragma GCC system_header

_LIBCPP_BEGIN_NAMESPACE_STD

template <class _Key, class _Tp, class _Compare, bool = is_empty<_Compare>::value>
class __map_value_compare
    : private _Compare
{
    typedef pair<_Key, _Tp> _P;
    typedef pair<const _Key, _Tp> _CP;
public:
    __map_value_compare() : _Compare() {}
    __map_value_compare(_Compare c) : _Compare(c) {}
    const _Compare& key_comp() const {return *this;}
    bool operator()(const _CP& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y.first);}
    bool operator()(const _CP& __x, const _P& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y.first);}
    bool operator()(const _CP& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y);}
    bool operator()(const _P& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y.first);}
    bool operator()(const _P& __x, const _P& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y.first);}
    bool operator()(const _P& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x.first, __y);}
    bool operator()(const _Key& __x, const _CP& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.first);}
    bool operator()(const _Key& __x, const _P& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y.first);}
    bool operator()(const _Key& __x, const _Key& __y) const
        {return static_cast<const _Compare&>(*this)(__x, __y);}

//     bool operator()(const _Tp& __x, const _Tp& __y) const
//         {return static_cast<const _Compare&>(*this)(__x.first, __y.first);}
//     bool operator()(const typename _Tp::first_type& __x, const _Tp& __y) const
//         {return static_cast<const _Compare&>(*this)(__x, __y.first);}
//     bool operator()(const _Tp& __x, const typename _Tp::first_type& __y) const
//         {return static_cast<const _Compare&>(*this)(__x.first, __y);}
//     bool operator()(const typename _Tp::first_type& __x,
//                     const typename _Tp::first_type& __y) const
//         {return static_cast<const _Compare&>(*this)(__x, __y);}
};

template <class _Key, class _Tp, class _Compare>
class __map_value_compare<_Key, _Tp, _Compare, false>
{
    _Compare comp;

    typedef pair<_Key, _Tp> _P;
    typedef pair<const _Key, _Tp> _CP;

public:
    __map_value_compare() : comp() {}
    __map_value_compare(_Compare c) : comp(c) {}
    const _Compare& key_comp() const {return comp;}

    bool operator()(const _CP& __x, const _CP& __y) const
        {return comp(__x.first, __y.first);}
    bool operator()(const _CP& __x, const _P& __y) const
        {return comp(__x.first, __y.first);}
    bool operator()(const _CP& __x, const _Key& __y) const
        {return comp(__x.first, __y);}
    bool operator()(const _P& __x, const _CP& __y) const
        {return comp(__x.first, __y.first);}
    bool operator()(const _P& __x, const _P& __y) const
        {return comp(__x.first, __y.first);}
    bool operator()(const _P& __x, const _Key& __y) const
        {return comp(__x.first, __y);}
    bool operator()(const _Key& __x, const _CP& __y) const
        {return comp(__x, __y.first);}
    bool operator()(const _Key& __x, const _P& __y) const
        {return comp(__x, __y.first);}
    bool operator()(const _Key& __x, const _Key& __y) const
        {return comp(__x, __y);}

//     bool operator()(const _Tp& __x, const _Tp& __y) const
//         {return comp(__x.first, __y.first);}
//     bool operator()(const typename _Tp::first_type& __x, const _Tp& __y) const
//         {return comp(__x, __y.first);}
//     bool operator()(const _Tp& __x, const typename _Tp::first_type& __y) const
//         {return comp(__x.first, __y);}
//     bool operator()(const typename _Tp::first_type& __x,
//                     const typename _Tp::first_type& __y) const
//         {return comp(__x, __y);}
};

template <class _Allocator>
class __map_node_destructor
{
    typedef _Allocator                          allocator_type;
    typedef allocator_traits<allocator_type>    __alloc_traits;
    typedef typename __alloc_traits::value_type::value_type value_type;
public:
    typedef typename __alloc_traits::pointer    pointer;
private:
    typedef typename value_type::first_type     first_type;
    typedef typename value_type::second_type    second_type;

    allocator_type& __na_;

    __map_node_destructor& operator=(const __map_node_destructor&);

public:
    bool __first_constructed;
    bool __second_constructed;

    explicit __map_node_destructor(allocator_type& __na)
        : __na_(__na),
          __first_constructed(false),
          __second_constructed(false)
        {}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    __map_node_destructor(__tree_node_destructor<allocator_type>&& __x)
        : __na_(__x.__na_),
          __first_constructed(__x.__value_constructed),
          __second_constructed(__x.__value_constructed)
        {
            __x.__value_constructed = false;
        }
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    void operator()(pointer __p)
    {
        if (__second_constructed)
            __alloc_traits::destroy(__na_, addressof(__p->__value_.second));
        if (__first_constructed)
            __alloc_traits::destroy(__na_, addressof(__p->__value_.first));
        if (__p)
            __alloc_traits::deallocate(__na_, __p, 1);
    }
};

template <class, class, class, class> class map;
template <class, class, class, class> class multimap;
template <class> class __map_const_iterator;

template <class _TreeIterator>
class __map_iterator
{
    _TreeIterator __i_;

    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;
    typedef const typename _TreeIterator::value_type::first_type key_type;
    typedef typename _TreeIterator::value_type::second_type      mapped_type;
public:
    typedef bidirectional_iterator_tag                           iterator_category;
    typedef pair<key_type, mapped_type>                          value_type;
    typedef typename _TreeIterator::difference_type              difference_type;
    typedef value_type&                                          reference;
    typedef typename __pointer_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind<value_type>
#else
            rebind<value_type>::other
#endif
                                                                 pointer;

    __map_iterator() {}

    __map_iterator(_TreeIterator __i) : __i_(__i) {}

    reference operator*() const {return *operator->();}
    pointer operator->() const {return (pointer)__i_.operator->();}

    __map_iterator& operator++() {++__i_; return *this;}
    __map_iterator operator++(int)
    {
        __map_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __map_iterator& operator--() {--__i_; return *this;}
    __map_iterator operator--(int)
    {
        __map_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend bool operator==(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend bool operator!=(const __map_iterator& __x, const __map_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class> friend class __map_const_iterator;
};

template <class _TreeIterator>
class __map_const_iterator
{
    _TreeIterator __i_;

    typedef typename _TreeIterator::__pointer_traits             __pointer_traits;
    typedef const typename _TreeIterator::value_type::first_type key_type;
    typedef typename _TreeIterator::value_type::second_type      mapped_type;
public:
    typedef bidirectional_iterator_tag                           iterator_category;
    typedef pair<key_type, mapped_type>                          value_type;
    typedef typename _TreeIterator::difference_type              difference_type;
    typedef const value_type&                                    reference;
    typedef typename __pointer_traits::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind<value_type>
#else
            rebind<value_type>::other
#endif
                                                                 pointer;

    __map_const_iterator() {}

    __map_const_iterator(_TreeIterator __i) : __i_(__i) {}
    __map_const_iterator(
            __map_iterator<typename _TreeIterator::__non_const_iterator> __i)
                : __i_(__i.__i_) {}

    reference operator*() const {return *operator->();}
    pointer operator->() const {return (pointer)__i_.operator->();}

    __map_const_iterator& operator++() {++__i_; return *this;}
    __map_const_iterator operator++(int)
    {
        __map_const_iterator __t(*this);
        ++(*this);
        return __t;
    }

    __map_const_iterator& operator--() {--__i_; return *this;}
    __map_const_iterator operator--(int)
    {
        __map_const_iterator __t(*this);
        --(*this);
        return __t;
    }

    friend bool operator==(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ == __y.__i_;}
    friend bool operator!=(const __map_const_iterator& __x, const __map_const_iterator& __y)
        {return __x.__i_ != __y.__i_;}

    template <class, class, class, class> friend class map;
    template <class, class, class, class> friend class multimap;
    template <class, class, class> friend class __tree_const_iterator;
};

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class map
{
public:
    // types:
    typedef _Key                                     key_type;
    typedef _Tp                                      mapped_type;
    typedef pair<const key_type, mapped_type>        value_type;
    typedef _Compare                                 key_compare;
    typedef _Allocator                               allocator_type;
    typedef value_type&                              reference;
    typedef const value_type&                        const_reference;

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class map;
    protected:
        key_compare comp;

        value_compare(key_compare c) : comp(c) {}
    public:
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:
    typedef pair<key_type, mapped_type>                             __value_type;
    typedef __map_value_compare<key_type, mapped_type, key_compare> __vc;
    typedef typename allocator_traits<allocator_type>::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind_alloc<__value_type>
#else
            rebind_alloc<__value_type>::other
#endif
                                                           __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type>   __base;
    typedef typename __base::__node_traits                 __node_traits;
    typedef allocator_traits<allocator_type>               __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer               pointer;
    typedef typename __alloc_traits::const_pointer         const_pointer;
    typedef typename __alloc_traits::size_type             size_type;
    typedef typename __alloc_traits::difference_type       difference_type;
    typedef __map_iterator<typename __base::iterator>      iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef _STD::reverse_iterator<iterator>               reverse_iterator;
    typedef _STD::reverse_iterator<const_iterator>         const_reverse_iterator;

    explicit map(const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp)) {}

    explicit map(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a) {}

    template <class _InputIterator>
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        map(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__f, __l);
        }

    map(const map& __m)
        : __tree_(__m.__tree_)
        {
            insert(__m.begin(), __m.end());
        }

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

    map(map&& __m)
        : __tree_(_STD::move(__m.__tree_))
        {
        }

    map(map&& __m, const allocator_type& __a);

    map(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    map(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__il.begin(), __il.end());
        }

    map& operator=(map&& __m)
        {
            __tree_ = _STD::move(__m.__tree_);
            return *this;
        }

    map& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_unique(__il.begin(), __il.end());
            return *this;
        }

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    explicit map(const allocator_type& __a)
        : __tree_(__a)
        {
        }

    map(const map& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), __a)
        {
            insert(__m.begin(), __m.end());
        }

          iterator begin()       {return __tree_.begin();}
    const_iterator begin() const {return __tree_.begin();}
          iterator end()         {return __tree_.end();}
    const_iterator end()   const {return __tree_.end();}

          reverse_iterator rbegin()       {return       reverse_iterator(end());}
    const_reverse_iterator rbegin() const {return const_reverse_iterator(end());}
          reverse_iterator rend()         {return       reverse_iterator(begin());}
    const_reverse_iterator rend()   const {return const_reverse_iterator(begin());}

    const_iterator         cbegin()  const {return begin();}
    const_iterator         cend()    const {return end();}
    const_reverse_iterator crbegin() const {return rbegin();}
    const_reverse_iterator crend()   const {return rend();}

    bool      empty()    const {return __tree_.size() == 0;}
    size_type size()     const {return __tree_.size();}
    size_type max_size() const {return __tree_.max_size();}

    mapped_type& operator[](const key_type& __k);
#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    mapped_type& operator[](key_type&& __k);
#endif

          mapped_type& at(const key_type& __k);
    const mapped_type& at(const key_type& __k) const;

    allocator_type get_allocator() const {return __tree_.__alloc();}
    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}
    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

    pair<iterator, bool>
        emplace() {return __tree_.__emplace_unique();}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        pair<iterator, bool>
        emplace(_A0&& __a0)
            {return __tree_.__emplace_unique(_STD::forward<_A0>(__a0));}

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        pair<iterator, bool>
        emplace(_A0&& __a0, _Args&& ...__args);

#endif  // _LIBCPP_HAS_NO_VARIADICS

    iterator
    emplace_hint(const_iterator __p)
        {return __tree_.__emplace_hint_unique(__p.__i_);}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator
        emplace_hint(const_iterator __p, _A0&& __a0)
            {return __tree_.__emplace_hint_unique(__p.__i_, _STD::forward<_A0>(__a0));}

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator
        emplace_hint(const_iterator __p, _A0&& __a0, _Args&& ...__args);

#endif  // _LIBCPP_HAS_NO_VARIADICS

    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        pair<iterator, bool> insert(_P&& __p)
            {return __tree_.__insert_unique(_STD::forward<_P>(__p));}

    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(const_iterator __pos, _P&& __p)
            {return __tree_.__insert_unique(__pos.__i_, _STD::forward<_P>(__p));}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    pair<iterator, bool>
        insert(const value_type& __v) {return __tree_.__insert_unique(__v);}

    iterator
        insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_unique(__p.__i_, __v);}

    template <class _InputIterator>
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                insert(__e.__i_, *__f);
        }

    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    size_type erase(const key_type& __k)
        {return __tree_.__erase_unique(__k);}
    iterator  erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    void clear() {__tree_.clear();}

    void swap(map& __m) {__tree_.swap(__m.__tree_);}

    iterator find(const key_type& __k)             {return __tree_.find(__k);}
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
    size_type      count(const key_type& __k) const
        {return __tree_.__count_unique(__k);}
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    const_iterator lower_bound(const key_type& __k) const
        {return __tree_.lower_bound(__k);}
    iterator upper_bound(const key_type& __k)
        {return __tree_.upper_bound(__k);}
    const_iterator upper_bound(const key_type& __k) const
        {return __tree_.upper_bound(__k);}
    pair<iterator,iterator> equal_range(const key_type& __k)
        {return __tree_.__equal_range_unique(__k);}
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
        {return __tree_.__equal_range_unique(__k);}

private:
    typedef typename __base::__node                    __node;
    typedef typename __base::__node_allocator          __node_allocator;
    typedef typename __base::__node_pointer            __node_pointer;
    typedef typename __base::__node_const_pointer      __node_const_pointer;
    typedef typename __base::__node_base_pointer       __node_base_pointer;
    typedef typename __base::__node_base_const_pointer __node_base_const_pointer;
    typedef __map_node_destructor<__node_allocator> _D;
    typedef unique_ptr<__node, _D> __node_holder;

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    __node_holder __construct_node();
    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0);
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0, _Args&& ...__args);
#endif  // _LIBCPP_HAS_NO_VARIADICS
#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
    __node_holder __construct_node(const key_type& __k);
#endif

    __node_base_pointer&
        __find_equal_key(__node_base_pointer& __parent, const key_type& __k);
    __node_base_pointer&
        __find_equal_key(const_iterator __hint,
                         __node_base_pointer& __parent, const key_type& __k);
    __node_base_const_pointer
        __find_equal_key(__node_base_const_pointer& __parent, const key_type& __k) const;
};

// Find place to insert if __k doesn't exist
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __k exists, set parent to node of __k and return reference to node of __k
template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_pointer& __parent,
                                                       const key_type& __k)
{
    __node_pointer __nd = __tree_.__root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.first))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = __nd;
                    return __parent->__left_;
                }
            }
            else if (__tree_.value_comp().key_comp()(__nd->__value_.first, __k))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = __nd;
                    return __parent->__right_;
                }
            }
            else
            {
                __parent = __nd;
                return __parent;
            }
        }
    }
    __parent = __tree_.__end_node();
    return __parent->__left_;
}

// Find place to insert if __k doesn't exist
// First check prior to __hint.
// Next check after __hint.
// Next do O(log N) search.
// Set __parent to parent of null leaf
// Return reference to null leaf
// If __k exists, set parent to node of __k and return reference to node of __k
template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_pointer&
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(const_iterator __hint,
                                                       __node_base_pointer& __parent,
                                                       const key_type& __k)
{
    if (__hint == end() || __tree_.value_comp().key_comp()(__k, __hint->first))  // check before
    {
        // __k < *__hint
        const_iterator __prior = __hint;
        if (__prior == begin() || __tree_.value_comp().key_comp()((--__prior)->first, __k))
        {
            // *prev(__hint) < __k < *__hint
            if (__hint.__ptr_->__left_ == nullptr)
            {
                __parent = const_cast<__node_pointer&>(__hint.__ptr_);
                return __parent->__left_;
            }
            else
            {
                __parent = const_cast<__node_pointer&>(__prior.__ptr_);
                return __parent->__right_;
            }
        }
        // __k <= *prev(__hint)
        return __find_equal_key(__parent, __k);
    }
    else if (__tree_.value_comp().key_comp()(__hint->first, __k))  // check after
    {
        // *__hint < __k
        const_iterator __next = next(__hint);
        if (__next == end() || __tree_.value_comp().key_comp()(__k, __next->first))
        {
            // *__hint < __k < *next(__hint)
            if (__hint.__ptr_->__right_ == nullptr)
            {
                __parent = const_cast<__node_pointer&>(__hint.__ptr_);
                return __parent->__right_;
            }
            else
            {
                __parent = const_cast<__node_pointer&>(__next.__ptr_);
                return __parent->__left_;
            }
        }
        // *next(__hint) <= __k
        return __find_equal_key(__parent, __k);
    }
    // else __k == *__hint
    __parent = const_cast<__node_pointer&>(__hint.__ptr_);
    return __parent;
}

// Find __k
// Set __parent to parent of null leaf and
//    return reference to null leaf iv __k does not exist.
// If __k exists, set parent to node of __k and return reference to node of __k
template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_base_const_pointer
map<_Key, _Tp, _Compare, _Allocator>::__find_equal_key(__node_base_const_pointer& __parent,
                                                       const key_type& __k) const
{
    __node_const_pointer __nd = __tree_.__root();
    if (__nd != nullptr)
    {
        while (true)
        {
            if (__tree_.value_comp().key_comp()(__k, __nd->__value_.first))
            {
                if (__nd->__left_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__left_);
                else
                {
                    __parent = __nd;
                    return const_cast<const __node_base_const_pointer&>(__parent->__left_);
                }
            }
            else if (__tree_.value_comp().key_comp()(__nd->__value_.first, __k))
            {
                if (__nd->__right_ != nullptr)
                    __nd = static_cast<__node_pointer>(__nd->__right_);
                else
                {
                    __parent = __nd;
                    return const_cast<const __node_base_const_pointer&>(__parent->__right_);
                }
            }
            else
            {
                __parent = __nd;
                return __parent;
            }
        }
    }
    __parent = __tree_.__end_node();
    return const_cast<const __node_base_const_pointer&>(__parent->__left_);
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
map<_Key, _Tp, _Compare, _Allocator>::map(map&& __m, const allocator_type& __a)
    : __tree_(_STD::move(__m.__tree_), __a)
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_unique(__e.__i_,
                    _STD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node()
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second));
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0,
          class>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_), _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

#ifndef _LIBCPP_HAS_NO_VARIADICS

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _Args&& ...__args)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first), _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second), _STD::forward<_Args>(__args)...);
    __h.get_deleter().__second_constructed = true;
    return __h;
}

#endif  // _LIBCPP_HAS_NO_VARIADICS

#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
typename map<_Key, _Tp, _Compare, _Allocator>::__node_holder
map<_Key, _Tp, _Compare, _Allocator>::__construct_node(const key_type& __k)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first), __k);
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second));
    __h.get_deleter().__second_constructed = true;
    return _STD::move(__h);
}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](const key_type& __k)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal_key(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(__k);
        __tree_.__insert_node_at(__parent, __child, __h.get());
        __r = __h.release();
    }
    return __r->__value_.second;
}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::operator[](key_type&& __k)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal_key(__parent, __k);
    __node_pointer __r = static_cast<__node_pointer>(__child);
    if (__child == nullptr)
    {
        __node_holder __h = __construct_node(_STD::move(__k));
        __tree_.__insert_node_at(__parent, __child, __h.get());
        __r = __h.release();
    }
    return __r->__value_.second;
}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
_Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k)
{
    __node_base_pointer __parent;
    __node_base_pointer& __child = __find_equal_key(__parent, __k);
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__child == nullptr)
        throw out_of_range("map::at:  key not found");
#endif  // _LIBCPP_NO_EXCEPTIONS
    return static_cast<__node_pointer>(__child)->__value_.second;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
const _Tp&
map<_Key, _Tp, _Compare, _Allocator>::at(const key_type& __k) const
{
    __node_base_const_pointer __parent;
    __node_base_const_pointer __child = __find_equal_key(__parent, __k);
#ifndef _LIBCPP_NO_EXCEPTIONS
    if (__child == nullptr)
        throw out_of_range("map::at:  key not found");
#endif  // _LIBCPP_NO_EXCEPTIONS
    return static_cast<__node_const_pointer>(__child)->__value_.second;
}

#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class //= typename enable_if<is_convertible<_A0, _Key>::value>::type
         >
pair<typename map<_Key, _Tp, _Compare, _Allocator>::iterator, bool>
map<_Key, _Tp, _Compare, _Allocator>::emplace(_A0&& __a0, _Args&& ...__args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    pair<iterator, bool> __r = __tree_.__node_insert_unique(__h.get());
    if (__r.second)
        __h.release();
    return __r;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class //= typename enable_if<is_convertible<_A0, _Key>::value>::type
         >
typename map<_Key, _Tp, _Compare, _Allocator>::iterator
map<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,
                                                   _A0&& __a0, _Args&& ...__args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    iterator __r = __tree_.__node_insert_unique(__p.__i_, __h.get());
    if (__r.__i_.__ptr_ == __h.get())
        __h.release();
    return __r;
}

#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator==(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && _STD::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator< (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return _STD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator!=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator> (const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator>=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator<=(const map<_Key, _Tp, _Compare, _Allocator>& __x,
           const map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
void
swap(map<_Key, _Tp, _Compare, _Allocator>& __x,
     map<_Key, _Tp, _Compare, _Allocator>& __y)
{
    __x.swap(__y);
}

template <class _Key, class _Tp, class _Compare = less<_Key>,
          class _Allocator = allocator<pair<const _Key, _Tp> > >
class multimap
{
public:
    // types:
    typedef _Key                                     key_type;
    typedef _Tp                                      mapped_type;
    typedef pair<const key_type, mapped_type>        value_type;
    typedef _Compare                                 key_compare;
    typedef _Allocator                               allocator_type;
    typedef value_type&                              reference;
    typedef const value_type&                        const_reference;

    class value_compare
        : public binary_function<value_type, value_type, bool>
    {
        friend class multimap;
    protected:
        key_compare comp;

        value_compare(key_compare c) : comp(c) {}
    public:
        bool operator()(const value_type& __x, const value_type& __y) const
            {return comp(__x.first, __y.first);}
    };

private:
    typedef pair<key_type, mapped_type>                             __value_type;
    typedef __map_value_compare<key_type, mapped_type, key_compare> __vc;
    typedef typename allocator_traits<allocator_type>::template
#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES
            rebind_alloc<__value_type>
#else
            rebind_alloc<__value_type>::other
#endif
                                                                    __allocator_type;
    typedef __tree<__value_type, __vc, __allocator_type>            __base;
    typedef typename __base::__node_traits                          __node_traits;
    typedef allocator_traits<allocator_type>                        __alloc_traits;

    __base __tree_;

public:
    typedef typename __alloc_traits::pointer               pointer;
    typedef typename __alloc_traits::const_pointer         const_pointer;
    typedef typename __alloc_traits::size_type             size_type;
    typedef typename __alloc_traits::difference_type       difference_type;
    typedef __map_iterator<typename __base::iterator>      iterator;
    typedef __map_const_iterator<typename __base::const_iterator> const_iterator;
    typedef _STD::reverse_iterator<iterator>               reverse_iterator;
    typedef _STD::reverse_iterator<const_iterator>         const_reverse_iterator;

    explicit multimap(const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp)) {}

    explicit multimap(const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a) {}

    template <class _InputIterator>
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__f, __l);
        }

    template <class _InputIterator>
        multimap(_InputIterator __f, _InputIterator __l,
            const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__f, __l);
        }

    multimap(const multimap& __m)
        : __tree_(__m.__tree_.value_comp(),
          __alloc_traits::select_on_container_copy_construction(__m.__tree_.__alloc()))
        {
            insert(__m.begin(), __m.end());
        }

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

    multimap(multimap&& __m)
        : __tree_(_STD::move(__m.__tree_))
        {
        }

    multimap(multimap&& __m, const allocator_type& __a);

    multimap(initializer_list<value_type> __il, const key_compare& __comp = key_compare())
        : __tree_(__vc(__comp))
        {
            insert(__il.begin(), __il.end());
        }

    multimap(initializer_list<value_type> __il, const key_compare& __comp, const allocator_type& __a)
        : __tree_(__vc(__comp), __a)
        {
            insert(__il.begin(), __il.end());
        }

    multimap& operator=(multimap&& __m)
        {
            __tree_ = _STD::move(__m.__tree_);
            return *this;
        }

    multimap& operator=(initializer_list<value_type> __il)
        {
            __tree_.__assign_multi(__il.begin(), __il.end());
            return *this;
        }
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    explicit multimap(const allocator_type& __a)
        : __tree_(__a)
        {
        }

    multimap(const multimap& __m, const allocator_type& __a)
        : __tree_(__m.__tree_.value_comp(), __a)
        {
            insert(__m.begin(), __m.end());
        }

          iterator begin()       {return __tree_.begin();}
    const_iterator begin() const {return __tree_.begin();}
          iterator end()         {return __tree_.end();}
    const_iterator end()   const {return __tree_.end();}

          reverse_iterator rbegin()       {return       reverse_iterator(end());}
    const_reverse_iterator rbegin() const {return const_reverse_iterator(end());}
          reverse_iterator rend()         {return       reverse_iterator(begin());}
    const_reverse_iterator rend()   const {return const_reverse_iterator(begin());}

    const_iterator         cbegin()  const {return begin();}
    const_iterator         cend()    const {return end();}
    const_reverse_iterator crbegin() const {return rbegin();}
    const_reverse_iterator crend()   const {return rend();}

    bool      empty()    const {return __tree_.size() == 0;}
    size_type size()     const {return __tree_.size();}
    size_type max_size() const {return __tree_.max_size();}

    allocator_type get_allocator() const {return __tree_.__alloc();}
    key_compare    key_comp()      const {return __tree_.value_comp().key_comp();}
    value_compare  value_comp()    const {return value_compare(__tree_.value_comp().key_comp());}

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

    iterator emplace() {return __tree_.__emplace_multi();}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator
        emplace(_A0&& __a0)
            {return __tree_.__emplace_multi(_STD::forward<_A0>(__a0));}

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator
        emplace(_A0&& __a0, _Args&& ...__args);

#endif  // _LIBCPP_HAS_NO_VARIADICS

    iterator emplace_hint(const_iterator __p)
        {return __tree_.__emplace_hint_multi(__p.__i_);}

    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        iterator
        emplace_hint(const_iterator __p, _A0&& __a0)
            {return __tree_.__emplace_hint_multi(__p.__i_, _STD::forward<_A0>(__a0));}

#ifndef _LIBCPP_HAS_NO_VARIADICS

    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        iterator
        emplace_hint(const_iterator __p, _A0&& __a0, _Args&& ...__args);

#endif  // _LIBCPP_HAS_NO_VARIADICS

    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(_P&& __p)
            {return __tree_.__insert_multi(_STD::forward<_P>(__p));}

    template <class _P,
              class = typename enable_if<is_convertible<_P, value_type>::value>::type>
        iterator insert(const_iterator __pos, _P&& __p)
            {return __tree_.__insert_multi(__pos.__i_, _STD::forward<_P>(__p));}

#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

    iterator insert(const value_type& __v) {return __tree_.__insert_multi(__v);}

    iterator insert(const_iterator __p, const value_type& __v)
            {return __tree_.__insert_multi(__p.__i_, __v);}

    template <class _InputIterator>
        void insert(_InputIterator __f, _InputIterator __l)
        {
            for (const_iterator __e = cend(); __f != __l; ++__f)
                __tree_.__insert_multi(__e.__i_, *__f);
        }

    void insert(initializer_list<value_type> __il)
        {insert(__il.begin(), __il.end());}

    iterator erase(const_iterator __p) {return __tree_.erase(__p.__i_);}
    size_type erase(const key_type& __k) {return __tree_.__erase_multi(__k);}
    iterator  erase(const_iterator __f, const_iterator __l)
        {return __tree_.erase(__f.__i_, __l.__i_);}
    void clear() {__tree_.clear();}

    void swap(multimap& __m) {__tree_.swap(__m.__tree_);}

    iterator find(const key_type& __k)             {return __tree_.find(__k);}
    const_iterator find(const key_type& __k) const {return __tree_.find(__k);}
    size_type      count(const key_type& __k) const
        {return __tree_.__count_multi(__k);}
    iterator lower_bound(const key_type& __k)
        {return __tree_.lower_bound(__k);}
    const_iterator lower_bound(const key_type& __k) const
            {return __tree_.lower_bound(__k);}
    iterator upper_bound(const key_type& __k)
            {return __tree_.upper_bound(__k);}
    const_iterator upper_bound(const key_type& __k) const
            {return __tree_.upper_bound(__k);}
    pair<iterator,iterator>             equal_range(const key_type& __k)
            {return __tree_.__equal_range_multi(__k);}
    pair<const_iterator,const_iterator> equal_range(const key_type& __k) const
            {return __tree_.__equal_range_multi(__k);}

private:
    typedef typename __base::__node                    __node;
    typedef typename __base::__node_allocator          __node_allocator;
    typedef typename __base::__node_pointer            __node_pointer;
    typedef typename __base::__node_const_pointer      __node_const_pointer;
    typedef __map_node_destructor<__node_allocator> _D;
    typedef unique_ptr<__node, _D> __node_holder;

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES
    __node_holder __construct_node();
    template <class _A0,
              class = typename enable_if<is_convertible<_A0, value_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0);
#ifndef _LIBCPP_HAS_NO_VARIADICS
    template <class _A0, class ..._Args,
              class = typename enable_if<is_convertible<_A0, key_type>::value>::type>
        __node_holder __construct_node(_A0&& __a0, _Args&& ...__args);
#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES
};

#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES

template <class _Key, class _Tp, class _Compare, class _Allocator>
multimap<_Key, _Tp, _Compare, _Allocator>::multimap(multimap&& __m, const allocator_type& __a)
    : __tree_(_STD::move(__m.__tree_), __a)
{
    if (__a != __m.get_allocator())
    {
        const_iterator __e = cend();
        while (!__m.empty())
            __tree_.__insert_multi(__e.__i_,
                    _STD::move(__m.__tree_.remove(__m.begin().__i_)->__value_));
    }
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
typename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder
multimap<_Key, _Tp, _Compare, _Allocator>::__construct_node()
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second));
    __h.get_deleter().__second_constructed = true;
    return __h;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0,
          class // = typename enable_if<is_convertible<_A0, value_type>::value>::type
         >
typename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder
multimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_), _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __h.get_deleter().__second_constructed = true;
    return __h;
}

#ifndef _LIBCPP_HAS_NO_VARIADICS

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class // = typename enable_if<is_convertible<_A0, key_type>::value>::type
         >
typename multimap<_Key, _Tp, _Compare, _Allocator>::__node_holder
multimap<_Key, _Tp, _Compare, _Allocator>::__construct_node(_A0&& __a0, _Args&& ...__args)
{
    __node_allocator& __na = __tree_.__node_alloc();
    __node_holder __h(__node_traits::allocate(__na, 1), _D(__na));
    __node_traits::construct(__na, addressof(__h->__value_.first), _STD::forward<_A0>(__a0));
    __h.get_deleter().__first_constructed = true;
    __node_traits::construct(__na, addressof(__h->__value_.second), _STD::forward<_Args>(__args)...);
    __h.get_deleter().__second_constructed = true;
    return __h;
}

#endif  // _LIBCPP_HAS_NO_VARIADICS
#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES

#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class //= typename enable_if<is_convertible<_A0, _Key>::value>::type
         >
typename multimap<_Key, _Tp, _Compare, _Allocator>::iterator
multimap<_Key, _Tp, _Compare, _Allocator>::emplace(_A0&& __a0, _Args&& ...__args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    iterator __r = __tree_.__node_insert_multi(__h.get());
    __h.release();
    return __r;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
template <class _A0, class ..._Args,
          class //= typename enable_if<is_convertible<_A0, _Key>::value>::type
         >
typename multimap<_Key, _Tp, _Compare, _Allocator>::iterator
multimap<_Key, _Tp, _Compare, _Allocator>::emplace_hint(const_iterator __p,
                                                        _A0&& __a0,
                                                        _Args&& ...__args)
{
    __node_holder __h = __construct_node(_STD::forward<_A0>(__a0),
                                         _STD::forward<_Args>(__args)...);
    iterator __r = __tree_.__node_insert_multi(__p.__i_, __h.get());
    __h.release();
    return __r;
}

#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator==(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __x.size() == __y.size() && _STD::equal(__x.begin(), __x.end(), __y.begin());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator< (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return _STD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator!=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x == __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator> (const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return __y < __x;
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator>=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__x < __y);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
bool
operator<=(const multimap<_Key, _Tp, _Compare, _Allocator>& __x,
           const multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    return !(__y < __x);
}

template <class _Key, class _Tp, class _Compare, class _Allocator>
inline
void
swap(multimap<_Key, _Tp, _Compare, _Allocator>& __x,
     multimap<_Key, _Tp, _Compare, _Allocator>& __y)
{
    __x.swap(__y);
}

_LIBCPP_END_NAMESPACE_STD

#endif  // _LIBCPP_MAP
