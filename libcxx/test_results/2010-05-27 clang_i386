passed 1 tests in /test
passed 1 tests in /test/algorithms
passed 1 tests in /test/algorithms/alg.c.library
passed 1 tests in /test/algorithms/alg.modifying.operations
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.copy
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.fill
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.generate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.move
passed 5 tests in /test/algorithms/alg.modifying.operations/alg.partitions
passed 3 tests in /test/algorithms/alg.modifying.operations/alg.random.shuffle
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.remove
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.replace
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.reverse
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.rotate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.swap
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.transform
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.unique
passed 1 tests in /test/algorithms/alg.nonmodifying
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.adjacent.find
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.all_of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.any_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.count
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.equal
passed 3 tests in /test/algorithms/alg.nonmodifying/alg.find
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.end
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.first.of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.foreach
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.is_permutation
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.none_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.search
passed 2 tests in /test/algorithms/alg.nonmodifying/mismatch
passed 1 tests in /test/algorithms/alg.sorting
passed 1 tests in /test/algorithms/alg.sorting/alg.binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/equal.range
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/lower.bound
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/upper.bound
passed 1 tests in /test/algorithms/alg.sorting/alg.heap.operations
passed 4 tests in /test/algorithms/alg.sorting/alg.heap.operations/is.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/make.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/pop.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/push.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/sort.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.lex.comparison
passed 4 tests in /test/algorithms/alg.sorting/alg.merge
max_init_list.pass.cpp:19:2: error: #error max(initializer_list<T> t) is not implemented
#error max(initializer_list<T> t) is not implemented
 ^
1 error generated.
max_init_list.pass.cpp failed to compile
max_init_list_comp.pass.cpp:19:2: error: #error max(initializer_list<T> t, Compare comp) is not implemented
#error max(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
max_init_list_comp.pass.cpp failed to compile
min_init_list.pass.cpp:19:2: error: #error min(initializer_list<T> t) is not implemented
#error min(initializer_list<T> t) is not implemented
 ^
1 error generated.
min_init_list.pass.cpp failed to compile
min_init_list_comp.pass.cpp:19:2: error: #error min(initializer_list<T> t, Compare comp) is not implemented
#error min(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
min_init_list_comp.pass.cpp failed to compile
minmax.pass.cpp:23:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                      ~~~~~^
In file included from minmax.pass.cpp:16:
In file included from ../../../../include/algorithm:553:
../../../../include/utility:209:40: error: reference to type 'int const' requires an initializer
    _LIBCPP_INLINE_VISIBILITY pair() : first(), second() {}
                                       ^
minmax.pass.cpp:23:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                  ^
minmax.pass.cpp:33:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(x, y, x, y);
    ^
In file included from minmax.pass.cpp:16:
In file included from ../../../../include/algorithm:553:
../../../../include/utility:209:49: error: reference to type 'int const' requires an initializer
    _LIBCPP_INLINE_VISIBILITY pair() : first(), second() {}
                                                ^
3 errors generated.
minmax.pass.cpp failed to compile
minmax_comp.pass.cpp:25:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                      ~~~~~^
In file included from minmax_comp.pass.cpp:17:
In file included from ../../../../include/algorithm:553:
../../../../include/utility:209:40: error: reference to type 'int const' requires an initializer
    _LIBCPP_INLINE_VISIBILITY pair() : first(), second() {}
                                       ^
minmax_comp.pass.cpp:25:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                  ^
minmax_comp.pass.cpp:35:5: note: in instantiation of function template specialization 'test<int, std::greater<int> >' requested here
    test(x, y, std::greater<int>(), x, y);
    ^
In file included from minmax_comp.pass.cpp:17:
In file included from ../../../../include/algorithm:553:
../../../../include/utility:209:49: error: reference to type 'int const' requires an initializer
    _LIBCPP_INLINE_VISIBILITY pair() : first(), second() {}
                                                ^
3 errors generated.
minmax_comp.pass.cpp failed to compile
minmax_init_list.pass.cpp:19:2: error: #error minmax(initializer_list<T> t) is not implemented
#error minmax(initializer_list<T> t) is not implemented
 ^
1 error generated.
minmax_init_list.pass.cpp failed to compile
minmax_init_list_comp.pass.cpp:19:2: error: #error minmax(initializer_list<T> t, Compare comp) is not implemented
#error minmax(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
minmax_init_list_comp.pass.cpp failed to compile
failed 8 tests in /test/algorithms/alg.sorting/alg.min.max
passed 10 tests in /test/algorithms/alg.sorting/alg.min.max
passed 2 tests in /test/algorithms/alg.sorting/alg.nth.element
passed 4 tests in /test/algorithms/alg.sorting/alg.permutation.generators
passed 1 tests in /test/algorithms/alg.sorting/alg.set.operations
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/includes
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.intersection
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.symmetric.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.union
passed 1 tests in /test/algorithms/alg.sorting/alg.sort
passed 4 tests in /test/algorithms/alg.sorting/alg.sort/is.sorted
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort.copy
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/stable.sort
passed 1 tests in /test/algorithms/algorithms.general
not implemented:  /test/atomics
not implemented:  /test/atomics/atomics.fences
not implemented:  /test/atomics/atomics.flag
not implemented:  /test/atomics/atomics.general
not implemented:  /test/atomics/atomics.lockfree
not implemented:  /test/atomics/atomics.order
not implemented:  /test/atomics/atomics.syn
not implemented:  /test/atomics/atomics.types
not implemented:  /test/atomics/atomics.types/atomics.types.address
not implemented:  /test/atomics/atomics.types/atomics.types.generic
not implemented:  /test/atomics/atomics.types/atomics.types.integral
not implemented:  /test/atomics/atomics.types.operations
passed 1 tests in /test/containers
passed 4 tests in /test/containers/associative
passed 2 tests in /test/containers/associative/map
passed 7 tests in /test/containers/associative/map/map.access
passed 17 tests in /test/containers/associative/map/map.cons
passed 12 tests in /test/containers/associative/map/map.modifiers
passed 5 tests in /test/containers/associative/map/map.ops
passed 2 tests in /test/containers/associative/map/map.special
passed 5 tests in /test/containers/associative/multimap
passed 17 tests in /test/containers/associative/multimap/multimap.cons
passed 12 tests in /test/containers/associative/multimap/multimap.modifiers
passed 5 tests in /test/containers/associative/multimap/multimap.ops
passed 2 tests in /test/containers/associative/multimap/multimap.special
passed 22 tests in /test/containers/associative/multiset
passed 17 tests in /test/containers/associative/multiset/multiset.cons
passed 2 tests in /test/containers/associative/multiset/multiset.special
passed 23 tests in /test/containers/associative/set
passed 17 tests in /test/containers/associative/set/set.cons
passed 2 tests in /test/containers/associative/set/set.special
passed 1 tests in /test/containers/container.requirements
passed 1 tests in /test/containers/container.requirements/associative.reqmts
passed 1 tests in /test/containers/container.requirements/associative.reqmts/associative.reqmts.except
passed 1 tests in /test/containers/container.requirements/container.requirements.dataraces
passed 1 tests in /test/containers/container.requirements/container.requirements.general
passed 1 tests in /test/containers/container.requirements/sequence.reqmts
passed 1 tests in /test/containers/container.requirements/unord.req
passed 1 tests in /test/containers/container.requirements/unord.req/unord.req.except
passed 1 tests in /test/containers/containers.general
passed 1 tests in /test/containers/sequences
passed 3 tests in /test/containers/sequences/array
passed 2 tests in /test/containers/sequences/array/array.cons
passed 2 tests in /test/containers/sequences/array/array.data
passed 1 tests in /test/containers/sequences/array/array.fill
passed 1 tests in /test/containers/sequences/array/array.size
passed 1 tests in /test/containers/sequences/array/array.special
passed 1 tests in /test/containers/sequences/array/array.swap
passed 4 tests in /test/containers/sequences/array/array.tuple
passed 1 tests in /test/containers/sequences/array/array.zero
passed 1 tests in /test/containers/sequences/container.adaptors
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue
passed 12 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.cons
passed 6 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.cons.alloc
passed 8 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.members
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.special
passed 1 tests in /test/containers/sequences/container.adaptors/queue
passed 5 tests in /test/containers/sequences/container.adaptors/queue/queue.cons
passed 5 tests in /test/containers/sequences/container.adaptors/queue/queue.cons.alloc
passed 14 tests in /test/containers/sequences/container.adaptors/queue/queue.defn
passed 2 tests in /test/containers/sequences/container.adaptors/queue/queue.ops
passed 1 tests in /test/containers/sequences/container.adaptors/queue/queue.special
passed 1 tests in /test/containers/sequences/container.adaptors/stack
passed 5 tests in /test/containers/sequences/container.adaptors/stack/stack.cons
passed 5 tests in /test/containers/sequences/container.adaptors/stack/stack.cons.alloc
passed 12 tests in /test/containers/sequences/container.adaptors/stack/stack.defn
passed 2 tests in /test/containers/sequences/container.adaptors/stack/stack.ops
passed 1 tests in /test/containers/sequences/container.adaptors/stack/stack.special
passed 2 tests in /test/containers/sequences/deque
passed 4 tests in /test/containers/sequences/deque/deque.capacity
passed 19 tests in /test/containers/sequences/deque/deque.cons
passed 16 tests in /test/containers/sequences/deque/deque.modifiers
passed 5 tests in /test/containers/sequences/deque/deque.special
passed 3 tests in /test/containers/sequences/forwardlist
passed 1 tests in /test/containers/sequences/forwardlist/forwardlist.access
passed 21 tests in /test/containers/sequences/forwardlist/forwardlist.cons
passed 2 tests in /test/containers/sequences/forwardlist/forwardlist.iter
passed 15 tests in /test/containers/sequences/forwardlist/forwardlist.modifiers
passed 12 tests in /test/containers/sequences/forwardlist/forwardlist.ops
passed 4 tests in /test/containers/sequences/forwardlist/forwardlist.spec
passed 2 tests in /test/containers/sequences/list
passed 2 tests in /test/containers/sequences/list/list.capacity
passed 15 tests in /test/containers/sequences/list/list.cons
passed 17 tests in /test/containers/sequences/list/list.modifiers
passed 12 tests in /test/containers/sequences/list/list.ops
passed 1 tests in /test/containers/sequences/list/list.special
passed 2 tests in /test/containers/sequences/vector
passed 6 tests in /test/containers/sequences/vector/vector.capacity
passed 16 tests in /test/containers/sequences/vector/vector.cons
passed 2 tests in /test/containers/sequences/vector/vector.data
passed 11 tests in /test/containers/sequences/vector/vector.modifiers
passed 1 tests in /test/containers/sequences/vector/vector.special
passed 31 tests in /test/containers/sequences/vector.bool
passed 1 tests in /test/containers/unord
passed 20 tests in /test/containers/unord/unord.map
passed 24 tests in /test/containers/unord/unord.map/unord.map.cnstr
passed 2 tests in /test/containers/unord/unord.map/unord.map.elem
passed 1 tests in /test/containers/unord/unord.map/unord.map.swap
passed 12 tests in /test/containers/unord/unord.map/unorder.map.modifiers
passed 21 tests in /test/containers/unord/unord.multimap
passed 24 tests in /test/containers/unord/unord.multimap/unord.multimap.cnstr
passed 12 tests in /test/containers/unord/unord.multimap/unord.multimap.modifiers
passed 1 tests in /test/containers/unord/unord.multimap/unord.multimap.swap
passed 33 tests in /test/containers/unord/unord.multiset
passed 24 tests in /test/containers/unord/unord.multiset/unord.multiset.cnstr
passed 1 tests in /test/containers/unord/unord.multiset/unord.multiset.swap
passed 34 tests in /test/containers/unord/unord.set
passed 24 tests in /test/containers/unord/unord.set/unord.set.cnstr
passed 1 tests in /test/containers/unord/unord.set/unord.set.swap
passed 1 tests in /test/depr
passed 1 tests in /test/depr/depr.auto.ptr
passed 1 tests in /test/depr/depr.auto.ptr/auto.ptr
passed 10 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.cons
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.conv
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.members
inttypes_h.pass.cpp:260:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
inttypes_h.pass.cpp:264:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
inttypes_h.pass.cpp:268:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
inttypes_h.pass.cpp:272:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
inttypes_h.pass.cpp:276:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
inttypes_h.pass.cpp:280:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
inttypes_h.pass.cpp:284:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
inttypes_h.pass.cpp:288:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
inttypes_h.pass.cpp:292:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
inttypes_h.pass.cpp:296:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
inttypes_h.pass.cpp:300:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
inttypes_h.pass.cpp:304:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
inttypes_h.pass.cpp:308:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
inttypes_h.pass.cpp:312:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
inttypes_h.pass.cpp:316:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
inttypes_h.pass.cpp:320:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
inttypes_h.pass.cpp:324:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
inttypes_h.pass.cpp:328:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
inttypes_h.pass.cpp:332:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
inttypes_h.pass.cpp failed to compile
stdio_h.pass.cpp:97:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:97:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:97:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:98:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:98:33: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:98:53: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:100:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:100:33: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:100:49: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                                ^~
stdio_h.pass.cpp:102:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:102:33: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:102:56: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                                       ^~
stdio_h.pass.cpp:103:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:103:33: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:103:53: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:105:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:105:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:105:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:107:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:107:33: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:107:50: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                                 ^~
stdio_h.pass.cpp:109:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:109:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:109:57: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                                        ^~
stdio_h.pass.cpp:110:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:110:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:110:54: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                                     ^~
9 warnings generated.
uchar_h.pass.cpp:12:10: fatal error: 'uchar.h' file not found
#include <uchar.h>
         ^
1 error generated.
uchar_h.pass.cpp failed to compile
failed 2 tests in /test/depr/depr.c.headers
passed 24 tests in /test/depr/depr.c.headers
passed 5 tests in /test/depr/depr.ios.members
passed 1 tests in /test/depr/depr.lib.binders
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.2nd
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.2nd
passed 1 tests in /test/depr/depr.str.strstreams
passed 1 tests in /test/depr/depr.str.strstreams/depr.istrstream
passed 4 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.cons
passed 2 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.ostrstream
passed 2 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.cons
passed 4 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstream
passed 2 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.cons
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.dest
passed 3 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.oper
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstreambuf
passed 8 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.cons
passed 3 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.members
passed 6 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.virtuals
passed 1 tests in /test/diagnostics
passed 1 tests in /test/diagnostics/assertions
passed 1 tests in /test/diagnostics/diagnostics.general
passed 1 tests in /test/diagnostics/errno
passed 1 tests in /test/diagnostics/std.exceptions
passed 1 tests in /test/diagnostics/std.exceptions/domain.error
passed 1 tests in /test/diagnostics/std.exceptions/invalid.argument
passed 1 tests in /test/diagnostics/std.exceptions/length.error
passed 1 tests in /test/diagnostics/std.exceptions/logic.error
passed 1 tests in /test/diagnostics/std.exceptions/out.of.range
passed 1 tests in /test/diagnostics/std.exceptions/overflow.error
passed 1 tests in /test/diagnostics/std.exceptions/range.error
passed 1 tests in /test/diagnostics/std.exceptions/runtime.error
passed 1 tests in /test/diagnostics/std.exceptions/underflow.error
passed 2 tests in /test/diagnostics/syserr
passed 1 tests in /test/diagnostics/syserr/syserr.compare
passed 1 tests in /test/diagnostics/syserr/syserr.errcat
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.derived
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.nonvirtuals
passed 2 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.objects
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.overview
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.virtuals
passed 1 tests in /test/diagnostics/syserr/syserr.errcode
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.modifiers
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.nonmembers
passed 5 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.overview
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.modifiers
passed 2 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.nonmembers
passed 4 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.overview
passed 1 tests in /test/diagnostics/syserr/syserr.hash
passed 1 tests in /test/diagnostics/syserr/syserr.syserr
passed 6 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.members
passed 1 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.overview
passed 1 tests in /test/input.output
passed 1 tests in /test/input.output/file.streams
cinttypes.pass.cpp:260:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
cinttypes.pass.cpp:264:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
cinttypes.pass.cpp:268:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
cinttypes.pass.cpp:272:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
cinttypes.pass.cpp:276:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
cinttypes.pass.cpp:280:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
cinttypes.pass.cpp:284:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
cinttypes.pass.cpp:288:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
cinttypes.pass.cpp:292:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
cinttypes.pass.cpp:296:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
cinttypes.pass.cpp:300:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
cinttypes.pass.cpp:304:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
cinttypes.pass.cpp:308:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
cinttypes.pass.cpp:312:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
cinttypes.pass.cpp:316:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
cinttypes.pass.cpp:320:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
cinttypes.pass.cpp:324:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
cinttypes.pass.cpp:328:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
cinttypes.pass.cpp:332:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
cinttypes.pass.cpp failed to compile
cstdio.pass.cpp:97:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:97:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:97:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:98:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:98:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:98:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:100:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:100:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:100:54: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                                     ^~
cstdio.pass.cpp:102:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:102:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:102:61: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                                            ^~
cstdio.pass.cpp:103:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:103:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:103:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:105:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:105:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:105:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:107:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:107:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:107:55: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                                      ^~
cstdio.pass.cpp:109:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:109:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:109:62: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                                             ^~
cstdio.pass.cpp:110:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:110:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:110:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                                          ^~
9 warnings generated.
failed 1 tests in /test/input.output/file.streams/c.files
passed 3 tests in /test/input.output/file.streams/c.files
passed 1 tests in /test/input.output/file.streams/fstreams
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf
passed 3 tests in /test/input.output/file.streams/fstreams/filebuf.assign
passed 2 tests in /test/input.output/file.streams/fstreams/filebuf.cons
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf.members
Assertion failed: (f.sbumpc() == 0x4E51), function main, file underflow.pass.cpp, line 114.
./testit: line 84: 74388 Abort trap              ./a.out
underflow.pass.cpp failed at run time
failed 1 tests in /test/input.output/file.streams/fstreams/filebuf.virtuals
passed 3 tests in /test/input.output/file.streams/fstreams/filebuf.virtuals
passed 1 tests in /test/input.output/file.streams/fstreams/fstream
passed 3 tests in /test/input.output/file.streams/fstreams/fstream.assign
passed 4 tests in /test/input.output/file.streams/fstreams/fstream.cons
passed 4 tests in /test/input.output/file.streams/fstreams/fstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream
passed 3 tests in /test/input.output/file.streams/fstreams/ifstream.assign
passed 4 tests in /test/input.output/file.streams/fstreams/ifstream.cons
passed 4 tests in /test/input.output/file.streams/fstreams/ifstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream
passed 3 tests in /test/input.output/file.streams/fstreams/ofstream.assign
passed 4 tests in /test/input.output/file.streams/fstreams/ofstream.cons
passed 4 tests in /test/input.output/file.streams/fstreams/ofstream.members
passed 1 tests in /test/input.output/input.output.general
passed 1 tests in /test/input.output/iostream.format
passed 4 tests in /test/input.output/iostream.format/ext.manip
passed 1 tests in /test/input.output/iostream.format/input.streams
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass
passed 2 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.assign
passed 2 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.dest
passed 1 tests in /test/input.output/iostream.format/input.streams/istream
passed 2 tests in /test/input.output/iostream.format/input.streams/istream/istream.assign
passed 2 tests in /test/input.output/iostream.format/input.streams/istream/istream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream_sentry
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted
passed 13 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.arithmetic
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.reqmts
passed 10 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream_extractors
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.manip
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.rvalue
passed 18 tests in /test/input.output/iostream.format/input.streams/istream.unformatted
passed 1 tests in /test/input.output/iostream.format/output.streams
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream
passed 2 tests in /test/input.output/iostream.format/output.streams/ostream.assign
passed 2 tests in /test/input.output/iostream.format/output.streams/ostream.cons
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.reqmts
passed 4 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters
passed 13 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.arithmetic
passed 10 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.character
passed 3 tests in /test/input.output/iostream.format/output.streams/ostream.manip
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.rvalue
passed 3 tests in /test/input.output/iostream.format/output.streams/ostream.seeks
passed 3 tests in /test/input.output/iostream.format/output.streams/ostream.unformatted
passed 2 tests in /test/input.output/iostream.format/output.streams/ostream_sentry
passed 7 tests in /test/input.output/iostream.format/std.manip
passed 2 tests in /test/input.output/iostream.forward
passed 1 tests in /test/input.output/iostream.objects
passed 4 tests in /test/input.output/iostream.objects/narrow.stream.objects
passed 4 tests in /test/input.output/iostream.objects/wide.stream.objects
passed 1 tests in /test/input.output/iostreams.base
passed 1 tests in /test/input.output/iostreams.base/fpos
passed 1 tests in /test/input.output/iostreams.base/fpos/fpos.members
passed 7 tests in /test/input.output/iostreams.base/fpos/fpos.operations
passed 1 tests in /test/input.output/iostreams.base/ios
passed 1 tests in /test/input.output/iostreams.base/ios/basic.ios.cons
passed 13 tests in /test/input.output/iostreams.base/ios/basic.ios.members
passed 11 tests in /test/input.output/iostreams.base/ios/iostate.flags
passed 1 tests in /test/input.output/iostreams.base/ios.base
passed 9 tests in /test/input.output/iostreams.base/ios.base/fmtflags.state
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.callback
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.cons
passed 2 tests in /test/input.output/iostreams.base/ios.base/ios.base.locales
passed 3 tests in /test/input.output/iostreams.base/ios.base/ios.base.storage
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.members.static
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_Init
passed 2 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_failure
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_fmtflags
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_iostate
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_openmode
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios_seekdir
passed 1 tests in /test/input.output/iostreams.base/std.ios.manip
passed 3 tests in /test/input.output/iostreams.base/std.ios.manip/adjustfield.manip
passed 3 tests in /test/input.output/iostreams.base/std.ios.manip/basefield.manip
passed 3 tests in /test/input.output/iostreams.base/std.ios.manip/error.reporting
passed 4 tests in /test/input.output/iostreams.base/std.ios.manip/floatfield.manip
passed 14 tests in /test/input.output/iostreams.base/std.ios.manip/fmtflags.manip
passed 2 tests in /test/input.output/iostreams.base/stream.types
passed 1 tests in /test/input.output/iostreams.requirements
passed 1 tests in /test/input.output/iostreams.requirements/iostream.limits.imbue
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.limits.pos
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.threadsafety
passed 1 tests in /test/input.output/stream.buffers
passed 1 tests in /test/input.output/stream.buffers/streambuf
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.cons
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.buffer
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.locales
passed 5 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.get
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.put
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.assign
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.get.area
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.put.area
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.buffer
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.get
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.locales
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.put
passed 1 tests in /test/input.output/stream.buffers/streambuf.reqts
passed 1 tests in /test/input.output/string.streams
passed 1 tests in /test/input.output/string.streams/istringstream
passed 3 tests in /test/input.output/string.streams/istringstream/istringstream.assign
passed 3 tests in /test/input.output/string.streams/istringstream/istringstream.cons
passed 1 tests in /test/input.output/string.streams/istringstream/istringstream.members
passed 1 tests in /test/input.output/string.streams/ostringstream
passed 3 tests in /test/input.output/string.streams/ostringstream/ostringstream.assign
passed 3 tests in /test/input.output/string.streams/ostringstream/ostringstream.cons
passed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.members
passed 1 tests in /test/input.output/string.streams/stringbuf
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.assign
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.cons
passed 1 tests in /test/input.output/string.streams/stringbuf/stringbuf.members
passed 6 tests in /test/input.output/string.streams/stringbuf/stringbuf.virtuals
passed 1 tests in /test/input.output/string.streams/stringstream
passed 3 tests in /test/input.output/string.streams/stringstream.cons
passed 3 tests in /test/input.output/string.streams/stringstream.cons/stringstream.assign
passed 1 tests in /test/input.output/string.streams/stringstream.members
passed 1 tests in /test/iterators
passed 1 tests in /test/iterators/iterator.primitives
passed 1 tests in /test/iterators/iterator.primitives/iterator.basic
passed 4 tests in /test/iterators/iterator.primitives/iterator.operations
passed 4 tests in /test/iterators/iterator.primitives/iterator.traits
passed 5 tests in /test/iterators/iterator.primitives/std.iterator.tags
passed 1 tests in /test/iterators/iterator.requirements
passed 1 tests in /test/iterators/iterator.requirements/bidirectional.iterators
passed 1 tests in /test/iterators/iterator.requirements/forward.iterators
passed 1 tests in /test/iterators/iterator.requirements/input.iterators
passed 1 tests in /test/iterators/iterator.requirements/iterator.iterators
passed 1 tests in /test/iterators/iterator.requirements/iterator.requirements.general
passed 1 tests in /test/iterators/iterator.requirements/output.iterators
passed 1 tests in /test/iterators/iterator.requirements/random.access.iterators
passed 1 tests in /test/iterators/iterator.synopsis
passed 1 tests in /test/iterators/iterators.general
passed 1 tests in /test/iterators/predef.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iterator
passed 1 tests in /test/iterators/predef.iterators/move.iterators
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops
passed 3 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.nonmember
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-=
passed 6 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.comp
passed 5 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.const
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.conv
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.decr
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.incr
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.index
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.ref
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.requirements
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iterator
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops
passed 5 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.cons
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.conv
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op!=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op++
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op--
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op==
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opdiff
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opindex
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opref
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opsum
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.requirements
types.pass.cpp:52:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((std::is_same<typename R::pointer, It>::value), "");
    ^
In file included from types.pass.cpp:28:
In file included from ../../../../../include/iterator:316:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
types.pass.cpp:58:5: note: in instantiation of function template specialization 'test<bidirectional_iterator<char *> >' requested here
    test<bidirectional_iterator<char*> >();
    ^
In file included from types.pass.cpp:28:
In file included from ../../../../../include/iterator:316:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
types.pass.cpp:52:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((std::is_same<typename R::pointer, It>::value), "");
    ^
In file included from types.pass.cpp:28:
In file included from ../../../../../include/iterator:316:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
types.pass.cpp:59:5: note: in instantiation of function template specialization 'test<random_access_iterator<char *> >' requested here
    test<random_access_iterator<char*> >();
    ^
In file included from types.pass.cpp:28:
In file included from ../../../../../include/iterator:316:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
2 errors generated.
types.pass.cpp failed to compile
failed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iterator
passed 1 tests in /test/iterators/stream.iterators
passed 1 tests in /test/iterators/stream.iterators/istream.iterator
passed 3 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.cons
passed 5 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator
passed 4 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator.cons
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_equal
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_op!=
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_op++
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_op==
passed 3 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_op_astrk
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator_proxy
passed 6 tests in /test/iterators/stream.iterators/iterator.range
passed 1 tests in /test/iterators/stream.iterators/ostream.iterator
passed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.cons.des
passed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/ostreambuf.iterator
passed 2 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.cons
passed 4 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.ops
passed 1 tests in /test/language.support
passed 1 tests in /test/language.support/cstdint
passed 1 tests in /test/language.support/cstdint/cstdint.syn
passed 1 tests in /test/language.support/support.dynamic
passed 1 tests in /test/language.support/support.dynamic/alloc.errors
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/bad.alloc
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.badlength
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.handler
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/set.new.handler
passed 1 tests in /test/language.support/support.dynamic/new.delete
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.array
passed 1 tests in /test/language.support/support.dynamic/new.delete/new.delete.dataraces
passed 2 tests in /test/language.support/support.dynamic/new.delete/new.delete.placement
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.single
passed 1 tests in /test/language.support/support.exception
passed 6 tests in /test/language.support/support.exception/except.nested
passed 1 tests in /test/language.support/support.exception/exception
passed 1 tests in /test/language.support/support.exception/exception.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/set.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate.handler
passed 1 tests in /test/language.support/support.exception/exception.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/bad.exception
passed 1 tests in /test/language.support/support.exception/exception.unexpected/set.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected.handler
passed 4 tests in /test/language.support/support.exception/propagation
passed 1 tests in /test/language.support/support.exception/uncaught
passed 1 tests in /test/language.support/support.general
passed 2 tests in /test/language.support/support.initlist
passed 1 tests in /test/language.support/support.initlist/support.initlist.access
passed 1 tests in /test/language.support/support.initlist/support.initlist.cons
not implemented:  /test/language.support/support.initlist/support.initlist.range
passed 1 tests in /test/language.support/support.limits
passed 4 tests in /test/language.support/support.limits/c.limits
passed 2 tests in /test/language.support/support.limits/limits
passed 1 tests in /test/language.support/support.limits/limits/denorm.style
passed 1 tests in /test/language.support/support.limits/limits/numeric.limits
passed 31 tests in /test/language.support/support.limits/limits/numeric.limits.members
passed 1 tests in /test/language.support/support.limits/limits/numeric.special
passed 1 tests in /test/language.support/support.limits/limits/round.style
passed 1 tests in /test/language.support/support.rtti
passed 1 tests in /test/language.support/support.rtti/bad.cast
passed 1 tests in /test/language.support/support.rtti/bad.typeid
passed 2 tests in /test/language.support/support.rtti/type.info
passed 12 tests in /test/language.support/support.runtime
quick_exit.pass.cpp:19:10: error: no member named 'at_quick_exit' in namespace 'std'
    std::at_quick_exit(f);
    ~~~~~^
quick_exit.pass.cpp:20:5: error: use of undeclared identifier 'quick_exit'
    quick_exit(0);
    ^
2 errors generated.
quick_exit.pass.cpp failed to compile
failed 1 tests in /test/language.support/support.start.term
passed 7 tests in /test/language.support/support.types
passed 1 tests in /test/localization
passed 2 tests in /test/localization/c.locales
passed 1 tests in /test/localization/locale.categories
passed 1 tests in /test/localization/locale.categories/category.collate
passed 2 tests in /test/localization/locale.categories/category.collate/locale.collate
passed 3 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.members
passed 1 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.virtuals
passed 4 tests in /test/localization/locale.categories/category.collate/locale.collate.byname
passed 1 tests in /test/localization/locale.categories/category.ctype
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.dtor
passed 14 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.members
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.statics
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.virtuals
passed 9 tests in /test/localization/locale.categories/category.ctype/locale.codecvt
passed 29 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.virtuals
passed 4 tests in /test/localization/locale.categories/category.ctype/locale.codecvt.byname
passed 2 tests in /test/localization/locale.categories/category.ctype/locale.ctype
passed 12 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.virtuals
passed 13 tests in /test/localization/locale.categories/category.ctype/locale.ctype.byname
passed 1 tests in /test/localization/locale.categories/category.messages
passed 3 tests in /test/localization/locale.categories/category.messages/locale.messages
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.members
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.virtuals
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages.byname
passed 1 tests in /test/localization/locale.categories/category.monetary
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.get
passed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.virtuals
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.put
passed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.virtuals
passed 3 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.virtuals
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct.byname
passed 1 tests in /test/localization/locale.categories/category.numeric
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.nm.put
passed 8 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.virtuals
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.num.get
passed 11 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.virtuals
passed 1 tests in /test/localization/locale.categories/category.time
passed 3 tests in /test/localization/locale.categories/category.time/locale.time.get
passed 12 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.virtuals
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
                          "\x434\x435\x43A\x430\x431\x440\x44F"
                          ^
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:98:27: warning: hex escape sequence out of range
get_one_wide.pass.cpp:100:27: warning: hex escape sequence out of range
                          "\x433"
                          ^
get_one_wide.pass.cpp:146:35: warning: hex escape sequence out of range
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                  ^
get_one_wide.pass.cpp:146:47: warning: hex escape sequence out of range
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                              ^
get_one_wide.pass.cpp:146:59: warning: hex escape sequence out of range
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                                          ^
11 warnings generated.
Assertion failed: (i.base() == in+sizeof(in)/sizeof(in[0])-1), function main, file get_one_wide.pass.cpp, line 105.
./testit: line 84: 79748 Abort trap              ./a.out
get_one_wide.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 13 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.put
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.virtuals
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.put.byname
passed 1 tests in /test/localization/locale.categories/facet.numpunct
passed 2 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct
passed 5 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.members
passed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.virtuals
passed 3 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct.byname
passed 1 tests in /test/localization/locale.categories/facets.examples
not implemented:  /test/localization/locale.stdcvt
passed 1 tests in /test/localization/locale.syn
passed 1 tests in /test/localization/locales
passed 1 tests in /test/localization/locales/locale
Assertion failed: (new_called == 0), function main, file char_pointer.pass.cpp, line 97.
./testit: line 84: 79959 Abort trap              ./a.out
char_pointer.pass.cpp failed at run time
failed 1 tests in /test/localization/locales/locale/locale.cons
passed 8 tests in /test/localization/locales/locale/locale.cons
passed 2 tests in /test/localization/locales/locale/locale.members
passed 2 tests in /test/localization/locales/locale/locale.operators
passed 2 tests in /test/localization/locales/locale/locale.statics
passed 1 tests in /test/localization/locales/locale/locale.types
passed 1 tests in /test/localization/locales/locale/locale.types/locale.category
passed 1 tests in /test/localization/locales/locale/locale.types/locale.facet
passed 1 tests in /test/localization/locales/locale/locale.types/locale.id
passed 1 tests in /test/localization/locales/locale.convenience
passed 11 tests in /test/localization/locales/locale.convenience/classification
passed 1 tests in /test/localization/locales/locale.convenience/conversions
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.buffer
passed 2 tests in /test/localization/locales/locale.convenience/conversions/conversions.character
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.string
passed 2 tests in /test/localization/locales/locale.global.templates
passed 1 tests in /test/localization/localization.general
passed 1 tests in /test/numerics
passed 4 tests in /test/numerics/c.math
passed 1 tests in /test/numerics/cfenv
passed 1 tests in /test/numerics/cfenv/cfenv.syn
passed 2 tests in /test/numerics/complex.number
passed 1 tests in /test/numerics/complex.number/ccmplx
passed 7 tests in /test/numerics/complex.number/cmplx.over
passed 1 tests in /test/numerics/complex.number/complex
passed 10 tests in /test/numerics/complex.number/complex.member.ops
passed 2 tests in /test/numerics/complex.number/complex.members
passed 22 tests in /test/numerics/complex.number/complex.ops
passed 12 tests in /test/numerics/complex.number/complex.special
passed 1 tests in /test/numerics/complex.number/complex.synopsis
passed 19 tests in /test/numerics/complex.number/complex.transcendentals
passed 8 tests in /test/numerics/complex.number/complex.value.ops
passed 1 tests in /test/numerics/numarray
passed 1 tests in /test/numerics/numarray/class.gslice
passed 1 tests in /test/numerics/numarray/class.gslice/gslice.access
passed 2 tests in /test/numerics/numarray/class.gslice/gslice.cons
passed 1 tests in /test/numerics/numarray/class.slice
passed 2 tests in /test/numerics/numarray/class.slice/cons.slice
passed 1 tests in /test/numerics/numarray/class.slice/slice.access
passed 2 tests in /test/numerics/numarray/template.gslice.array
passed 2 tests in /test/numerics/numarray/template.gslice.array/gslice.array.assign
passed 10 tests in /test/numerics/numarray/template.gslice.array/gslice.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.gslice.array/gslice.array.fill
passed 2 tests in /test/numerics/numarray/template.indirect.array
passed 2 tests in /test/numerics/numarray/template.indirect.array/indirect.array.assign
passed 10 tests in /test/numerics/numarray/template.indirect.array/indirect.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.indirect.array/indirect.array.fill
passed 2 tests in /test/numerics/numarray/template.mask.array
passed 2 tests in /test/numerics/numarray/template.mask.array/mask.array.assign
passed 10 tests in /test/numerics/numarray/template.mask.array/mask.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.mask.array/mask.array.fill
passed 2 tests in /test/numerics/numarray/template.slice.array
passed 2 tests in /test/numerics/numarray/template.slice.array/slice.arr.assign
passed 10 tests in /test/numerics/numarray/template.slice.array/slice.arr.comp.assign
passed 1 tests in /test/numerics/numarray/template.slice.array/slice.arr.fill
passed 1 tests in /test/numerics/numarray/template.valarray
passed 2 tests in /test/numerics/numarray/template.valarray/valarray.access
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.assign
passed 20 tests in /test/numerics/numarray/template.valarray/valarray.cassign
passed 11 tests in /test/numerics/numarray/template.valarray/valarray.cons
passed 10 tests in /test/numerics/numarray/template.valarray/valarray.members
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.sub
passed 4 tests in /test/numerics/numarray/template.valarray/valarray.unary
passed 1 tests in /test/numerics/numarray/valarray.nonmembers
passed 30 tests in /test/numerics/numarray/valarray.nonmembers/valarray.binary
passed 24 tests in /test/numerics/numarray/valarray.nonmembers/valarray.comparison
passed 1 tests in /test/numerics/numarray/valarray.nonmembers/valarray.special
passed 20 tests in /test/numerics/numarray/valarray.nonmembers/valarray.transcend
passed 4 tests in /test/numerics/numarray/valarray.range
passed 1 tests in /test/numerics/numarray/valarray.syn
passed 1 tests in /test/numerics/numeric.ops
passed 2 tests in /test/numerics/numeric.ops/accumulate
passed 2 tests in /test/numerics/numeric.ops/adjacent.difference
passed 2 tests in /test/numerics/numeric.ops/inner.product
passed 1 tests in /test/numerics/numeric.ops/numeric.iota
passed 2 tests in /test/numerics/numeric.ops/partial.sum
passed 1 tests in /test/numerics/numeric.requirements
passed 1 tests in /test/numerics/numerics.general
passed 1 tests in /test/numerics/rand
passed 1 tests in /test/numerics/rand/rand.adapt
passed 12 tests in /test/numerics/rand/rand.adapt/rand.adapt.disc
passed 12 tests in /test/numerics/rand/rand.adapt/rand.adapt.ibits
passed 12 tests in /test/numerics/rand/rand.adapt/rand.adapt.shuf
passed 3 tests in /test/numerics/rand/rand.device
passed 1 tests in /test/numerics/rand/rand.dis
passed 1 tests in /test/numerics/rand/rand.dis/rand.dist.bern
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bernoulli
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bin
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.geo
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.negbin
passed 1 tests in /test/numerics/rand/rand.dis/rand.dist.norm
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.cauchy
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.chisq
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.f
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.lognormal
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.normal
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.t
passed 1 tests in /test/numerics/rand/rand.dis/rand.dist.pois
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.exp
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.extreme
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.gamma
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.poisson
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.weibull
passed 1 tests in /test/numerics/rand/rand.dis/rand.dist.samp
passed 24 tests in /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.discrete
passed 24 tests in /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.pconst
passed 24 tests in /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.plinear
passed 1 tests in /test/numerics/rand/rand.dis/rand.dist.uni
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.int
passed 18 tests in /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.real
passed 1 tests in /test/numerics/rand/rand.eng
passed 12 tests in /test/numerics/rand/rand.eng/rand.eng.lcong
passed 12 tests in /test/numerics/rand/rand.eng/rand.eng.mers
passed 12 tests in /test/numerics/rand/rand.eng/rand.eng.sub
passed 10 tests in /test/numerics/rand/rand.predef
passed 1 tests in /test/numerics/rand/rand.req
passed 1 tests in /test/numerics/rand/rand.req/rand.req.adapt
passed 1 tests in /test/numerics/rand/rand.req/rand.req.dst
passed 1 tests in /test/numerics/rand/rand.req/rand.req.eng
passed 1 tests in /test/numerics/rand/rand.req/rand.req.genl
passed 1 tests in /test/numerics/rand/rand.req/rand.req.seedseq
passed 1 tests in /test/numerics/rand/rand.req/rand.req.urng
passed 1 tests in /test/numerics/rand/rand.synopsis
passed 1 tests in /test/numerics/rand/rand.util
passed 1 tests in /test/numerics/rand/rand.util/rand.util.canonical
passed 7 tests in /test/numerics/rand/rand.util/rand.util.seedseq
not implemented:  /test/re
not implemented:  /test/re/re.alg
not implemented:  /test/re/re.alg/re.alg.match
not implemented:  /test/re/re.alg/re.alg.replace
not implemented:  /test/re/re.alg/re.alg.search
not implemented:  /test/re/re.alg/re.except
not implemented:  /test/re/re.badexp
not implemented:  /test/re/re.const
not implemented:  /test/re/re.const/re.err
not implemented:  /test/re/re.const/re.matchflag
not implemented:  /test/re/re.const/re.synopt
not implemented:  /test/re/re.def
not implemented:  /test/re/re.def/defns.regex.collating.element
not implemented:  /test/re/re.def/defns.regex.finite.state.machine
not implemented:  /test/re/re.def/defns.regex.format.specifier
not implemented:  /test/re/re.def/defns.regex.matched
not implemented:  /test/re/re.def/defns.regex.primary.equivalence.class
not implemented:  /test/re/re.def/defns.regex.regular.expression
not implemented:  /test/re/re.def/defns.regex.subexpression
not implemented:  /test/re/re.general
not implemented:  /test/re/re.grammar
not implemented:  /test/re/re.iter
not implemented:  /test/re/re.iter/re.regiter
not implemented:  /test/re/re.iter/re.regiter/re.regiter.cnstr
not implemented:  /test/re/re.iter/re.regiter/re.regiter.comp
not implemented:  /test/re/re.iter/re.regiter/re.regiter.deref
not implemented:  /test/re/re.iter/re.regiter/re.regiter.incr
not implemented:  /test/re/re.iter/re.tokiter
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.cnstr
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.comp
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.deref
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.incr
not implemented:  /test/re/re.regex
not implemented:  /test/re/re.regex/re.regex.assign
not implemented:  /test/re/re.regex/re.regex.const
not implemented:  /test/re/re.regex/re.regex.construct
not implemented:  /test/re/re.regex/re.regex.locale
not implemented:  /test/re/re.regex/re.regex.nonmemb
not implemented:  /test/re/re.regex/re.regex.nonmemb/re.regex.nmswap
not implemented:  /test/re/re.regex/re.regex.operations
not implemented:  /test/re/re.regex/re.regex.swap
not implemented:  /test/re/re.req
not implemented:  /test/re/re.results
not implemented:  /test/re/re.results/re.results.acc
not implemented:  /test/re/re.results/re.results.all
not implemented:  /test/re/re.results/re.results.const
not implemented:  /test/re/re.results/re.results.form
not implemented:  /test/re/re.results/re.results.nonmember
not implemented:  /test/re/re.results/re.results.size
not implemented:  /test/re/re.results/re.results.swap
not implemented:  /test/re/re.submatch
not implemented:  /test/re/re.submatch/re.submatch.members
not implemented:  /test/re/re.submatch/re.submatch.op
not implemented:  /test/re/re.syn
not implemented:  /test/re/re.traits
passed 1 tests in /test/strings
passed 1 tests in /test/strings/basic.string
passed 4 tests in /test/strings/basic.string/string.access
passed 10 tests in /test/strings/basic.string/string.capacity
passed 16 tests in /test/strings/basic.string/string.cons
passed 8 tests in /test/strings/basic.string/string.iterators
passed 1 tests in /test/strings/basic.string/string.modifiers
passed 8 tests in /test/strings/basic.string/string.modifiers/string_append
passed 8 tests in /test/strings/basic.string/string.modifiers/string_assign
passed 1 tests in /test/strings/basic.string/string.modifiers/string_copy
passed 4 tests in /test/strings/basic.string/string.modifiers/string_erase
passed 9 tests in /test/strings/basic.string/string.modifiers/string_insert
passed 4 tests in /test/strings/basic.string/string.modifiers/string_op+=
passed 11 tests in /test/strings/basic.string/string.modifiers/string_replace
passed 1 tests in /test/strings/basic.string/string.modifiers/string_swap
passed 1 tests in /test/strings/basic.string/string.nonmembers
passed 6 tests in /test/strings/basic.string/string.nonmembers/string.io
passed 1 tests in /test/strings/basic.string/string.nonmembers/string.special
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_op!=
passed 5 tests in /test/strings/basic.string/string.nonmembers/string_op+
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_operator==
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_opgt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_opgt=
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_oplt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string_oplt=
passed 1 tests in /test/strings/basic.string/string.ops
passed 3 tests in /test/strings/basic.string/string.ops/string.accessors
passed 6 tests in /test/strings/basic.string/string.ops/string_compare
passed 4 tests in /test/strings/basic.string/string.ops/string_find
passed 4 tests in /test/strings/basic.string/string.ops/string_find.first.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string_find.first.of
passed 4 tests in /test/strings/basic.string/string.ops/string_find.last.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string_find.last.of
passed 4 tests in /test/strings/basic.string/string.ops/string_rfind
passed 1 tests in /test/strings/basic.string/string.ops/string_substr
passed 1 tests in /test/strings/basic.string/string.require
passed 1 tests in /test/strings/basic.string.hash
cuchar.pass.cpp:12:10: fatal error: 'cuchar' file not found
#include <cuchar>
         ^
1 error generated.
cuchar.pass.cpp failed to compile
version_cuchar.pass.cpp:12:10: fatal error: 'cuchar' file not found
#include <cuchar>
         ^
1 error generated.
version_cuchar.pass.cpp failed to compile
failed 2 tests in /test/strings/c.strings
passed 8 tests in /test/strings/c.strings
passed 1 tests in /test/strings/char.traits
passed 1 tests in /test/strings/char.traits/char.traits.require
passed 1 tests in /test/strings/char.traits/char.traits.specializations
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char32_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.wchar.t
passed 1 tests in /test/strings/char.traits/char.traits.typedefs
passed 1 tests in /test/strings/string.classes
not implemented:  /test/strings/string.conversions
not implemented:  /test/strings/strings.general
passed 1 tests in /test/thread
passed 1 tests in /test/thread/futures
not implemented:  /test/thread/futures/futures.async
not implemented:  /test/thread/futures/futures.atomic_future
not implemented:  /test/thread/futures/futures.errors
not implemented:  /test/thread/futures/futures.future_error
passed 3 tests in /test/thread/futures/futures.overview
not implemented:  /test/thread/futures/futures.promise
not implemented:  /test/thread/futures/futures.shared_future
not implemented:  /test/thread/futures/futures.state
not implemented:  /test/thread/futures/futures.tas
not implemented:  /test/thread/futures/futures.tas/futures.taask.nonmembers
not implemented:  /test/thread/futures/futures.tas/futures.task.members
not implemented:  /test/thread/futures/futures.unique_future
notify_all_at_thread_exit.pass.cpp:20:2: error: #error notify_all_at_thread_exit not implemented
#error notify_all_at_thread_exit not implemented
 ^
1 error generated.
notify_all_at_thread_exit.pass.cpp failed to compile
failed 1 tests in /test/thread/thread.condition
passed 2 tests in /test/thread/thread.condition
Assertion failed: (t1 - t0 - Clock::duration(250) < Clock::duration(2)), function f, file wait_until_pred.pass.cpp, line 78.
./testit: line 84: 89106 Abort trap              ./a.out
wait_until_pred.pass.cpp failed at run time
failed 1 tests in /test/thread/thread.condition/thread.condition.condvar
passed 12 tests in /test/thread/thread.condition/thread.condition.condvar
passed 12 tests in /test/thread/thread.condition/thread.condition.condvarany
passed 1 tests in /test/thread/thread.general
passed 1 tests in /test/thread/thread.mutex
passed 1 tests in /test/thread/thread.mutex/thread.lock
passed 6 tests in /test/thread/thread.mutex/thread.lock/thread.lock.guard
passed 1 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique
passed 11 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.cons
passed 5 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.locking
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.mod
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.obs
passed 2 tests in /test/thread/thread.mutex/thread.lock.algorithm
passed 1 tests in /test/thread/thread.mutex/thread.mutex.requirements
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.class
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.recursive
passed 1 tests in /test/thread/thread.mutex/thread.once
passed 1 tests in /test/thread/thread.mutex/thread.once/thread.once.callonce
passed 3 tests in /test/thread/thread.mutex/thread.once/thread.once.onceflag
passed 1 tests in /test/thread/thread.mutex/thread.timedmutex.requirements
Assertion failed: (d < ns(2500000)), function f, file lock.pass.cpp, line 38.
./testit: line 84: 89600 Abort trap              ./a.out
lock.pass.cpp failed at run time
failed 1 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.class
passed 6 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.class
passed 7 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.recursive
passed 1 tests in /test/thread/thread.req
passed 1 tests in /test/thread/thread.req/thread.req.exception
passed 1 tests in /test/thread/thread.req/thread.req.native
passed 1 tests in /test/thread/thread.req/thread.req.paramname
passed 1 tests in /test/thread/thread.req/thread.req.timing
passed 1 tests in /test/thread/thread.threads
passed 1 tests in /test/thread/thread.threads/thread.thread.class
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.algorithm
passed 2 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.assign
passed 4 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.constr
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.destr
passed 7 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.id
passed 6 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.member
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.static
passed 4 tests in /test/thread/thread.threads/thread.thread.this
passed 1 tests in /test/utilities
passed 1 tests in /test/utilities/date.time
passed 1 tests in /test/utilities/function.objects
passed 6 tests in /test/utilities/function.objects/arithmetic.operations
passed 1 tests in /test/utilities/function.objects/base
passed 1 tests in /test/utilities/function.objects/bind
passed 1 tests in /test/utilities/function.objects/bind/func.bind
invoke_int_0.pass.cpp:44:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:45:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:46:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:47:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()), 5);
               ~~~~~^
invoke_int_0.pass.cpp:49:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:50:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:51:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:52:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<int>(A_int_0()), 5);
               ~~~~~^
8 errors generated.
invoke_int_0.pass.cpp failed to compile
invoke_lvalue.pass.cpp:50:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:56:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:64:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:71:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:79:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:86:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:94:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:98:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:105:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:109:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:117:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:121:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:128:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:132:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:165:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:165:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(i) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:166:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, i)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:166:17: note: instantiated from:
    assert(std::bind(f_int_1, i)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:172:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(i) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:172:17: note: instantiated from:
    assert(std::bind(fp, _1)(i) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:173:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, i)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:173:17: note: instantiated from:
    assert(std::bind(fp, i)() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:178:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:178:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(i) == 3);
           ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
invoke_lvalue.pass.cpp failed to compile
invoke_rvalue.pass.cpp:49:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(2);
    ~~~~~^
invoke_rvalue.pass.cpp:54:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, 2)();
    ~~~~~^
invoke_rvalue.pass.cpp:61:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(3);
    ~~~~~^
invoke_rvalue.pass.cpp:67:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, 3)();
    ~~~~~^
invoke_rvalue.pass.cpp:74:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(4);
    ~~~~~^
invoke_rvalue.pass.cpp:80:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, 4)();
    ~~~~~^
invoke_rvalue.pass.cpp:87:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:91:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:97:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:101:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:108:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:112:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:118:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:122:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:154:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(2) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:154:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(2) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:155:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, 2)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:155:17: note: instantiated from:
    assert(std::bind(f_int_1, 2)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:160:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(3) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:160:17: note: instantiated from:
    assert(std::bind(fp, _1)(3) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:161:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, 3)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:161:17: note: instantiated from:
    assert(std::bind(fp, 3)() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:165:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(4) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:165:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(4) == 3);
           ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
invoke_rvalue.pass.cpp failed to compile
invoke_void_0.pass.cpp:50:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f));
         ~~~~~^
invoke_void_0.pass.cpp:51:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f));
         ~~~~~^
invoke_void_0.pass.cpp:52:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:53:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()));
               ~~~~~^
invoke_void_0.pass.cpp:55:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(f));
         ~~~~~^
invoke_void_0.pass.cpp:56:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(&f));
         ~~~~~^
invoke_void_0.pass.cpp:57:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:58:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<void>(A_int_0()));
               ~~~~~^
8 errors generated.
invoke_void_0.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/bind/func.bind/func.bind.bind
is_bind_expression.pass.cpp:27:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C()));
               ~~~~~^
is_bind_expression.pass.cpp:28:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C(), std::placeholders::_2));
               ~~~~~^
is_bind_expression.pass.cpp:29:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind<int>(C()));
               ~~~~~^
3 errors generated.
is_bind_expression.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isbind
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isbind
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.place
passed 3 tests in /test/utilities/function.objects/bitwise.operations
passed 6 tests in /test/utilities/function.objects/comparisons
passed 1 tests in /test/utilities/function.objects/func.def
member_function.pass.cpp:31:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:31:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function.pass.cpp:63:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function.pass.cpp:33:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:33:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<is_base_of<A, typename remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:31:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function.pass.cpp:31:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function.pass.cpp:63:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:33:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function.pass.cpp:33:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function.pass.cpp:63:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function.pass.cpp:43:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:43:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function.pass.cpp:64:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:47:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 2 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:54:11: note: candidate function template not viable: requires 3 arguments, but 2 were provided
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:994:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:994:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:53:17: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
                ^
../../../../include/__functional_03:54:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function.pass.cpp:65:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate template ignored: substitution failure [with _F = char (A::*)(int, double), _A0 = A, _A1 = int, _A2 = int]
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function.pass.cpp:55:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:55:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function.pass.cpp:65:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 3 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:47:11: note: candidate function template not viable: requires 2 arguments, but 3 were provided
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:54:11: note: candidate template ignored: substitution failure [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
2 warnings and 5 errors generated.
member_function.pass.cpp failed to compile
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:105:12: error: functional-style cast from 'char (A::*)() const' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:69:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_const.pass.cpp:31:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:31:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_const.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_const.pass.cpp:33:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:33:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_const.pass.cpp:35:5: warning: comparison between pointer and integer ('typename __apply_cv<A const, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:35:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<is_base_of<A, typename remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:31:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_const.pass.cpp:31:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_const.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:33:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_const.pass.cpp:33:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_const.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A const, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A const *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:35:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A const *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_const.pass.cpp:35:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_const.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:113:12: error: functional-style cast from 'char (A::*)(int) const' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:70:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const.pass.cpp:45:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:45:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const.pass.cpp:70:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:47:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 2 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:54:11: note: candidate function template not viable: requires 3 arguments, but 2 were provided
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:121:12: error: functional-style cast from 'char (A::*)(int, double) const' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:71:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:994:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:994:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:53:17: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
                ^
../../../../include/__functional_03:54:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_const.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate template ignored: substitution failure [with _F = char (A::*)(int, double), _A0 = A, _A1 = int, _A2 = int]
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_const.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 3 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:47:11: note: candidate function template not viable: requires 2 arguments, but 3 were provided
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:54:11: note: candidate template ignored: substitution failure [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_const.pass.cpp failed to compile
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:169:12: error: functional-style cast from 'char (A::*)() const volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:69:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_const_volatile.pass.cpp:31:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:31:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_const_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_const_volatile.pass.cpp:33:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:33:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_const_volatile.pass.cpp:35:5: warning: comparison between pointer and integer ('typename __apply_cv<A const volatile, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:35:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<is_base_of<A, typename remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:31:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_const_volatile.pass.cpp:31:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_const_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:33:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_const_volatile.pass.cpp:33:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_const_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A const volatile, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A const volatile *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:35:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A const volatile *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_const_volatile.pass.cpp:35:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_const_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:177:12: error: functional-style cast from 'char (A::*)(int) const volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:70:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const_volatile.pass.cpp:45:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:45:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const_volatile.pass.cpp:70:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:47:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 2 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:54:11: note: candidate function template not viable: requires 3 arguments, but 2 were provided
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:185:12: error: functional-style cast from 'char (A::*)(int, double) const volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:71:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:994:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:994:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:53:17: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
                ^
../../../../include/__functional_03:54:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_const_volatile.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate template ignored: substitution failure [with _F = char (A::*)(int, double), _A0 = A, _A1 = int, _A2 = int]
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_const_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const_volatile.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 3 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:47:11: note: candidate function template not viable: requires 2 arguments, but 3 were provided
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:54:11: note: candidate template ignored: substitution failure [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_const_volatile.pass.cpp failed to compile
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:137:12: error: functional-style cast from 'char (A::*)() volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:69:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_volatile.pass.cpp:31:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:31:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_volatile.pass.cpp:33:5: warning: comparison between pointer and integer ('typename __apply_cv<A, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:33:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_volatile.pass.cpp:35:5: warning: comparison between pointer and integer ('typename __apply_cv<A volatile, char ()>::type *' (aka 'char (*)()') and 'int')
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:35:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<is_base_of<A, typename remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:31:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_volatile.pass.cpp:31:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:33:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_volatile.pass.cpp:33:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:42:22: error: non-const lvalue reference to type 'typename __apply_cv<A volatile, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'typename enable_if<!is_base_of<A, typename remove_reference<A volatile *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:35:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A volatile *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_volatile.pass.cpp:35:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_volatile.pass.cpp:69:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:145:12: error: functional-style cast from 'char (A::*)(int) volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:70:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_volatile.pass.cpp:45:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:45:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_volatile.pass.cpp:70:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:47:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 2 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:54:11: note: candidate function template not viable: requires 3 arguments, but 2 were provided
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:153:12: error: functional-style cast from 'char (A::*)(int, double) volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:71:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:994:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:994:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:53:17: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
                ^
../../../../include/__functional_03:54:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_volatile.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate template ignored: deduced conflicting types for parameter '_A1' ('double' vs. 'int')
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 4 were provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate function template not viable: requires 1 argument, but 4 were provided
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 4 were provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate template ignored: substitution failure [with _F = char (A::*)(int, double), _A0 = A, _A1 = int, _A2 = int]
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_volatile.pass.cpp:71:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_volatile.pass.cpp:15:
In file included from ../../../../include/functional:887:
../../../../include/__functional_03:40:11: note: candidate function template not viable: requires 1 argument, but 3 were provided
          operator() (_A0& __a0)
          ^
../../../../include/__functional_03:47:11: note: candidate function template not viable: requires 2 arguments, but 3 were provided
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:54:11: note: candidate template ignored: substitution failure [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:33:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_volatile.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.require
passed 1 tests in /test/utilities/function.objects/func.wrap
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall/func.wrap.badcall.const
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.alg
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.cap
alloc.pass.cpp:21:2: error: #error template<class A> function(allocator_arg_t, const A&); not implemented
#error template<class A> function(allocator_arg_t, const A&); not implemented
 ^
1 error generated.
alloc.pass.cpp failed to compile
alloc_F.pass.cpp:21:2: error: #error template<class F, class A> function(allocator_arg_t, const A&, F); not implemented
#error template<class F, class A> function(allocator_arg_t, const A&, F); not implemented
 ^
1 error generated.
alloc_F.pass.cpp failed to compile
alloc_function.pass.cpp:21:2: error: #error template<class A> function(allocator_arg_t, const A&, const function&); not implemented
#error template<class A> function(allocator_arg_t, const A&, const function&); not implemented
 ^
1 error generated.
alloc_function.pass.cpp failed to compile
alloc_nullptr.pass.cpp:21:2: error: #error template<class A> function(allocator_arg_t, const A&, nullptr_t); not implemented
#error template<class A> function(allocator_arg_t, const A&, nullptr_t); not implemented
 ^
1 error generated.
alloc_nullptr.pass.cpp failed to compile
alloc_rfunction.pass.cpp:21:2: error: #error template<class A> function(allocator_arg_t, const A&, function&&); not implemented
#error template<class A> function(allocator_arg_t, const A&, function&&); not implemented
 ^
1 error generated.
alloc_rfunction.pass.cpp failed to compile
failed 5 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.con
passed 7 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.con
In file included from invoke_int_0.pass.cpp:16:
In file included from ../../../../../../include/functional:887:
../../../../../../include/__functional_03:359:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:703:13: note: in instantiation of member function 'std::__function::__func<int (*)(), std::allocator<int (*)()>, int ()>::operator()' requested here
            ::new (__f_) _FF(__f);
            ^
In file included from invoke_int_0.pass.cpp:16:
In file included from ../../../../../../include/functional:492:
In file included from ../../../../../../include/memory:199:
In file included from ../../../../../../include/__functional_base:52:
../../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke_int_0.pass.cpp:16:
In file included from ../../../../../../include/functional:887:
../../../../../../include/__functional_03:359:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:703:13: note: in instantiation of member function 'std::__function::__func<A_int_0, std::allocator<A_int_0>, int ()>::operator()' requested here
            ::new (__f_) _FF(__f);
            ^
In file included from invoke_int_0.pass.cpp:16:
In file included from ../../../../../../include/functional:492:
In file included from ../../../../../../include/memory:199:
In file included from ../../../../../../include/__functional_base:52:
../../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
invoke_int_0.pass.cpp failed to compile
In file included from invoke_void_0.pass.cpp:16:
In file included from ../../../../../../include/functional:887:
../../../../../../include/__functional_03:359:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:703:13: note: in instantiation of member function 'std::__function::__func<void (*)(), std::allocator<void (*)()>, void ()>::operator()' requested here
            ::new (__f_) _FF(__f);
            ^
In file included from invoke_void_0.pass.cpp:16:
In file included from ../../../../../../include/functional:492:
In file included from ../../../../../../include/memory:199:
In file included from ../../../../../../include/__functional_base:52:
../../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:820:1: note: candidate template ignored: substitution failure [with _R = void]
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = void]
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke_void_0.pass.cpp:16:
In file included from ../../../../../../include/functional:887:
../../../../../../include/__functional_03:359:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:703:13: note: in instantiation of member function 'std::__function::__func<A_void_0, std::allocator<A_void_0>, void ()>::operator()' requested here
            ::new (__f_) _FF(__f);
            ^
In file included from invoke_void_0.pass.cpp:16:
In file included from ../../../../../../include/functional:492:
In file included from ../../../../../../include/memory:199:
In file included from ../../../../../../include/__functional_base:52:
../../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:820:1: note: candidate template ignored: substitution failure [with _R = void]
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = void]
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
invoke_void_0.pass.cpp failed to compile
failed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.inv
passed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.inv
assign_F_alloc.pass.cpp:21:2: error: #error template<class F, class A> void assign(F&&, const A&); not implemented
#error template<class F, class A> void assign(F&&, const A&); not implemented
 ^
1 error generated.
assign_F_alloc.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.mod
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.mod
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.nullptr
passed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.targ
passed 4 tests in /test/utilities/function.objects/function.pointer.adaptors
passed 3 tests in /test/utilities/function.objects/logical.operations
passed 16 tests in /test/utilities/function.objects/member.pointer.adaptors
passed 4 tests in /test/utilities/function.objects/negators
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:58:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
    ^
binary.pass.cpp:58:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
                   ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:58:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
    ^
binary.pass.cpp:58:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
                   ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<float (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<float (*())(int)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:70:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:70:21: note: instantiated from:
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
                    ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:70:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:70:21: note: instantiated from:
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
                    ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 2, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<float (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<float (*())(int, int)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
                   ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
                   ^
In file included from binary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
binary.pass.cpp failed to compile
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: type 'C' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<C (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<C ()>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
type.pass.cpp:23:5: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    static_assert((std::is_same<std::reference_wrapper<C>::type,
    ^
type.pass.cpp:23:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<C>::type,
                                ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
type.pass.cpp:23:5: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    static_assert((std::is_same<std::reference_wrapper<C>::type,
    ^
type.pass.cpp:23:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<C>::type,
                                ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<int *(*())(double *), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<int *(*())(double *)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
             ^
type.pass.cpp:31:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
    ^
type.pass.cpp:31:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
                                ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
             ^
type.pass.cpp:31:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
    ^
type.pass.cpp:31:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
                                ^
In file included from type.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
4 errors generated.
type.pass.cpp failed to compile
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:58:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, int>,
    ^
unary.pass.cpp:58:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, int>,
                   ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:58:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, int>,
    ^
unary.pass.cpp:58:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, int>,
                   ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<float (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<float (*())(int)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:68:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:68:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, float>,
                   ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:68:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:68:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, float>,
                   ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 2, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<float (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<float (*())(int, int)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:70:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((!std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:70:21: note: instantiated from:
    static_assert((!std::is_base_of<std::unary_function<int, float>,
                    ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:642:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:656:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:660:7: note: in instantiation of template class 'std::__libcpp_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __libcpp_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:70:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((!std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:70:21: note: instantiated from:
    static_assert((!std::is_base_of<std::unary_function<int, float>,
                    ^
In file included from unary.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
unary.pass.cpp failed to compile
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<int *(*())(double *), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<int *(*())(double *)>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:71:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
    ^
weak_result.pass.cpp:71:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
                                ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:71:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
    ^
weak_result.pass.cpp:71:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
                                ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:52:66: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:52:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:80:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<functor4> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
    ^
weak_result.pass.cpp:80:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
                   ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:52:66: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:52:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:80:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<functor4> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
    ^
weak_result.pass.cpp:80:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
                   ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:489:
../../../../include/type_traits:1309:13: error: type 'C' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<C (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<C ()>' requested here
typename result_of<_F()>::type
         ^
../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:52:66: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:52:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:81:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<C> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
    ^
weak_result.pass.cpp:81:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
                   ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
weak_result.pass.cpp:52:66: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:52:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:81:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<C> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
    ^
weak_result.pass.cpp:81:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
                   ^
In file included from weak_result.pass.cpp:16:
In file included from ../../../../include/functional:492:
In file included from ../../../../include/memory:199:
In file included from ../../../../include/__functional_base:52:
../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
weak_result.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/refwrap
In file included from conversion.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
conversion.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
conversion.pass.cpp:43:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from conversion.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
conversion.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
conversion.pass.cpp:45:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from conversion.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
conversion.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.access
In file included from copy_assign.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
copy_assign.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_assign.pass.cpp:55:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from copy_assign.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
copy_assign.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_assign.pass.cpp:57:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from copy_assign.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
copy_assign.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.assign
In file included from copy_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
copy_ctor.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_ctor.pass.cpp:43:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from copy_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
copy_ctor.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_ctor.pass.cpp:45:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from copy_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
copy_ctor.pass.cpp failed to compile
In file included from type_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
type_ctor.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
type_ctor.pass.cpp:42:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from type_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
type_ctor.pass.cpp:28:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
type_ctor.pass.cpp:44:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from type_ctor.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
type_ctor.pass.cpp failed to compile
failed 2 tests in /test/utilities/function.objects/refwrap/refwrap.const
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.const
In file included from cref_1.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
cref_1.pass.cpp:22:43: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<const int> r = std::cref(i);
                                          ^
In file included from cref_1.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
cref_1.pass.cpp failed to compile
In file included from cref_2.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
cref_2.pass.cpp:22:44: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<const int> r1 = std::cref(i);
                                           ^
In file included from cref_2.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
cref_2.pass.cpp failed to compile
In file included from ref_1.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
ref_1.pass.cpp:22:37: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<int> r = std::ref(i);
                                    ^
In file included from ref_1.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
ref_1.pass.cpp failed to compile
In file included from ref_2.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
ref_2.pass.cpp:22:38: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<int> r1 = std::ref(i);
                                     ^
In file included from ref_2.pass.cpp:16:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
ref_2.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<void (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<void (*())(int)>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = void (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<void (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:57:43: note: in instantiation of template class 'std::reference_wrapper<void (*)(int)>' requested here
    std::reference_wrapper<void (*)(int)> r1(fp);
                                          ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<void (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:57:43: note: in instantiation of template class 'std::reference_wrapper<void (*)(int)>' requested here
    std::reference_wrapper<void (*)(int)> r1(fp);
                                          ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = void (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: no matching function for call to object of type 'A_void_1'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<A_void_1 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<A_void_1 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_void_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_void_1 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:66:38: note: in instantiation of template class 'std::reference_wrapper<A_void_1>' requested here
    std::reference_wrapper<A_void_1> r1(a0);
                                     ^
invoke.pass.cpp:33:10: note: candidate function not viable: requires 1 argument, but 0 were provided
    void operator()(int i)
         ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_void_1 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:66:38: note: in instantiation of template class 'std::reference_wrapper<A_void_1>' requested here
    std::reference_wrapper<A_void_1> r1(a0);
                                     ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = A_void_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 1, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<int (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<int (*())(int)>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:132:42: note: in instantiation of template class 'std::reference_wrapper<int (*)(int)>' requested here
    std::reference_wrapper<int (*)(int)> r1(fp);
                                         ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:132:42: note: in instantiation of template class 'std::reference_wrapper<int (*)(int)>' requested here
    std::reference_wrapper<int (*)(int)> r1(fp);
                                         ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: no matching function for call to object of type 'A_int_1'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<A_int_1 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<A_int_1 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_int_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_int_1 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:139:37: note: in instantiation of template class 'std::reference_wrapper<A_int_1>' requested here
    std::reference_wrapper<A_int_1> r1(a0);
                                    ^
invoke.pass.cpp:110:9: note: candidate function not viable: requires 1 argument, but 0 were provided
    int operator()(int i)
        ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_int_1 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:139:37: note: in instantiation of template class 'std::reference_wrapper<A_int_1>' requested here
    std::reference_wrapper<A_int_1> r1(a0);
                                    ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = A_int_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
invoke.pass.cpp:167:11: error: expression is not assignable
    r1(a) = 6;
    ~~~~~ ^
invoke.pass.cpp:171:12: error: expression is not assignable
    r1(ap) = 7;
    ~~~~~~ ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 2, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<void (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<void (*())(int, int)>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = void (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<void (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:210:48: note: in instantiation of template class 'std::reference_wrapper<void (*)(int, int)>' requested here
    std::reference_wrapper<void (*)(int, int)> r1(fp);
                                               ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<void (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:210:48: note: in instantiation of template class 'std::reference_wrapper<void (*)(int, int)>' requested here
    std::reference_wrapper<void (*)(int, int)> r1(fp);
                                               ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = void (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: no matching function for call to object of type 'A_void_2'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<A_void_2 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<A_void_2 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_void_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_void_2 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:220:38: note: in instantiation of template class 'std::reference_wrapper<A_void_2>' requested here
    std::reference_wrapper<A_void_2> r1(a0);
                                     ^
invoke.pass.cpp:185:10: note: candidate function not viable: requires 2 arguments, but 0 were provided
    void operator()(int i, int j)
         ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_void_2 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:220:38: note: in instantiation of template class 'std::reference_wrapper<A_void_2>' requested here
    std::reference_wrapper<A_void_2> r1(a0);
                                     ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = A_void_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: too few arguments to function call, expected 2, have 0
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<int (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<int (*())(int, int)>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:288:47: note: in instantiation of template class 'std::reference_wrapper<int (*)(int, int)>' requested here
    std::reference_wrapper<int (*)(int, int)> r1(fp);
                                              ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<int (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:288:47: note: in instantiation of template class 'std::reference_wrapper<int (*)(int, int)>' requested here
    std::reference_wrapper<int (*)(int, int)> r1(fp);
                                              ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = int (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:489:
../../../../../include/type_traits:1309:13: error: no matching function for call to object of type 'A_int_2'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1309:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1335:7: note: in instantiation of template class 'std::__result_of<A_int_2 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:877:10: note: in instantiation of template class 'std::result_of<A_int_2 ()>' requested here
typename result_of<_F()>::type
         ^
../../../../../include/__functional_base_03:878:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_int_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_int_2 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:296:37: note: in instantiation of template class 'std::reference_wrapper<A_int_2>' requested here
    std::reference_wrapper<A_int_2> r1(a0);
                                    ^
invoke.pass.cpp:266:9: note: candidate function not viable: requires 2 arguments, but 0 were provided
    int operator()(int i, int j)
        ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:963:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:963:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1019:14: note: in instantiation of template class 'std::__invoke_return<A_int_2 &, 0>' requested here
    typename __invoke_return<type&>::type
             ^
invoke.pass.cpp:296:37: note: in instantiation of template class 'std::reference_wrapper<A_int_2>' requested here
    std::reference_wrapper<A_int_2> r1(a0);
                                    ^
In file included from invoke.pass.cpp:19:
In file included from ../../../../../include/functional:492:
In file included from ../../../../../include/memory:199:
In file included from ../../../../../include/__functional_base:52:
../../../../../include/__functional_base_03:424:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:436:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:448:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:460:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:472:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:484:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:496:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:508:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:520:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:532:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:544:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:556:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:568:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:580:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:592:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:604:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:618:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:630:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:642:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:654:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:666:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:678:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:690:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:702:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:714:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:726:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:738:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:750:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:762:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:774:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:786:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:798:1: note: candidate function template not viable: requires 5 arguments, but 1 was provided
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:812:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:820:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:856:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:878:1: note: candidate template ignored: substitution failure [with _F = A_int_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:886:1: note: candidate function template not viable: requires 2 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:894:1: note: candidate function template not viable: requires 3 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:902:1: note: candidate function template not viable: requires 4 arguments, but 1 was provided
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
18 errors generated.
invoke.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 3 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 3 tests in /test/utilities/function.objects/unord.hash
passed 1 tests in /test/utilities/memory
passed 1 tests in /test/utilities/memory/allocator.adaptor
passed 5 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.cnstr
passed 9 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.members
passed 4 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.types
passed 1 tests in /test/utilities/memory/allocator.tag
passed 3 tests in /test/utilities/memory/allocator.traits
passed 7 tests in /test/utilities/memory/allocator.traits/allocator.traits.members
passed 10 tests in /test/utilities/memory/allocator.traits/allocator.traits.types
passed 1 tests in /test/utilities/memory/allocator.uses
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.construction
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.trait
passed 1 tests in /test/utilities/memory/c.malloc
passed 2 tests in /test/utilities/memory/default.allocator
passed 1 tests in /test/utilities/memory/default.allocator/allocator.globals
passed 4 tests in /test/utilities/memory/default.allocator/allocator.members
passed 5 tests in /test/utilities/memory/pointer.traits
passed 1 tests in /test/utilities/memory/pointer.traits/pointer.traits.functions
passed 3 tests in /test/utilities/memory/pointer.traits/pointer.traits.types
passed 1 tests in /test/utilities/memory/ptr.align
passed 1 tests in /test/utilities/memory/specialized.algorithms
passed 1 tests in /test/utilities/memory/specialized.algorithms/specialized.addressof
passed 2 tests in /test/utilities/memory/specialized.algorithms/uninitialized.copy
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill.n
passed 1 tests in /test/utilities/memory/storage.iterator
passed 1 tests in /test/utilities/memory/temporary.buffer
passed 1 tests in /test/utilities/memory/unique.ptr
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt1
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.general
move01.pass.cpp:49:54: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s1(new A[4], Deleter<A[]>(5));
                                                     ^~~~~~~~~~~~~~~
In file included from move01.pass.cpp:22:
./../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
1 error generated.
move01.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
passed 17 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
pointer_deleter04.fail.cpp should not compile
move01.pass.cpp:62:53: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s(new A[3], Deleter<A[]>(5));
                                                    ^~~~~~~~~~~~~~~
In file included from move01.pass.cpp:22:
./../../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
1 error generated.
move01.pass.cpp failed to compile
pointer_deleter01.pass.cpp:38:46: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s(p, Deleter<A[]>());
                                             ^~~~~~~~~~~~~~
In file included from pointer_deleter01.pass.cpp:21:
./../../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
1 error generated.
pointer_deleter01.pass.cpp failed to compile
failed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
passed 39 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
swap.pass.cpp:41:48: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s1(p1, Deleter<A[]>(1));
                                               ^~~~~~~~~~~~~~~
In file included from swap.pass.cpp:19:
./../../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
swap.pass.cpp:43:48: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s2(p2, Deleter<A[]>(2));
                                               ^~~~~~~~~~~~~~~
In file included from swap.pass.cpp:19:
./../../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
2 errors generated.
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.observers
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single
move_convert13.fail.cpp should not compile
In file included from move_convert01.pass.cpp:16:
In file included from ../../../../../../include/memory:191:
../../../../../../include/type_traits:1199:12: error: non-const lvalue reference to type 'std::default_delete<A>' cannot bind to a value of unrelated type 'std::default_delete<B>'
    return __t;
           ^~~
In file included from move_convert01.pass.cpp:16:
../../../../../../include/memory:2180:27: note: in instantiation of function template specialization 'std::forward<std::default_delete<A>, std::default_delete<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert01.pass.cpp:16:
In file included from ../../../../../../include/memory:190:
../../../../../../include/__config:104:14: note: instantiated from:
#define _STD std
             ^
move_convert01.pass.cpp:47:8: note: in instantiation of function template specialization 'std::unique_ptr<A, std::default_delete<A> >::operator=<B, std::default_delete<B> >' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert01.pass.cpp failed to compile
In file included from move_convert02.pass.cpp:16:
In file included from ../../../../../../include/memory:191:
../../../../../../include/type_traits:1223:16: error: functional-style cast from 'Deleter<B>' to '__rv<Deleter<A> >' is not allowed
    return _Tp(__rv<_Tp>(__t));
               ^~~~~~~~~~
In file included from move_convert02.pass.cpp:16:
../../../../../../include/memory:2180:27: note: in instantiation of function template specialization 'std::forward<Deleter<A>, Deleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert02.pass.cpp:16:
In file included from ../../../../../../include/memory:190:
../../../../../../include/__config:104:14: note: instantiated from:
#define _STD std
             ^
move_convert02.pass.cpp:49:8: note: in instantiation of function template specialization 'std::unique_ptr<A, Deleter<A> >::operator=<B, Deleter<B> >' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert02.pass.cpp failed to compile
In file included from move_convert03.pass.cpp:18:
In file included from ../../../../../../include/memory:191:
../../../../../../include/type_traits:1199:12: error: non-const lvalue reference to type 'CDeleter<A>' cannot bind to a value of unrelated type 'CDeleter<B>'
    return __t;
           ^~~
In file included from move_convert03.pass.cpp:18:
../../../../../../include/memory:2180:27: note: in instantiation of function template specialization 'std::forward<CDeleter<A> &, CDeleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert03.pass.cpp:18:
In file included from ../../../../../../include/memory:190:
../../../../../../include/__config:104:14: note: instantiated from:
#define _STD std
             ^
move_convert03.pass.cpp:52:8: note: in instantiation of function template specialization 'std::unique_ptr<A, CDeleter<A> &>::operator=<B, CDeleter<B> &>' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert03.pass.cpp failed to compile
failed 4 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
passed 13 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
pointer_deleter04.fail.cpp should not compile
move_convert01.pass.cpp:49:24: error: no matching constructor for initialization of 'std::unique_ptr<A>'
    std::unique_ptr<A> s2(std::move(s));
                       ^  ~~~~~~~~~~~~
In file included from move_convert01.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2087:40: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'pointer' (aka 'A *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                       ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2095:44: note: candidate template ignored: failed template argument deduction
        _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                           ^
../../../../../../include/memory:2075:31: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr()
                              ^
../../../../../../include/memory:2184:31: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                              ^
1 error generated.
move_convert01.pass.cpp failed to compile
move_convert02.pass.cpp:51:37: error: no matching constructor for initialization of 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2(std::move(s));
                                    ^  ~~~~~~~~~~~~
In file included from move_convert02.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2087:40: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'pointer' (aka 'A *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                       ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2095:44: note: candidate template ignored: failed template argument deduction
        _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                           ^
../../../../../../include/memory:2075:31: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr()
                              ^
../../../../../../include/memory:2184:31: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                              ^
1 error generated.
move_convert02.pass.cpp failed to compile
move_convert03.pass.cpp:67:38: error: no matching constructor for initialization of 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2(std::move(s));
                                     ^  ~~~~~~~~~~~~
In file included from move_convert03.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2087:40: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'pointer' (aka 'A *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                       ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2095:44: note: candidate template ignored: failed template argument deduction
        _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                           ^
../../../../../../include/memory:2075:31: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr()
                              ^
../../../../../../include/memory:2184:31: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                              ^
1 error generated.
move_convert03.pass.cpp failed to compile
move_convert04.pass.cpp:49:24: error: no viable conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A>'
    std::unique_ptr<A> s2 = std::move(s);
                       ^    ~~~~~~~~~~~~
In file included from move_convert04.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2168:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()
                              ^
../../../../../../include/memory:2212:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                              ^
1 error generated.
move_convert04.pass.cpp failed to compile
move_convert05.pass.cpp:51:37: error: no viable conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2 = std::move(s);
                                    ^    ~~~~~~~~~~~~
In file included from move_convert05.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2168:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()
                              ^
../../../../../../include/memory:2212:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                              ^
1 error generated.
move_convert05.pass.cpp failed to compile
move_convert06.pass.cpp:67:38: error: no viable conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert06.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2168:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()
                              ^
../../../../../../include/memory:2212:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                              ^
1 error generated.
move_convert06.pass.cpp failed to compile
move_convert07.pass.cpp:52:38: error: no viable conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> >'
    std::unique_ptr<A, CDeleter<A> > s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert07.pass.cpp:16:
../../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2064:9: note: candidate constructor [with $0 = B, $1 = CDeleter<B> &] not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'unique_ptr<B, CDeleter<B> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'typename enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to '__rv<std::unique_ptr<A, CDeleter<A> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../../include/memory:2168:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()
                              ^
../../../../../../include/memory:2212:31: note: candidate function
    _LIBCPP_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                              ^
1 error generated.
move_convert07.pass.cpp failed to compile
failed 8 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 40 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.dtor
passed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.observers
swap.pass.cpp:62:48: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s1(p1, Deleter<A[]>(1));
                                               ^~~~~~~~~~~~~~~
In file included from swap.pass.cpp:19:
./../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
swap.pass.cpp:64:48: error: no viable constructor copying parameter of type 'Deleter<A []>'
    std::unique_ptr<A[], Deleter<A[]> > s2(p2, Deleter<A[]>(2));
                                               ^~~~~~~~~~~~~~~
In file included from swap.pass.cpp:19:
./../deleter.h:91:5: note: candidate constructor not viable: no known conversion from 'Deleter<A []>' to 'Deleter<A []> &' for 1st argument
    Deleter(Deleter&);
    ^
2 errors generated.
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 2 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 3 tests in /test/utilities/memory/util.dynamic.safety
passed 1 tests in /test/utilities/memory/util.smartptr
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.enab
not implemented:  /test/utilities/memory/util.smartptr/util.smartptr.hash
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.getdeleter
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_Y_rv.pass.cpp, line 53.
./testit: line 84: 92787 Abort trap              ./a.out
shared_ptr_Y_rv.pass.cpp failed at run time
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_rv.pass.cpp, line 53.
./testit: line 84: 92793 Abort trap              ./a.out
shared_ptr_rv.pass.cpp failed at run time
clang: error: clang frontend command failed due to signal 11 (use -v to see invocation)
unique_ptr_Y.pass.cpp failed to compile
failed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cast
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cmp
clang: error: clang frontend command failed due to signal 11 (use -v to see invocation)
unique_ptr.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 19 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.dest
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.io
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.mod
passed 6 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.spec
not implemented:  /test/utilities/memory/util.smartptr/util.smartptr.shared.atomic
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.ownerless
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.assign
passed 4 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.const
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.dest
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.mod
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.spec
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weakptr
passed 1 tests in /test/utilities/meta
passed 1 tests in /test/utilities/meta/meta.hel
is_convertible.pass.cpp:97:5: warning: qualifier on function type 'Function' (aka 'void ()') has unspecified behavior
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_convertible.pass.cpp:97:52: note: instantiated from:
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
                                                   ^~~~~~~~~~~~~~
is_convertible.pass.cpp:275:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((!std::is_convertible<char, char&>::value), "");
    ^
In file included from is_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
1 warning and 1 error generated.
is_convertible.pass.cpp failed to compile
is_explicitly_convertible.pass.cpp:22:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:22:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:22:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:22:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:23:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:23:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:23:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:23:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:24:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:24:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:24:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:24:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:25:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:25:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:25:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:25:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:27:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:27:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:27:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:27:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:28:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:28:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:28:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:28:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:14:
In file included from ../../../../include/type_traits:136:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:30:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:30:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
                    ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
is_explicitly_convertible.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.rel
passed 2 tests in /test/utilities/meta/meta.rel
passed 1 tests in /test/utilities/meta/meta.rqmts
passed 1 tests in /test/utilities/meta/meta.trans
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.arr
passed 6 tests in /test/utilities/meta/meta.trans/meta.trans.cv
aligned_storage.pass.cpp:25:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:31:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 12, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 8, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:40:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:41:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:46:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:50:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:51:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:55:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:56:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 64, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:60:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:61:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:70:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:75:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:76:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 4, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:80:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
aligned_storage.pass.cpp failed to compile
underlying_type.pass.cpp:18:2: error: #error underlying_type is not implemented
#error underlying_type is not implemented
 ^
1 error generated.
underlying_type.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 6 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.ptr
passed 3 tests in /test/utilities/meta/meta.trans/meta.trans.ref
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.sign
passed 1 tests in /test/utilities/meta/meta.type.synop
passed 1 tests in /test/utilities/meta/meta.unary
union.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:37:5: note: in instantiation of function template specialization 'test_union_imp<Union>' requested here
    test_union_imp<T>();
    ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:38:5: note: in instantiation of function template specialization 'test_union_imp<Union const>' requested here
    test_union_imp<const T>();
    ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:39:5: note: in instantiation of function template specialization 'test_union_imp<Union volatile>' requested here
    test_union_imp<volatile T>();
    ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:40:5: note: in instantiation of function template specialization 'test_union_imp<Union const volatile>' requested here
    test_union_imp<const volatile T>();
    ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
8 errors generated.
union.pass.cpp failed to compile
failed 1 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 12 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 13 tests in /test/utilities/meta/meta.unary/meta.unary.comp
has_copy_assign.pass.cpp:18:2: error: #error has_copy_assign not implemented
#error has_copy_assign not implemented
 ^
1 error generated.
has_copy_assign.pass.cpp failed to compile
has_copy_constructor.pass.cpp:18:2: error: #error has_copy_constructor not implemented
#error has_copy_constructor not implemented
 ^
1 error generated.
has_copy_constructor.pass.cpp failed to compile
has_default_constructor.pass.cpp:18:2: error: #error has_default_constructor not implemented
#error has_default_constructor not implemented
 ^
1 error generated.
has_default_constructor.pass.cpp failed to compile
has_move_assign.pass.cpp:18:2: error: #error has_move_assign not implemented
#error has_move_assign not implemented
 ^
1 error generated.
has_move_assign.pass.cpp failed to compile
has_move_constructor.pass.cpp:18:2: error: #error has_move_constructor not implemented
#error has_move_constructor not implemented
 ^
1 error generated.
has_move_constructor.pass.cpp failed to compile
has_nothrow_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Union>' requested here
    test_has_nothrow_assign<Union>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Abstract>' requested here
    test_has_nothrow_assign<Abstract>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Empty>' requested here
    test_has_nothrow_assign<Empty>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<NotEmpty>' requested here
    test_has_nothrow_assign<NotEmpty>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<bit_zero>' requested here
    test_has_nothrow_assign<bit_zero>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
has_nothrow_copy_assign.pass.cpp failed to compile
has_nothrow_copy_constructor.pass.cpp:28:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:64:5: note: in instantiation of function template specialization 'test_has_not_nothrow_copy_constructor<int &>' requested here
    test_has_not_nothrow_copy_constructor<int&>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:31:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Union>' requested here
    test_has_nothrow_copy_constructor<Union>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Abstract>' requested here
    test_has_nothrow_copy_constructor<Abstract>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Empty>' requested here
    test_has_nothrow_copy_constructor<Empty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<NotEmpty>' requested here
    test_has_nothrow_copy_constructor<NotEmpty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
has_nothrow_copy_constructor.pass.cpp failed to compile
has_nothrow_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Union>' requested here
    test_has_nothrow_default_constructor<Union>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Abstract>' requested here
    test_has_nothrow_default_constructor<Abstract>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Empty>' requested here
    test_has_nothrow_default_constructor<Empty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<NotEmpty>' requested here
    test_has_nothrow_default_constructor<NotEmpty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<bit_zero>' requested here
    test_has_nothrow_default_constructor<bit_zero>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
has_nothrow_default_constructor.pass.cpp failed to compile
has_nothrow_move_assign.pass.cpp:18:2: error: #error has_nothrow_move_assign not implemented
#error has_nothrow_move_assign not implemented
 ^
1 error generated.
has_nothrow_move_assign.pass.cpp failed to compile
has_nothrow_move_constructor.pass.cpp:18:2: error: #error has_nothrow_move_constructor not implemented
#error has_nothrow_move_constructor not implemented
 ^
1 error generated.
has_nothrow_move_constructor.pass.cpp failed to compile
has_trivial_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Union>' requested here
    test_has_trivial_assign<Union>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Abstract>' requested here
    test_has_trivial_assign<Abstract>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Empty>' requested here
    test_has_trivial_assign<Empty>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_trivial_assign<NotEmpty>' requested here
    test_has_trivial_assign<NotEmpty>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_trivial_assign<bit_zero>' requested here
    test_has_trivial_assign<bit_zero>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
has_trivial_copy_assign.pass.cpp failed to compile
has_trivial_copy_constructor.pass.cpp:28:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:64:5: note: in instantiation of function template specialization 'test_has_not_trivial_copy_constructor<int &>' requested here
    test_has_not_trivial_copy_constructor<int&>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:29:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:30:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:31:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Union>' requested here
    test_has_trivial_copy_constructor<Union>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Abstract>' requested here
    test_has_trivial_copy_constructor<Abstract>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Empty>' requested here
    test_has_trivial_copy_constructor<Empty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<NotEmpty>' requested here
    test_has_trivial_copy_constructor<NotEmpty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
has_trivial_copy_constructor.pass.cpp failed to compile
has_trivial_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:66:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Union>' requested here
    test_has_trivial_default_constructor<Union>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:67:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Abstract>' requested here
    test_has_trivial_default_constructor<Abstract>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Empty>' requested here
    test_has_trivial_default_constructor<Empty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<NotEmpty>' requested here
    test_has_trivial_default_constructor<NotEmpty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<bit_zero>' requested here
    test_has_trivial_default_constructor<bit_zero>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
has_trivial_default_constructor.pass.cpp failed to compile
has_trivial_destructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:68:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Union>' requested here
    test_has_trivial_destructor<Union>();
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:69:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Empty>' requested here
    test_has_trivial_destructor<Empty>();
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<bit_zero>' requested here
    test_has_trivial_destructor<bit_zero>();
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
12 errors generated.
has_trivial_destructor.pass.cpp failed to compile
has_trivial_move_assign.pass.cpp:18:2: error: #error has_trivial_move_assign not implemented
#error has_trivial_move_assign not implemented
 ^
1 error generated.
has_trivial_move_assign.pass.cpp failed to compile
has_trivial_move_constructor.pass.cpp:18:2: error: #error has_trivial_move_constructor not implemented
#error has_trivial_move_constructor not implemented
 ^
1 error generated.
has_trivial_move_constructor.pass.cpp failed to compile
has_virtual_destructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:75:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<Abstract>' requested here
    test_has_virtual_destructor<Abstract>();
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:19:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:76:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<NotEmpty>' requested here
    test_has_virtual_destructor<NotEmpty>();
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:21:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
8 errors generated.
has_virtual_destructor.pass.cpp failed to compile
In file included from is_empty.pass.cpp:14:
../../../../../include/type_traits:668:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:679:56: note: in instantiation of template class 'std::__is_empty1<Union>' requested here
struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                       ^
../../../../../include/type_traits:683:40: note: in instantiation of template class 'std::__libcpp_empty<Union, 1>' requested here
template <class _Tp> struct is_empty : public __libcpp_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:28:5: note: in instantiation of template class 'std::is_empty<Union>' requested here
    static_assert(!std::is_empty<T>::value, "");
    ^
is_empty.pass.cpp:28:20: note: instantiated from:
    static_assert(!std::is_empty<T>::value, "");
                   ^
is_empty.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:14:
../../../../../include/type_traits:668:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:679:56: note: in instantiation of template class 'std::__is_empty1<Union const>' requested here
struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                       ^
../../../../../include/type_traits:683:40: note: in instantiation of template class 'std::__libcpp_empty<Union const, 1>' requested here
template <class _Tp> struct is_empty : public __libcpp_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:29:5: note: in instantiation of template class 'std::is_empty<Union const>' requested here
    static_assert(!std::is_empty<const T>::value, "");
    ^
is_empty.pass.cpp:29:20: note: instantiated from:
    static_assert(!std::is_empty<const T>::value, "");
                   ^
is_empty.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:14:
../../../../../include/type_traits:668:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:679:56: note: in instantiation of template class 'std::__is_empty1<Union volatile>' requested here
struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                       ^
../../../../../include/type_traits:683:40: note: in instantiation of template class 'std::__libcpp_empty<Union volatile, 1>' requested here
template <class _Tp> struct is_empty : public __libcpp_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:30:5: note: in instantiation of template class 'std::is_empty<Union volatile>' requested here
    static_assert(!std::is_empty<volatile T>::value, "");
    ^
is_empty.pass.cpp:30:20: note: instantiated from:
    static_assert(!std::is_empty<volatile T>::value, "");
                   ^
is_empty.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:14:
../../../../../include/type_traits:668:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:679:56: note: in instantiation of template class 'std::__is_empty1<Union const volatile>' requested here
struct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                       ^
../../../../../include/type_traits:683:40: note: in instantiation of template class 'std::__libcpp_empty<Union const volatile, 1>' requested here
template <class _Tp> struct is_empty : public __libcpp_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:31:5: note: in instantiation of template class 'std::is_empty<Union const volatile>' requested here
    static_assert(!std::is_empty<const volatile T>::value, "");
    ^
is_empty.pass.cpp:31:20: note: instantiated from:
    static_assert(!std::is_empty<const volatile T>::value, "");
                   ^
is_empty.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
4 errors generated.
is_empty.pass.cpp failed to compile
is_literal_type.pass.cpp:18:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:18:25: note: instantiated from:
    static_assert( std::is_literal_type<int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:18:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:18:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:19:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:19:25: note: instantiated from:
    static_assert( std::is_literal_type<const int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:19:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:19:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:20:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:20:25: note: instantiated from:
    static_assert(!std::is_literal_type<int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:20:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:20:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:21:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:21:25: note: instantiated from:
    static_assert(!std::is_literal_type<volatile int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:21:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:21:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
12 errors generated.
is_literal_type.pass.cpp failed to compile
is_pod.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:46:5: note: in instantiation of function template specialization 'test_is_pod<int>' requested here
    test_is_pod<int>();
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:47:5: note: in instantiation of function template specialization 'test_is_pod<double>' requested here
    test_is_pod<double>();
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:48:5: note: in instantiation of function template specialization 'test_is_pod<int *>' requested here
    test_is_pod<int*>();
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:49:5: note: in instantiation of function template specialization 'test_is_pod<int const *>' requested here
    test_is_pod<const int*>();
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:20:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:50:5: note: in instantiation of function template specialization 'test_is_pod<char [3]>' requested here
    test_is_pod<char[3]>();
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:22:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__config:125:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
is_pod.pass.cpp failed to compile
In file included from is_polymorphic.pass.cpp:14:
../../../../../include/type_traits:687:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:692:38: note: in instantiation of template class 'std::__is_polymorphic1<Union>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:696:46: note: in instantiation of template class 'std::__libcpp_polymorphic<Union, 1>' requested here
template <class _Tp> struct is_polymorphic : public __libcpp_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:28:5: note: in instantiation of template class 'std::is_polymorphic<Union>' requested here
    static_assert(!std::is_polymorphic<T>::value, "");
    ^
is_polymorphic.pass.cpp:28:20: note: instantiated from:
    static_assert(!std::is_polymorphic<T>::value, "");
                   ^
is_polymorphic.pass.cpp:65:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:14:
../../../../../include/type_traits:687:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:692:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:696:46: note: in instantiation of template class 'std::__libcpp_polymorphic<Union const, 1>' requested here
template <class _Tp> struct is_polymorphic : public __libcpp_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:29:5: note: in instantiation of template class 'std::is_polymorphic<Union const>' requested here
    static_assert(!std::is_polymorphic<const T>::value, "");
    ^
is_polymorphic.pass.cpp:29:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const T>::value, "");
                   ^
is_polymorphic.pass.cpp:65:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:14:
../../../../../include/type_traits:687:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:692:38: note: in instantiation of template class 'std::__is_polymorphic1<Union volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:696:46: note: in instantiation of template class 'std::__libcpp_polymorphic<Union volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __libcpp_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:30:5: note: in instantiation of template class 'std::is_polymorphic<Union volatile>' requested here
    static_assert(!std::is_polymorphic<volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:30:20: note: instantiated from:
    static_assert(!std::is_polymorphic<volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:65:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:14:
../../../../../include/type_traits:687:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:692:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:696:46: note: in instantiation of template class 'std::__libcpp_polymorphic<Union const volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __libcpp_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:31:5: note: in instantiation of template class 'std::is_polymorphic<Union const volatile>' requested here
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:31:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:65:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
4 errors generated.
is_polymorphic.pass.cpp failed to compile
is_standard_layout.pass.cpp:18:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert( std::is_standard_layout<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:18:25: note: instantiated from:
    static_assert( std::is_standard_layout<int>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:18:5: error: type name requires a specifier or qualifier
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:18:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:19:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:19:25: note: instantiated from:
    static_assert(!std::is_standard_layout<int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:19:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:19:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:20:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:20:25: note: instantiated from:
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:20:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:20:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 errors generated.
is_standard_layout.pass.cpp failed to compile
is_trivial.pass.cpp:18:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert( std::is_trivial<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:18:25: note: instantiated from:
    static_assert( std::is_trivial<int>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:18:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:18:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:19:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:19:25: note: instantiated from:
    static_assert(!std::is_trivial<int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:19:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:19:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:20:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:20:25: note: instantiated from:
    static_assert(!std::is_trivial<volatile int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:20:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:20:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 errors generated.
is_trivial.pass.cpp failed to compile
is_trivialially_copyable.pass.cpp:30:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:30:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:30:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:30:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:31:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:31:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:31:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:31:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:32:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:32:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<int&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:33:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:33:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:34:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:34:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:35:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:35:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:35:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:35:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:14:
In file included from ../../../../../include/type_traits:136:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:36:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:36:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<B>::value, "");
                   ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
is_trivialially_copyable.pass.cpp failed to compile
failed 24 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 10 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 2 tests in /test/utilities/ratio
passed 8 tests in /test/utilities/ratio/ratio.arithmetic
passed 6 tests in /test/utilities/ratio/ratio.comparison
passed 4 tests in /test/utilities/ratio/ratio.ratio
passed 1 tests in /test/utilities/ratio/ratio.si
passed 2 tests in /test/utilities/template.bitset
passed 4 tests in /test/utilities/template.bitset/bitset.cons
passed 1 tests in /test/utilities/template.bitset/bitset.hash
passed 26 tests in /test/utilities/template.bitset/bitset.members
passed 5 tests in /test/utilities/template.bitset/bitset.operators
passed 7 tests in /test/utilities/time
passed 1 tests in /test/utilities/time/time.clock
passed 2 tests in /test/utilities/time/time.clock/time.clock.hires
passed 2 tests in /test/utilities/time/time.clock/time.clock.monotonic
passed 5 tests in /test/utilities/time/time.clock/time.clock.system
passed 1 tests in /test/utilities/time/time.clock.req
passed 5 tests in /test/utilities/time/time.duration
passed 12 tests in /test/utilities/time/time.duration/time.duration.arithmetic
passed 2 tests in /test/utilities/time/time.duration/time.duration.cast
passed 2 tests in /test/utilities/time/time.duration/time.duration.comparisons
passed 11 tests in /test/utilities/time/time.duration/time.duration.cons
passed 11 tests in /test/utilities/time/time.duration/time.duration.nonmember
passed 1 tests in /test/utilities/time/time.duration/time.duration.observer
passed 3 tests in /test/utilities/time/time.duration/time.duration.special
passed 2 tests in /test/utilities/time/time.point
passed 2 tests in /test/utilities/time/time.point/time.point.arithmetic
passed 2 tests in /test/utilities/time/time.point/time.point.cast
passed 4 tests in /test/utilities/time/time.point/time.point.comparisons
passed 5 tests in /test/utilities/time/time.point/time.point.cons
passed 3 tests in /test/utilities/time/time.point/time.point.nonmember
passed 1 tests in /test/utilities/time/time.point/time.point.observer
passed 2 tests in /test/utilities/time/time.point/time.point.special
passed 1 tests in /test/utilities/time/time.traits
passed 3 tests in /test/utilities/time/time.traits/time.traits.duration_values
passed 1 tests in /test/utilities/time/time.traits/time.traits.is_fp
passed 2 tests in /test/utilities/time/time.traits/time.traits.specializations
passed 1 tests in /test/utilities/tuple
passed 1 tests in /test/utilities/tuple/tuple.general
empty_member.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, A> T;
                ~~~~~^
empty_member.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<int, A> T;
                          ^
empty_member.pass.cpp:26:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:26:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:26:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:26:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:29:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int> T;
                ~~~~~^
empty_member.pass.cpp:29:27: error: expected unqualified-id
        typedef std::tuple<A, int> T;
                          ^
empty_member.pass.cpp:30:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:30:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:30:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:30:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:33:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int, B> T;
                ~~~~~^
empty_member.pass.cpp:33:27: error: expected unqualified-id
        typedef std::tuple<A, int, B> T;
                          ^
empty_member.pass.cpp:34:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:34:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:34:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:34:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, B, int> T;
                ~~~~~^
empty_member.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<A, B, int> T;
                          ^
empty_member.pass.cpp:38:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:38:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:38:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:16:
In file included from ../../../../include/tuple:115:
../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
empty_member.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple
const_pair.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:27:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
const_pair.pass.cpp:28:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
const_pair.pass.cpp:29:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:29:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:30:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:30:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
6 errors generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:39:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:40:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:41:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:45:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:45:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:47:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:48:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:49:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:51:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:40:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:40:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:42:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:43:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:44:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:50:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:51:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:52:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:53:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:54:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:23:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:23:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:24:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:25:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:26:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:29:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:29:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:30:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:31:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:32:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:33:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:33:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:36:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:36:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:37:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:39:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:40:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:41:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
copy.pass.cpp failed to compile
move.pass.cpp:24:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:24:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:25:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:26:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:27:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:30:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:30:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:31:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:32:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:33:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:34:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:40:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:42:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:45:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:41:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:43:20: error: no viable constructor copying parameter of type 'std::unique_ptr<D>'
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from move_pair.pass.cpp:17:
In file included from ../../../../../include/tuple:118:
../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D>' to 'std::unique_ptr<D, std::default_delete<D> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
move_pair.pass.cpp:44:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
move_pair.pass.cpp:45:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
move_pair.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:47:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:17:
In file included from ../../../../../include/tuple:118:
In file included from ../../../../../include/memory:196:
../../../../../include/utility:212:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:43:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:17:
In file included from ../../../../../include/tuple:118:
../../../../../include/memory:2062:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../include/memory:2087:40: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                       ^
../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../include/memory:2095:44: note: candidate template ignored: failed template argument deduction
        _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                           ^
../../../../../include/memory:2075:31: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr()
                              ^
../../../../../include/memory:2184:31: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                              ^
9 errors generated.
move_pair.pass.cpp failed to compile
failed 6 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
UTypes.pass.cpp:25:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:26:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:26:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:29:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t(MoveOnly(0), MoveOnly(1));
        ~~~~~^
UTypes.pass.cpp:30:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:30:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:31:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:31:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:34:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:37:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:37:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:38:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:39:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
UTypes.pass.cpp:43:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:46:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:47:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:50:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:53:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
17 errors generated.
UTypes.pass.cpp failed to compile
In file included from alloc.pass.cpp:22:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc.pass.cpp:23:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc.pass.cpp failed to compile
In file included from alloc_UTypes.pass.cpp:22:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_UTypes.pass.cpp:23:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_UTypes.pass.cpp failed to compile
In file included from alloc_const_Types.pass.cpp:21:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_Types.pass.cpp:22:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_const_Types.pass.cpp failed to compile
In file included from alloc_const_pair.pass.cpp:22:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_pair.pass.cpp:23:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_const_pair.pass.cpp failed to compile
In file included from alloc_convert_copy.pass.cpp:21:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_copy.pass.cpp:22:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_convert_copy.pass.cpp failed to compile
In file included from alloc_convert_move.pass.cpp:23:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_move.pass.cpp:24:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_convert_move.pass.cpp failed to compile
In file included from alloc_copy.pass.cpp:21:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_copy.pass.cpp:22:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_copy.pass.cpp failed to compile
In file included from alloc_move.pass.cpp:22:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move.pass.cpp:23:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_move.pass.cpp failed to compile
In file included from alloc_move_pair.pass.cpp:23:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move_pair.pass.cpp:24:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
alloc_move_pair.pass.cpp failed to compile
const_Types.pass.cpp:23:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(2);
        ~~~~~^
const_Types.pass.cpp:24:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:24:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:27:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, 0);
        ~~~~~^
const_Types.pass.cpp:28:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:28:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:29:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:29:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:32:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:33:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:33:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:34:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:37:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr, "text");
        ~~~~~^
const_Types.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:39:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:40:21: note: instantiated from:
        assert(std::get<2>(t) == "text");
               ~~~~~^
const_Types.pass.cpp:44:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2);
        ~~~~~^
const_Types.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:46:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:47:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
const_Types.pass.cpp:50:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
const_Types.pass.cpp failed to compile
const_pair.pass.cpp:24:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:24:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:26:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
const_pair.pass.cpp:27:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:27:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:28:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:28:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
5 errors generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:36:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:36:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:38:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:39:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:40:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:45:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:46:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_copy.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_copy.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:40:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:40:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:41:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:42:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:48:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:49:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:51:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_move.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_move.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:23:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:23:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:24:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:25:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:28:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:28:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:29:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:30:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:31:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:31:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:34:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:34:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:35:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:36:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:37:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:37:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:38:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
copy.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int, char, std::string> T;
                          ^
copy.pass.cpp:42:9: error: use of undeclared identifier 'T'
        T t0(2, 'a', "some text");
        ^
copy.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
copy.pass.cpp failed to compile
default.pass.cpp:25:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t;
        ~~~~~^
default.pass.cpp:28:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t;
        ~~~~~^
default.pass.cpp:29:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:29:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:32:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t;
        ~~~~~^
default.pass.cpp:33:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:33:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:34:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:37:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t;
        ~~~~~^
default.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:39:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:40:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:43:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string, DefaultOnly> t;
        ~~~~~^
default.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:44:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:45:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:46:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:47:21: note: instantiated from:
        assert(std::get<3>(t) == DefaultOnly());
               ~~~~~^
15 errors generated.
default.pass.cpp failed to compile
move.pass.cpp:24:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:24:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:25:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:26:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:29:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:29:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:30:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:31:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:32:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:32:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:35:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:35:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:36:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:37:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:39:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
move.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:40:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:42:20: error: no viable constructor copying parameter of type 'std::unique_ptr<D>'
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
                   ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
In file included from move_pair.pass.cpp:16:
In file included from ../../../../../include/tuple:118:
../../../../../include/memory:2062:5: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D>' to 'std::unique_ptr<D, std::default_delete<D> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
move_pair.pass.cpp:43:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
move_pair.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:44:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:45:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:16:
In file included from ../../../../../include/tuple:118:
In file included from ../../../../../include/memory:196:
../../../../../include/utility:212:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:42:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:16:
In file included from ../../../../../include/tuple:118:
../../../../../include/memory:2062:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2081:31: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t)
                              ^
../../../../../include/memory:2087:40: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                       ^
../../../../../include/memory:2173:31: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                              ^
../../../../../include/memory:2095:44: note: candidate template ignored: failed template argument deduction
        _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                           ^
../../../../../include/memory:2075:31: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr()
                              ^
../../../../../include/memory:2184:31: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                              ^
8 errors generated.
move_pair.pass.cpp failed to compile
failed 18 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
passed 4 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
make_tuple.pass.cpp:26:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int&, float&> t = std::make_tuple(1, std::ref(i),
        ~~~~~^
make_tuple.pass.cpp:28:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:28:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:29:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:29:21: note: instantiated from:
        assert(std::get<1>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:30:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:30:21: note: instantiated from:
        assert(std::get<2>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:33:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:33:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:34:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
make_tuple.pass.cpp:35:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:35:21: note: instantiated from:
        assert(std::get<2>(t) == 3.5);
               ~~~~~^
make_tuple.pass.cpp:36:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 0;
        ~~~~~^
make_tuple.pass.cpp:37:14: error: no member named 'get' in namespace 'std'
        std::get<2>(t) = 0;
        ~~~~~^
9 errors generated.
make_tuple.pass.cpp failed to compile
tie.pass.cpp:26:14: error: no member named 'tie' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
        ~~~~~^
tie.pass.cpp:26:26: error: no member named 'ignore' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
                    ~~~~~^
2 errors generated.
tie.pass.cpp failed to compile
tuple_cat.pass.cpp:39:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:40:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t2;
        ~~~~~^
tuple_cat.pass.cpp:41:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:44:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:45:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:50:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:51:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:52:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:53:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:56:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:57:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:63:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:65:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int*> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
tuple_cat.pass.cpp failed to compile
failed 3 tests in /test/utilities/tuple/tuple.tuple/tuple.creation
get_const.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_const.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_const.pass.cpp:26:15: error: unknown type name 'T'
        const T t(3);
              ^
get_const.pass.cpp:27:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:27:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_const.pass.cpp:30:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_const.pass.cpp:30:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_const.pass.cpp:31:15: error: unknown type name 'T'
        const T t("high", 5);
              ^
get_const.pass.cpp:31:17: error: excess elements in scalar initializer
        const T t("high", 5);
                ^ ~~~~~~~~~
get_const.pass.cpp:32:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:32:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_const.pass.cpp:33:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:33:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_const.pass.cpp:36:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_const.pass.cpp:36:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_const.pass.cpp:38:15: error: unknown type name 'T'
        const T t(d, "high", 5);
              ^
get_const.pass.cpp:38:17: error: excess elements in scalar initializer
        const T t(d, "high", 5);
                ^ ~~~~~~~~~~~~
get_const.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:39:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
get_const.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:40:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_const.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:41:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
get_const.pass.cpp:42:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2.5;
        ~~~~~^
get_const.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 2.5);
               ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
get_const.pass.cpp failed to compile
get_non_const.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_non_const.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_non_const.pass.cpp:26:9: error: use of undeclared identifier 'T'
        T t(3);
        ^
get_non_const.pass.cpp:27:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:27:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_non_const.pass.cpp:28:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2;
        ~~~~~^
get_non_const.pass.cpp:29:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:29:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
get_non_const.pass.cpp:32:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:32:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_non_const.pass.cpp:33:9: error: use of undeclared identifier 'T'
        T t("high", 5);
        ^
get_non_const.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:34:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_non_const.pass.cpp:35:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:35:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_non_const.pass.cpp:36:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = "four";
        ~~~~~^
get_non_const.pass.cpp:37:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 4;
        ~~~~~^
get_non_const.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "four");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == "four");
               ~~~~~^
get_non_const.pass.cpp:39:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:39:21: note: instantiated from:
        assert(std::get<1>(t) == 4);
               ~~~~~^
get_non_const.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_non_const.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t(d, "high", 5);
        ^
get_non_const.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
get_non_const.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
tuple_element.pass.cpp:27:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_element.pass.cpp:27:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_element.pass.cpp:28:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:28:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:28:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:28:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:28:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:28:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:28:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:29:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:28:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:29:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:28:9: error: expected ')'
tuple_element.pass.cpp:28:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:28:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:28:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:21:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:28:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:21:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:32:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
tuple_element.pass.cpp:32:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
tuple_element.pass.cpp:33:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:33:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:33:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:33:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:33:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:33:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:33:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:34:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:33:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:34:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:33:9: error: expected ')'
tuple_element.pass.cpp:33:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:33:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:33:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:21:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
tuple_element.pass.cpp failed to compile
tuple_size.pass.cpp:24:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
tuple_size.pass.cpp:24:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
tuple_size.pass.cpp:25:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:26:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:25:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:26:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:25:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:26:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:25:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:26:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:25:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:26:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:25:9: error: expected ')'
tuple_size.pass.cpp:25:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:25:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
                      ^
tuple_size.pass.cpp:25:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:18:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:25:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:18:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:29:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_size.pass.cpp:29:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_size.pass.cpp:30:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:31:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:30:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:31:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:30:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:31:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:30:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:31:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:30:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:31:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:30:9: error: expected ')'
tuple_size.pass.cpp:30:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:30:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
                      ^
tuple_size.pass.cpp:30:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
In file included from tuple_size.pass.cpp:18:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
tuple_size.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.helper
begin.pass.cpp:27:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int*, int*> T;
                ~~~~~^
begin.pass.cpp:27:27: error: expected unqualified-id
        typedef std::tuple<int*, int*> T;
                          ^
begin.pass.cpp:29:15: error: unknown type name 'T'
        const T t(std::begin(array), std::end(array));
              ^
begin.pass.cpp:29:17: error: excess elements in scalar initializer
        const T t(std::begin(array), std::end(array));
                ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 errors generated.
begin.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.range
eq.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
eq.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
eq.pass.cpp:26:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
eq.pass.cpp:26:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
eq.pass.cpp:27:15: error: unknown type name 'T1'
        const T1 t1;
              ^
eq.pass.cpp:28:15: error: unknown type name 'T2'
        const T2 t2;
              ^
eq.pass.cpp:33:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:33:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:34:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:34:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:35:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:36:15: error: unknown type name 'T2'
        const T2 t2(1.1);
              ^
eq.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:43:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:44:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
eq.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
eq.pass.cpp failed to compile
lt.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
lt.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
lt.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
lt.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
lt.pass.cpp:39:15: error: unknown type name 'T1'
        const T1 t1;
              ^
lt.pass.cpp:40:15: error: unknown type name 'T2'
        const T2 t2;
              ^
lt.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:49:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:50:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
lt.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:59:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:60:15: error: unknown type name 'T2'
        const T2 t2(0.9);
              ^
lt.pass.cpp:67:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
lt.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.rel
non_member_swap.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
non_member_swap.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
non_member_swap.pass.cpp:26:9: error: use of undeclared identifier 'T'
        T t0;
        ^
non_member_swap.pass.cpp:27:9: error: use of undeclared identifier 'T'
        T t1;
        ^
non_member_swap.pass.cpp:28:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:31:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:31:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
non_member_swap.pass.cpp:32:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
non_member_swap.pass.cpp:33:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
non_member_swap.pass.cpp:34:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:35:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:35:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
non_member_swap.pass.cpp:36:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:36:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
non_member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
non_member_swap.pass.cpp:41:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
non_member_swap.pass.cpp:42:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t0) == 2);
               ~~~~~^
non_member_swap.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:44:21: note: instantiated from:
        assert(std::get<1>(t0) == 3);
               ~~~~~^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
non_member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.special
member_swap.pass.cpp:24:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
member_swap.pass.cpp:24:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
member_swap.pass.cpp:25:9: error: use of undeclared identifier 'T'
        T t0;
        ^
member_swap.pass.cpp:26:9: error: use of undeclared identifier 'T'
        T t1;
        ^
member_swap.pass.cpp:27:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:27:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:30:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:30:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
member_swap.pass.cpp:31:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
member_swap.pass.cpp:32:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
member_swap.pass.cpp:33:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:33:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:34:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:34:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
member_swap.pass.cpp:35:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:35:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
member_swap.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
member_swap.pass.cpp:41:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.swap
uses_allocator.pass.cpp:25:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
uses_allocator.pass.cpp:25:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
uses_allocator.pass.cpp:26:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:27:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:26:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:27:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:26:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:27:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:26:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:17:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:26:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:17:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:27:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:27:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:27:79: error: expected ')'
uses_allocator.pass.cpp:26:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:17:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:30:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
uses_allocator.pass.cpp:30:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
uses_allocator.pass.cpp:31:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:32:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:31:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:32:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:31:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:32:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:31:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:17:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:31:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:17:
In file included from ../../../../../include/tuple:115:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:32:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:32:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
uses_allocator.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.traits
passed 1 tests in /test/utilities/type.index
passed 1 tests in /test/utilities/type.index/type.index.hash
passed 5 tests in /test/utilities/type.index/type.index.members
passed 2 tests in /test/utilities/type.index/type.index.overview
passed 1 tests in /test/utilities/type.index/type.index.synopsis
passed 1 tests in /test/utilities/utilities.general
passed 1 tests in /test/utilities/utility
passed 1 tests in /test/utilities/utility/declval
passed 14 tests in /test/utilities/utility/forward
passed 1 tests in /test/utilities/utility/operators
passed 1 tests in /test/utilities/utility/pairs
get_const.pass.cpp:26:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(p) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:26:21: note: instantiated from:
        assert(std::get<0>(p) == 3);
               ~~~~~^
get_const.pass.cpp:27:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(p) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:27:21: note: instantiated from:
        assert(std::get<1>(p) == 4);
               ~~~~~^
2 errors generated.
get_const.pass.cpp failed to compile
get_non_const.pass.cpp:26:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(p) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:26:21: note: instantiated from:
        assert(std::get<0>(p) == 3);
               ~~~~~^
get_non_const.pass.cpp:27:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(p) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:27:21: note: instantiated from:
        assert(std::get<1>(p) == 4);
               ~~~~~^
get_non_const.pass.cpp:28:14: error: no member named 'get' in namespace 'std'
        std::get<0>(p) = 5;
        ~~~~~^
get_non_const.pass.cpp:29:14: error: no member named 'get' in namespace 'std'
        std::get<1>(p) = 6;
        ~~~~~^
get_non_const.pass.cpp:30:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(p) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:30:21: note: instantiated from:
        assert(std::get<0>(p) == 5);
               ~~~~~^
get_non_const.pass.cpp:31:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(p) == 6);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:31:21: note: instantiated from:
        assert(std::get<1>(p) == 6);
               ~~~~~^
6 errors generated.
get_non_const.pass.cpp failed to compile
tuple_element.pass.cpp:22:9: error: implicit instantiation of undefined template 'std::tuple_element<0, std::pair<int, short> >'
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
tuple_element.pass.cpp:22:37: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
                                    ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:113:
In file included from ../../../../../include/__tuple:21:
../../../../../include/__tuple_03:20:40: note: template is declared here
template <size_t _Ip, class _Tp> class tuple_element;
                                       ^
tuple_element.pass.cpp:22:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
tuple_element.pass.cpp:22:76: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
                                                                           ^
tuple_element.pass.cpp:22:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
tuple_element.pass.cpp:22:76: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
                                                                           ^
tuple_element.pass.cpp:22:9: error: expected ')'
tuple_element.pass.cpp:22:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
tuple_element.pass.cpp:22:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
                      ^
tuple_element.pass.cpp:22:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:22:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:23:9: error: implicit instantiation of undefined template 'std::tuple_element<1, std::pair<int, short> >'
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
tuple_element.pass.cpp:23:37: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
                                    ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:113:
In file included from ../../../../../include/__tuple:21:
../../../../../include/__tuple_03:20:40: note: template is declared here
template <size_t _Ip, class _Tp> class tuple_element;
                                       ^
tuple_element.pass.cpp:23:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
tuple_element.pass.cpp:23:78: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
                                                                             ^
tuple_element.pass.cpp:23:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
tuple_element.pass.cpp:23:78: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
                                                                             ^
tuple_element.pass.cpp:23:9: error: expected ')'
tuple_element.pass.cpp:23:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
tuple_element.pass.cpp:23:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
                      ^
tuple_element.pass.cpp:23:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:23:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, P1>::type, short>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:27:9: error: implicit instantiation of undefined template 'std::tuple_element<0, std::pair<int *, char> >'
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
tuple_element.pass.cpp:27:37: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
                                    ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:113:
In file included from ../../../../../include/__tuple:21:
../../../../../include/__tuple_03:20:40: note: template is declared here
template <size_t _Ip, class _Tp> class tuple_element;
                                       ^
tuple_element.pass.cpp:27:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
tuple_element.pass.cpp:27:77: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
                                                                            ^
tuple_element.pass.cpp:27:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
tuple_element.pass.cpp:27:77: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
                                                                            ^
tuple_element.pass.cpp:27:9: error: expected ')'
tuple_element.pass.cpp:27:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
tuple_element.pass.cpp:27:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
                      ^
tuple_element.pass.cpp:27:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:27:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, P1>::type, int*>::value), "");
        ^
In file included from tuple_element.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:28:9: error: implicit instantiation of undefined template 'std::tuple_element<1, std::pair<int *, char> >'
        static_assert((std::is_same<std::tuple_element<1, P1>::type, char>::value), "");
        ^
tuple_element.pass.cpp:28:37: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, P1>::type, char>::value), "");
                                    ^
fatal error: too many errors emitted, stopping now [-ferror-limit=]
20 errors generated.
tuple_element.pass.cpp failed to compile
tuple_size.pass.cpp:22:9: error: implicit instantiation of undefined template 'std::tuple_size<std::pair<int, short> >'
        static_assert((std::tuple_size<P1>::value == 2), "");
        ^
tuple_size.pass.cpp:22:24: note: instantiated from:
        static_assert((std::tuple_size<P1>::value == 2), "");
                       ^
In file included from tuple_size.pass.cpp:16:
In file included from ../../../../../include/utility:113:
In file included from ../../../../../include/__tuple:21:
../../../../../include/__tuple_03:19:28: note: template is declared here
template <class _Tp> class tuple_size;
                           ^
tuple_size.pass.cpp:22:9: error: type name requires a specifier or qualifier
        static_assert((std::tuple_size<P1>::value == 2), "");
        ^
In file included from tuple_size.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:22:9: error: C++ requires a type specifier for all declarations
        static_assert((std::tuple_size<P1>::value == 2), "");
        ^
In file included from tuple_size.pass.cpp:16:
In file included from ../../../../../include/utility:112:
../../../../../include/__config:129:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
3 errors generated.
tuple_size.pass.cpp failed to compile
failed 4 tests in /test/utilities/utility/pairs/pair.astuple
passed 1 tests in /test/utilities/utility/pairs/pair.astuple
passed 1 tests in /test/utilities/utility/pairs/pair.piecewise
passed 2 tests in /test/utilities/utility/pairs/pair.range
passed 1 tests in /test/utilities/utility/pairs/pairs.general
passed 15 tests in /test/utilities/utility/pairs/pairs.pair
passed 2 tests in /test/utilities/utility/utility.swap
passed 1 tests in /test/utilities/utility.requirements
passed 1 tests in /test/utilities/utility.requirements/allocator.requirements
passed 1 tests in /test/utilities/utility.requirements/hash.requirements
passed 1 tests in /test/utilities/utility.requirements/nullablepointer.requirements
passed 1 tests in /test/utilities/utility.requirements/swappable.requirements
passed 1 tests in /test/utilities/utility.requirements/utility.arg.requirements
****************************************************
Results for /test:
using Apple clang version 2.0 (trunk 104832)
Target: x86_64-apple-darwin10
Thread model: posix
with -nostdinc++ -nodefaultlibs /usr/lib/libSystem.B.dylib -arch i386 -I../include /usr/lib/libc++.dylib
----------------------------------------------------
sections without tests   : 86
sections with failures   : 48
sections without failures: 918
                       +   ----
total number of sections : 1052
----------------------------------------------------
number of tests failed   : 144
number of tests passed   : 3743
                       +   ----
total number of tests    : 3887
****************************************************
