passed 1 tests in /test
passed 1 tests in /test/algorithms
passed 1 tests in /test/algorithms/alg.c.library
passed 1 tests in /test/algorithms/alg.modifying.operations
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.copy
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.fill
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.generate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.move
passed 5 tests in /test/algorithms/alg.modifying.operations/alg.partitions
random_shuffle_urng.pass.cpp:32:2: error: #error random_shuffle for UniformRandomNumberGenerator not implemented
#error random_shuffle for UniformRandomNumberGenerator not implemented
 ^
1 error generated.
random_shuffle_urng.pass.cpp failed to compile
failed 1 tests in /test/algorithms/alg.modifying.operations/alg.random.shuffle
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.random.shuffle
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.remove
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.replace
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.reverse
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.rotate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.swap
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.transform
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.unique
passed 1 tests in /test/algorithms/alg.nonmodifying
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.adjacent.find
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.all_of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.any_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.count
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.equal
passed 3 tests in /test/algorithms/alg.nonmodifying/alg.find
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.end
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.first.of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.foreach
not implemented:  /test/algorithms/alg.nonmodifying/alg.is_permutation
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.none_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.search
passed 2 tests in /test/algorithms/alg.nonmodifying/mismatch
passed 1 tests in /test/algorithms/alg.sorting
passed 1 tests in /test/algorithms/alg.sorting/alg.binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/equal.range
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/lower.bound
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/upper.bound
passed 1 tests in /test/algorithms/alg.sorting/alg.heap.operations
passed 4 tests in /test/algorithms/alg.sorting/alg.heap.operations/is.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/make.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/pop.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/push.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/sort.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.lex.comparison
passed 4 tests in /test/algorithms/alg.sorting/alg.merge
max_init_list.pass.cpp:33:2: error: #error max(initializer_list<T> t) is not implemented
#error max(initializer_list<T> t) is not implemented
 ^
1 error generated.
max_init_list.pass.cpp failed to compile
max_init_list_comp.pass.cpp:33:2: error: #error max(initializer_list<T> t, Compare comp) is not implemented
#error max(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
max_init_list_comp.pass.cpp failed to compile
min_init_list.pass.cpp:33:2: error: #error min(initializer_list<T> t) is not implemented
#error min(initializer_list<T> t) is not implemented
 ^
1 error generated.
min_init_list.pass.cpp failed to compile
min_init_list_comp.pass.cpp:33:2: error: #error min(initializer_list<T> t, Compare comp) is not implemented
#error min(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
min_init_list_comp.pass.cpp failed to compile
minmax.pass.cpp:37:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                      ~~~~~^
In file included from minmax.pass.cpp:30:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:38: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                     ^
minmax.pass.cpp:37:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                  ^
minmax.pass.cpp:47:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(x, y, x, y);
    ^
In file included from minmax.pass.cpp:30:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:47: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                              ^
3 errors generated.
minmax.pass.cpp failed to compile
minmax_comp.pass.cpp:39:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                      ~~~~~^
In file included from minmax_comp.pass.cpp:31:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:38: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                     ^
minmax_comp.pass.cpp:39:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                  ^
minmax_comp.pass.cpp:49:5: note: in instantiation of function template specialization 'test<int, std::greater<int> >' requested here
    test(x, y, std::greater<int>(), x, y);
    ^
In file included from minmax_comp.pass.cpp:31:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:47: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                              ^
3 errors generated.
minmax_comp.pass.cpp failed to compile
minmax_init_list.pass.cpp:33:2: error: #error minmax(initializer_list<T> t) is not implemented
#error minmax(initializer_list<T> t) is not implemented
 ^
1 error generated.
minmax_init_list.pass.cpp failed to compile
minmax_init_list_comp.pass.cpp:33:2: error: #error minmax(initializer_list<T> t, Compare comp) is not implemented
#error minmax(initializer_list<T> t, Compare comp) is not implemented
 ^
1 error generated.
minmax_init_list_comp.pass.cpp failed to compile
failed 8 tests in /test/algorithms/alg.sorting/alg.min.max
passed 10 tests in /test/algorithms/alg.sorting/alg.min.max
passed 2 tests in /test/algorithms/alg.sorting/alg.nth.element
passed 4 tests in /test/algorithms/alg.sorting/alg.permutation.generators
passed 1 tests in /test/algorithms/alg.sorting/alg.set.operations
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/includes
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.intersection
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.symmetric.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.union
passed 1 tests in /test/algorithms/alg.sorting/alg.sort
passed 4 tests in /test/algorithms/alg.sorting/alg.sort/is.sorted
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort.copy
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/stable.sort
passed 1 tests in /test/algorithms/algorithms.general
not implemented:  /test/atomics
not implemented:  /test/atomics/atomics.fences
not implemented:  /test/atomics/atomics.flag
not implemented:  /test/atomics/atomics.general
not implemented:  /test/atomics/atomics.lockfree
not implemented:  /test/atomics/atomics.order
not implemented:  /test/atomics/atomics.syn
not implemented:  /test/atomics/atomics.types
not implemented:  /test/atomics/atomics.types/atomics.types.address
not implemented:  /test/atomics/atomics.types/atomics.types.generic
not implemented:  /test/atomics/atomics.types/atomics.types.integral
not implemented:  /test/atomics/atomics.types.operations
passed 1 tests in /test/containers
passed 4 tests in /test/containers/associative
passed 1 tests in /test/containers/associative/map
passed 7 tests in /test/containers/associative/map/map.access
passed 17 tests in /test/containers/associative/map/map.cons
passed 12 tests in /test/containers/associative/map/map.modifiers
passed 5 tests in /test/containers/associative/map/map.ops
passed 2 tests in /test/containers/associative/map/map.special
passed 5 tests in /test/containers/associative/multimap
passed 17 tests in /test/containers/associative/multimap/multimap.cons
passed 12 tests in /test/containers/associative/multimap/multimap.modifiers
passed 5 tests in /test/containers/associative/multimap/multimap.ops
passed 2 tests in /test/containers/associative/multimap/multimap.special
passed 22 tests in /test/containers/associative/multiset
passed 17 tests in /test/containers/associative/multiset/multiset.cons
passed 2 tests in /test/containers/associative/multiset/multiset.special
passed 22 tests in /test/containers/associative/set
passed 17 tests in /test/containers/associative/set/set.cons
passed 2 tests in /test/containers/associative/set/set.special
passed 1 tests in /test/containers/container.requirements
passed 1 tests in /test/containers/container.requirements/associative.reqmts
passed 1 tests in /test/containers/container.requirements/associative.reqmts/associative.reqmts.except
passed 1 tests in /test/containers/container.requirements/container.requirements.dataraces
passed 1 tests in /test/containers/container.requirements/container.requirements.general
passed 1 tests in /test/containers/container.requirements/sequence.reqmts
passed 1 tests in /test/containers/container.requirements/unord.req
passed 1 tests in /test/containers/container.requirements/unord.req/unord.req.except
passed 1 tests in /test/containers/containers.general
passed 1 tests in /test/containers/sequences
passed 2 tests in /test/containers/sequences/array
passed 2 tests in /test/containers/sequences/array/array.cons
passed 2 tests in /test/containers/sequences/array/array.data
passed 1 tests in /test/containers/sequences/array/array.fill
passed 1 tests in /test/containers/sequences/array/array.size
passed 1 tests in /test/containers/sequences/array/array.special
passed 1 tests in /test/containers/sequences/array/array.swap
passed 4 tests in /test/containers/sequences/array/array.tuple
passed 1 tests in /test/containers/sequences/array/array.zero
passed 1 tests in /test/containers/sequences/container.adaptors
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue
passed 12 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.cons
passed 6 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.cons.alloc
passed 8 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.members
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.special
passed 1 tests in /test/containers/sequences/container.adaptors/queue
passed 5 tests in /test/containers/sequences/container.adaptors/queue/queue.cons
passed 5 tests in /test/containers/sequences/container.adaptors/queue/queue.cons.alloc
passed 14 tests in /test/containers/sequences/container.adaptors/queue/queue.defn
passed 2 tests in /test/containers/sequences/container.adaptors/queue/queue.ops
passed 1 tests in /test/containers/sequences/container.adaptors/queue/queue.special
passed 1 tests in /test/containers/sequences/container.adaptors/stack
passed 5 tests in /test/containers/sequences/container.adaptors/stack/stack.cons
passed 5 tests in /test/containers/sequences/container.adaptors/stack/stack.cons.alloc
passed 12 tests in /test/containers/sequences/container.adaptors/stack/stack.defn
passed 2 tests in /test/containers/sequences/container.adaptors/stack/stack.ops
passed 1 tests in /test/containers/sequences/container.adaptors/stack/stack.special
passed 1 tests in /test/containers/sequences/deque
passed 4 tests in /test/containers/sequences/deque/deque.capacity
passed 19 tests in /test/containers/sequences/deque/deque.cons
passed 16 tests in /test/containers/sequences/deque/deque.modifiers
passed 5 tests in /test/containers/sequences/deque/deque.special
passed 2 tests in /test/containers/sequences/forwardlist
passed 1 tests in /test/containers/sequences/forwardlist/forwardlist.access
passed 21 tests in /test/containers/sequences/forwardlist/forwardlist.cons
passed 2 tests in /test/containers/sequences/forwardlist/forwardlist.iter
passed 15 tests in /test/containers/sequences/forwardlist/forwardlist.modifiers
passed 12 tests in /test/containers/sequences/forwardlist/forwardlist.ops
passed 4 tests in /test/containers/sequences/forwardlist/forwardlist.spec
passed 1 tests in /test/containers/sequences/list
passed 2 tests in /test/containers/sequences/list/list.capacity
passed 15 tests in /test/containers/sequences/list/list.cons
passed 17 tests in /test/containers/sequences/list/list.modifiers
passed 12 tests in /test/containers/sequences/list/list.ops
passed 1 tests in /test/containers/sequences/list/list.special
passed 1 tests in /test/containers/sequences/vector
passed 6 tests in /test/containers/sequences/vector/vector.capacity
passed 16 tests in /test/containers/sequences/vector/vector.cons
passed 2 tests in /test/containers/sequences/vector/vector.data
passed 11 tests in /test/containers/sequences/vector/vector.modifiers
passed 1 tests in /test/containers/sequences/vector/vector.special
passed 30 tests in /test/containers/sequences/vector.bool
passed 1 tests in /test/containers/unord
eq.pass.cpp:43:2: error: #error unordered_map == unordered_map not implemented
#error unordered_map == unordered_map not implemented
 ^
1 error generated.
eq.pass.cpp failed to compile
failed 1 tests in /test/containers/unord/unord.map
passed 17 tests in /test/containers/unord/unord.map
passed 24 tests in /test/containers/unord/unord.map/unord.map.cnstr
passed 2 tests in /test/containers/unord/unord.map/unord.map.elem
passed 1 tests in /test/containers/unord/unord.map/unord.map.swap
emplace.pass.cpp:36:10: fatal error: '../../Emplaceable.h' file not found
#include "../../Emplaceable.h"
         ^
1 error generated.
emplace.pass.cpp failed to compile
emplace_hint.pass.cpp:36:10: fatal error: '../../Emplaceable.h' file not found
#include "../../Emplaceable.h"
         ^
1 error generated.
emplace_hint.pass.cpp failed to compile
insert_hint_rvalue.pass.cpp:37:10: fatal error: '../../MoveOnly.h' file not found
#include "../../MoveOnly.h"
         ^
1 error generated.
insert_hint_rvalue.pass.cpp failed to compile
insert_init.pass.cpp:36:10: fatal error: '../../iterators.h' file not found
#include "../../iterators.h"
         ^
1 error generated.
insert_init.pass.cpp failed to compile
insert_range.pass.cpp:37:10: fatal error: '../../iterators.h' file not found
#include "../../iterators.h"
         ^
insert_range.pass.cpp:54:18: error: use of undeclared identifier 'input_iterator'
        c.insert(input_iterator<P*>(a), input_iterator<P*>(a + sizeof(a)/sizeof(a[0])));
                 ^
2 errors generated.
insert_range.pass.cpp failed to compile
insert_rvalue.pass.cpp:37:10: fatal error: '../../MoveOnly.h' file not found
#include "../../MoveOnly.h"
         ^
1 error generated.
insert_rvalue.pass.cpp failed to compile
failed 6 tests in /test/containers/unord/unord.map/unorder.map.modifiers
passed 6 tests in /test/containers/unord/unord.map/unorder.map.modifiers
eq.pass.cpp:43:2: error: #error unordered_multimap == unordered_multimap not implemented
#error unordered_multimap == unordered_multimap not implemented
 ^
1 error generated.
eq.pass.cpp failed to compile
failed 1 tests in /test/containers/unord/unord.multimap
passed 19 tests in /test/containers/unord/unord.multimap
passed 24 tests in /test/containers/unord/unord.multimap/unord.multimap.cnstr
emplace.pass.cpp:36:10: fatal error: '../../Emplaceable.h' file not found
#include "../../Emplaceable.h"
         ^
1 error generated.
emplace.pass.cpp failed to compile
emplace_hint.pass.cpp:36:10: fatal error: '../../Emplaceable.h' file not found
#include "../../Emplaceable.h"
         ^
1 error generated.
emplace_hint.pass.cpp failed to compile
insert_hint_rvalue.pass.cpp:37:10: fatal error: '../../MoveOnly.h' file not found
#include "../../MoveOnly.h"
         ^
1 error generated.
insert_hint_rvalue.pass.cpp failed to compile
insert_init.pass.cpp:36:10: fatal error: '../../iterators.h' file not found
#include "../../iterators.h"
         ^
1 error generated.
insert_init.pass.cpp failed to compile
insert_range.pass.cpp:37:10: fatal error: '../../iterators.h' file not found
#include "../../iterators.h"
         ^
insert_range.pass.cpp:54:18: error: use of undeclared identifier 'input_iterator'
        c.insert(input_iterator<P*>(a), input_iterator<P*>(a + sizeof(a)/sizeof(a[0])));
                 ^
2 errors generated.
insert_range.pass.cpp failed to compile
insert_rvalue.pass.cpp:37:10: fatal error: '../../MoveOnly.h' file not found
#include "../../MoveOnly.h"
         ^
1 error generated.
insert_rvalue.pass.cpp failed to compile
failed 6 tests in /test/containers/unord/unord.multimap/unord.multimap.modifiers
passed 6 tests in /test/containers/unord/unord.multimap/unord.multimap.modifiers
passed 1 tests in /test/containers/unord/unord.multimap/unord.multimap.swap
eq.pass.cpp:43:2: error: #error unordered_multiset == unordered_multiset not implemented
#error unordered_multiset == unordered_multiset not implemented
 ^
1 error generated.
eq.pass.cpp failed to compile
failed 1 tests in /test/containers/unord/unord.multiset
passed 31 tests in /test/containers/unord/unord.multiset
passed 24 tests in /test/containers/unord/unord.multiset/unord.multiset.cnstr
passed 1 tests in /test/containers/unord/unord.multiset/unord.multiset.swap
eq.pass.cpp:43:2: error: #error unordered_set == unordered_set not implemented
#error unordered_set == unordered_set not implemented
 ^
1 error generated.
eq.pass.cpp failed to compile
failed 1 tests in /test/containers/unord/unord.set
passed 31 tests in /test/containers/unord/unord.set
passed 24 tests in /test/containers/unord/unord.set/unord.set.cnstr
passed 1 tests in /test/containers/unord/unord.set/unord.set.swap
passed 1 tests in /test/depr
passed 1 tests in /test/depr/depr.auto.ptr
passed 1 tests in /test/depr/depr.auto.ptr/auto.ptr
passed 10 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.cons
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.conv
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.members
inttypes_h.pass.cpp:274:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
inttypes_h.pass.cpp:278:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
inttypes_h.pass.cpp:282:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
inttypes_h.pass.cpp:286:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
inttypes_h.pass.cpp:290:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
inttypes_h.pass.cpp:294:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
inttypes_h.pass.cpp:298:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
inttypes_h.pass.cpp:302:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
inttypes_h.pass.cpp:306:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
inttypes_h.pass.cpp:310:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
inttypes_h.pass.cpp:314:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
inttypes_h.pass.cpp:318:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
inttypes_h.pass.cpp:322:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
inttypes_h.pass.cpp:326:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
inttypes_h.pass.cpp:330:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
inttypes_h.pass.cpp:334:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
inttypes_h.pass.cpp:338:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
inttypes_h.pass.cpp:342:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
inttypes_h.pass.cpp:346:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
inttypes_h.pass.cpp:350:2: error: #error PRIiLEAST16 not defined
#error PRIiLEAST16 not defined
 ^
inttypes_h.pass.cpp:354:2: error: #error PRIiLEAST32 not defined
#error PRIiLEAST32 not defined
 ^
inttypes_h.pass.cpp:358:2: error: #error PRIiLEAST64 not defined
#error PRIiLEAST64 not defined
 ^
inttypes_h.pass.cpp:362:2: error: #error PRIiFAST8 not defined
#error PRIiFAST8 not defined
 ^
inttypes_h.pass.cpp:366:2: error: #error PRIiFAST16 not defined
#error PRIiFAST16 not defined
 ^
inttypes_h.pass.cpp:370:2: error: #error PRIiFAST32 not defined
#error PRIiFAST32 not defined
 ^
inttypes_h.pass.cpp:374:2: error: #error PRIiFAST64 not defined
#error PRIiFAST64 not defined
 ^
inttypes_h.pass.cpp:378:2: error: #error PRIiMAX not defined
#error PRIiMAX not defined
 ^
inttypes_h.pass.cpp:382:2: error: #error PRIiPTR not defined
#error PRIiPTR not defined
 ^
inttypes_h.pass.cpp:386:2: error: #error PRIo8 not defined
#error PRIo8 not defined
 ^
inttypes_h.pass.cpp:390:2: error: #error PRIo16 not defined
#error PRIo16 not defined
 ^
inttypes_h.pass.cpp:394:2: error: #error PRIo32 not defined
#error PRIo32 not defined
 ^
inttypes_h.pass.cpp:398:2: error: #error PRIo64 not defined
#error PRIo64 not defined
 ^
inttypes_h.pass.cpp:402:2: error: #error PRIoLEAST8 not defined
#error PRIoLEAST8 not defined
 ^
inttypes_h.pass.cpp:406:2: error: #error PRIoLEAST16 not defined
#error PRIoLEAST16 not defined
 ^
inttypes_h.pass.cpp:410:2: error: #error PRIoLEAST32 not defined
#error PRIoLEAST32 not defined
 ^
inttypes_h.pass.cpp:414:2: error: #error PRIoLEAST64 not defined
#error PRIoLEAST64 not defined
 ^
inttypes_h.pass.cpp:418:2: error: #error PRIoFAST8 not defined
#error PRIoFAST8 not defined
 ^
inttypes_h.pass.cpp:422:2: error: #error PRIoFAST16 not defined
#error PRIoFAST16 not defined
 ^
inttypes_h.pass.cpp:426:2: error: #error PRIoFAST32 not defined
#error PRIoFAST32 not defined
 ^
inttypes_h.pass.cpp:430:2: error: #error PRIoFAST64 not defined
#error PRIoFAST64 not defined
 ^
inttypes_h.pass.cpp:434:2: error: #error PRIoMAX not defined
#error PRIoMAX not defined
 ^
inttypes_h.pass.cpp:438:2: error: #error PRIoPTR not defined
#error PRIoPTR not defined
 ^
inttypes_h.pass.cpp:442:2: error: #error PRIu8 not defined
#error PRIu8 not defined
 ^
inttypes_h.pass.cpp:446:2: error: #error PRIu16 not defined
#error PRIu16 not defined
 ^
inttypes_h.pass.cpp:450:2: error: #error PRIu32 not defined
#error PRIu32 not defined
 ^
inttypes_h.pass.cpp:454:2: error: #error PRIu64 not defined
#error PRIu64 not defined
 ^
inttypes_h.pass.cpp:458:2: error: #error PRIuLEAST8 not defined
#error PRIuLEAST8 not defined
 ^
inttypes_h.pass.cpp:462:2: error: #error PRIuLEAST16 not defined
#error PRIuLEAST16 not defined
 ^
inttypes_h.pass.cpp:466:2: error: #error PRIuLEAST32 not defined
#error PRIuLEAST32 not defined
 ^
inttypes_h.pass.cpp:470:2: error: #error PRIuLEAST64 not defined
#error PRIuLEAST64 not defined
 ^
inttypes_h.pass.cpp:474:2: error: #error PRIuFAST8 not defined
#error PRIuFAST8 not defined
 ^
inttypes_h.pass.cpp:478:2: error: #error PRIuFAST16 not defined
#error PRIuFAST16 not defined
 ^
inttypes_h.pass.cpp:482:2: error: #error PRIuFAST32 not defined
#error PRIuFAST32 not defined
 ^
inttypes_h.pass.cpp:486:2: error: #error PRIuFAST64 not defined
#error PRIuFAST64 not defined
 ^
inttypes_h.pass.cpp:490:2: error: #error PRIuMAX not defined
#error PRIuMAX not defined
 ^
inttypes_h.pass.cpp:494:2: error: #error PRIuPTR not defined
#error PRIuPTR not defined
 ^
inttypes_h.pass.cpp:498:2: error: #error PRIx8 not defined
#error PRIx8 not defined
 ^
inttypes_h.pass.cpp:502:2: error: #error PRIx16 not defined
#error PRIx16 not defined
 ^
inttypes_h.pass.cpp:506:2: error: #error PRIx32 not defined
#error PRIx32 not defined
 ^
inttypes_h.pass.cpp:510:2: error: #error PRIx64 not defined
#error PRIx64 not defined
 ^
inttypes_h.pass.cpp:514:2: error: #error PRIxLEAST8 not defined
#error PRIxLEAST8 not defined
 ^
inttypes_h.pass.cpp:518:2: error: #error PRIxLEAST16 not defined
#error PRIxLEAST16 not defined
 ^
inttypes_h.pass.cpp:522:2: error: #error PRIxLEAST32 not defined
#error PRIxLEAST32 not defined
 ^
inttypes_h.pass.cpp:526:2: error: #error PRIxLEAST64 not defined
#error PRIxLEAST64 not defined
 ^
inttypes_h.pass.cpp:530:2: error: #error PRIxFAST8 not defined
#error PRIxFAST8 not defined
 ^
inttypes_h.pass.cpp:534:2: error: #error PRIxFAST16 not defined
#error PRIxFAST16 not defined
 ^
inttypes_h.pass.cpp:538:2: error: #error PRIxFAST32 not defined
#error PRIxFAST32 not defined
 ^
inttypes_h.pass.cpp:542:2: error: #error PRIxFAST64 not defined
#error PRIxFAST64 not defined
 ^
inttypes_h.pass.cpp:546:2: error: #error PRIxMAX not defined
#error PRIxMAX not defined
 ^
inttypes_h.pass.cpp:550:2: error: #error PRIxPTR not defined
#error PRIxPTR not defined
 ^
inttypes_h.pass.cpp:554:2: error: #error PRIX8 not defined
#error PRIX8 not defined
 ^
inttypes_h.pass.cpp:558:2: error: #error PRIX16 not defined
#error PRIX16 not defined
 ^
inttypes_h.pass.cpp:562:2: error: #error PRIX32 not defined
#error PRIX32 not defined
 ^
inttypes_h.pass.cpp:566:2: error: #error PRIX64 not defined
#error PRIX64 not defined
 ^
inttypes_h.pass.cpp:570:2: error: #error PRIXLEAST8 not defined
#error PRIXLEAST8 not defined
 ^
inttypes_h.pass.cpp:574:2: error: #error PRIXLEAST16 not defined
#error PRIXLEAST16 not defined
 ^
inttypes_h.pass.cpp:578:2: error: #error PRIXLEAST32 not defined
#error PRIXLEAST32 not defined
 ^
inttypes_h.pass.cpp:582:2: error: #error PRIXLEAST64 not defined
#error PRIXLEAST64 not defined
 ^
inttypes_h.pass.cpp:586:2: error: #error PRIXFAST8 not defined
#error PRIXFAST8 not defined
 ^
inttypes_h.pass.cpp:590:2: error: #error PRIXFAST16 not defined
#error PRIXFAST16 not defined
 ^
inttypes_h.pass.cpp:594:2: error: #error PRIXFAST32 not defined
#error PRIXFAST32 not defined
 ^
inttypes_h.pass.cpp:598:2: error: #error PRIXFAST64 not defined
#error PRIXFAST64 not defined
 ^
inttypes_h.pass.cpp:602:2: error: #error PRIXMAX not defined
#error PRIXMAX not defined
 ^
inttypes_h.pass.cpp:606:2: error: #error PRIXPTR not defined
#error PRIXPTR not defined
 ^
inttypes_h.pass.cpp:610:2: error: #error SCNd8 not defined
#error SCNd8 not defined
 ^
inttypes_h.pass.cpp:614:2: error: #error SCNd16 not defined
#error SCNd16 not defined
 ^
inttypes_h.pass.cpp:618:2: error: #error SCNd32 not defined
#error SCNd32 not defined
 ^
inttypes_h.pass.cpp:622:2: error: #error SCNd64 not defined
#error SCNd64 not defined
 ^
inttypes_h.pass.cpp:626:2: error: #error SCNdLEAST8 not defined
#error SCNdLEAST8 not defined
 ^
inttypes_h.pass.cpp:630:2: error: #error SCNdLEAST16 not defined
#error SCNdLEAST16 not defined
 ^
inttypes_h.pass.cpp:634:2: error: #error SCNdLEAST32 not defined
#error SCNdLEAST32 not defined
 ^
inttypes_h.pass.cpp:638:2: error: #error SCNdLEAST64 not defined
#error SCNdLEAST64 not defined
 ^
inttypes_h.pass.cpp:642:2: error: #error SCNdFAST8 not defined
#error SCNdFAST8 not defined
 ^
inttypes_h.pass.cpp:646:2: error: #error SCNdFAST16 not defined
#error SCNdFAST16 not defined
 ^
inttypes_h.pass.cpp:650:2: error: #error SCNdFAST32 not defined
#error SCNdFAST32 not defined
 ^
inttypes_h.pass.cpp:654:2: error: #error SCNdFAST64 not defined
#error SCNdFAST64 not defined
 ^
inttypes_h.pass.cpp:658:2: error: #error SCNdMAX not defined
#error SCNdMAX not defined
 ^
inttypes_h.pass.cpp:662:2: error: #error SCNdPTR not defined
#error SCNdPTR not defined
 ^
inttypes_h.pass.cpp:666:2: error: #error SCNi8 not defined
#error SCNi8 not defined
 ^
inttypes_h.pass.cpp:670:2: error: #error SCNi16 not defined
#error SCNi16 not defined
 ^
inttypes_h.pass.cpp:674:2: error: #error SCNi32 not defined
#error SCNi32 not defined
 ^
inttypes_h.pass.cpp:678:2: error: #error SCNi64 not defined
#error SCNi64 not defined
 ^
inttypes_h.pass.cpp:682:2: error: #error SCNiLEAST8 not defined
#error SCNiLEAST8 not defined
 ^
inttypes_h.pass.cpp:686:2: error: #error SCNiLEAST16 not defined
#error SCNiLEAST16 not defined
 ^
inttypes_h.pass.cpp:690:2: error: #error SCNiLEAST32 not defined
#error SCNiLEAST32 not defined
 ^
inttypes_h.pass.cpp:694:2: error: #error SCNiLEAST64 not defined
#error SCNiLEAST64 not defined
 ^
inttypes_h.pass.cpp:698:2: error: #error SCNiFAST8 not defined
#error SCNiFAST8 not defined
 ^
inttypes_h.pass.cpp:702:2: error: #error SCNiFAST16 not defined
#error SCNiFAST16 not defined
 ^
inttypes_h.pass.cpp:706:2: error: #error SCNiFAST32 not defined
#error SCNiFAST32 not defined
 ^
inttypes_h.pass.cpp:710:2: error: #error SCNiFAST64 not defined
#error SCNiFAST64 not defined
 ^
inttypes_h.pass.cpp:714:2: error: #error SCNiMAX not defined
#error SCNiMAX not defined
 ^
inttypes_h.pass.cpp:718:2: error: #error SCNiPTR not defined
#error SCNiPTR not defined
 ^
inttypes_h.pass.cpp:722:2: error: #error SCNo8 not defined
#error SCNo8 not defined
 ^
inttypes_h.pass.cpp:726:2: error: #error SCNo16 not defined
#error SCNo16 not defined
 ^
inttypes_h.pass.cpp:730:2: error: #error SCNo32 not defined
#error SCNo32 not defined
 ^
inttypes_h.pass.cpp:734:2: error: #error SCNo64 not defined
#error SCNo64 not defined
 ^
inttypes_h.pass.cpp:738:2: error: #error SCNoLEAST8 not defined
#error SCNoLEAST8 not defined
 ^
inttypes_h.pass.cpp:742:2: error: #error SCNoLEAST16 not defined
#error SCNoLEAST16 not defined
 ^
inttypes_h.pass.cpp:746:2: error: #error SCNoLEAST32 not defined
#error SCNoLEAST32 not defined
 ^
inttypes_h.pass.cpp:750:2: error: #error SCNoLEAST64 not defined
#error SCNoLEAST64 not defined
 ^
inttypes_h.pass.cpp:754:2: error: #error SCNoFAST8 not defined
#error SCNoFAST8 not defined
 ^
inttypes_h.pass.cpp:758:2: error: #error SCNoFAST16 not defined
#error SCNoFAST16 not defined
 ^
inttypes_h.pass.cpp:762:2: error: #error SCNoFAST32 not defined
#error SCNoFAST32 not defined
 ^
inttypes_h.pass.cpp:766:2: error: #error SCNoFAST64 not defined
#error SCNoFAST64 not defined
 ^
inttypes_h.pass.cpp:770:2: error: #error SCNoMAX not defined
#error SCNoMAX not defined
 ^
inttypes_h.pass.cpp:774:2: error: #error SCNoPTR not defined
#error SCNoPTR not defined
 ^
inttypes_h.pass.cpp:778:2: error: #error SCNu8 not defined
#error SCNu8 not defined
 ^
inttypes_h.pass.cpp:782:2: error: #error SCNu16 not defined
#error SCNu16 not defined
 ^
inttypes_h.pass.cpp:786:2: error: #error SCNu32 not defined
#error SCNu32 not defined
 ^
inttypes_h.pass.cpp:790:2: error: #error SCNu64 not defined
#error SCNu64 not defined
 ^
inttypes_h.pass.cpp:794:2: error: #error SCNuLEAST8 not defined
#error SCNuLEAST8 not defined
 ^
inttypes_h.pass.cpp:798:2: error: #error SCNuLEAST16 not defined
#error SCNuLEAST16 not defined
 ^
inttypes_h.pass.cpp:802:2: error: #error SCNuLEAST32 not defined
#error SCNuLEAST32 not defined
 ^
inttypes_h.pass.cpp:806:2: error: #error SCNuLEAST64 not defined
#error SCNuLEAST64 not defined
 ^
inttypes_h.pass.cpp:810:2: error: #error SCNuFAST8 not defined
#error SCNuFAST8 not defined
 ^
inttypes_h.pass.cpp:814:2: error: #error SCNuFAST16 not defined
#error SCNuFAST16 not defined
 ^
inttypes_h.pass.cpp:818:2: error: #error SCNuFAST32 not defined
#error SCNuFAST32 not defined
 ^
inttypes_h.pass.cpp:822:2: error: #error SCNuFAST64 not defined
#error SCNuFAST64 not defined
 ^
inttypes_h.pass.cpp:826:2: error: #error SCNuMAX not defined
#error SCNuMAX not defined
 ^
inttypes_h.pass.cpp:830:2: error: #error SCNuPTR not defined
#error SCNuPTR not defined
 ^
inttypes_h.pass.cpp:834:2: error: #error SCNx8 not defined
#error SCNx8 not defined
 ^
inttypes_h.pass.cpp:838:2: error: #error SCNx16 not defined
#error SCNx16 not defined
 ^
inttypes_h.pass.cpp:842:2: error: #error SCNx32 not defined
#error SCNx32 not defined
 ^
inttypes_h.pass.cpp:846:2: error: #error SCNx64 not defined
#error SCNx64 not defined
 ^
inttypes_h.pass.cpp:850:2: error: #error SCNxLEAST8 not defined
#error SCNxLEAST8 not defined
 ^
inttypes_h.pass.cpp:854:2: error: #error SCNxLEAST16 not defined
#error SCNxLEAST16 not defined
 ^
inttypes_h.pass.cpp:858:2: error: #error SCNxLEAST32 not defined
#error SCNxLEAST32 not defined
 ^
inttypes_h.pass.cpp:862:2: error: #error SCNxLEAST64 not defined
#error SCNxLEAST64 not defined
 ^
inttypes_h.pass.cpp:866:2: error: #error SCNxFAST8 not defined
#error SCNxFAST8 not defined
 ^
inttypes_h.pass.cpp:870:2: error: #error SCNxFAST16 not defined
#error SCNxFAST16 not defined
 ^
inttypes_h.pass.cpp:874:2: error: #error SCNxFAST32 not defined
#error SCNxFAST32 not defined
 ^
inttypes_h.pass.cpp:878:2: error: #error SCNxFAST64 not defined
#error SCNxFAST64 not defined
 ^
inttypes_h.pass.cpp:882:2: error: #error SCNxMAX not defined
#error SCNxMAX not defined
 ^
inttypes_h.pass.cpp:886:2: error: #error SCNxPTR not defined
#error SCNxPTR not defined
 ^
154 errors generated.
inttypes_h.pass.cpp failed to compile
math_h.pass.cpp:545:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(nextafter(0,1) == 0x1p-1074);
    ^
math_h.pass.cpp:545:30: note: instantiated from:
    assert(nextafter(0,1) == 0x1p-1074);
                             ^
math_h.pass.cpp:553:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(nexttoward(0, 1) == 0x1p-1074);
    ^
math_h.pass.cpp:553:32: note: instantiated from:
    assert(nexttoward(0, 1) == 0x1p-1074);
                               ^
2 warnings generated.
stdio_h.pass.cpp:111:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:111:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:111:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:112:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:112:33: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:112:53: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:114:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:114:33: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:114:49: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                                ^~
stdio_h.pass.cpp:116:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:116:33: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:116:56: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                                       ^~
stdio_h.pass.cpp:117:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:117:33: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:117:53: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:119:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:119:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:119:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:121:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:121:33: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:121:50: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                                 ^~
stdio_h.pass.cpp:123:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:123:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:123:57: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                                        ^~
stdio_h.pass.cpp:124:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:124:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:124:54: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                                     ^~
9 warnings generated.
uchar_h.pass.cpp:26:10: fatal error: 'uchar.h' file not found
#include <uchar.h>
         ^
1 error generated.
uchar_h.pass.cpp failed to compile
failed 2 tests in /test/depr/depr.c.headers
passed 24 tests in /test/depr/depr.c.headers
passed 5 tests in /test/depr/depr.ios.members
passed 1 tests in /test/depr/depr.lib.binders
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.2nd
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.2nd
passed 1 tests in /test/depr/depr.str.strstreams
passed 1 tests in /test/depr/depr.str.strstreams/depr.istrstream
./testit: line 96: 20710 Abort trap              ./a.out
ccp.pass.cpp failed at run time
./testit: line 96: 20737 Abort trap              ./a.out
ccp_size.pass.cpp failed at run time
./testit: line 96: 20755 Abort trap              ./a.out
cp.pass.cpp failed at run time
./testit: line 96: 20762 Abort trap              ./a.out
cp_size.pass.cpp failed at run time
failed 4 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.cons
./testit: line 96: 20773 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 20780 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.ostrstream
./testit: line 96: 20804 Abort trap              ./a.out
cp_size_mode.pass.cpp failed at run time
./testit: line 96: 20811 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.cons
./testit: line 96: 20822 Abort trap              ./a.out
freeze.pass.cpp failed at run time
./testit: line 96: 20829 Abort trap              ./a.out
pcount.pass.cpp failed at run time
./testit: line 96: 20836 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 20843 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 4 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstream
./testit: line 96: 20865 Abort trap              ./a.out
cp_size_mode.pass.cpp failed at run time
./testit: line 96: 20872 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.cons
./testit: line 96: 20883 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 1 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.dest
./testit: line 96: 20894 Abort trap              ./a.out
freeze.pass.cpp failed at run time
./testit: line 96: 20901 Abort trap              ./a.out
pcount.pass.cpp failed at run time
./testit: line 96: 20908 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 3 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.oper
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstreambuf
passed 8 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.cons
passed 3 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.members
passed 6 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.virtuals
passed 1 tests in /test/diagnostics
passed 1 tests in /test/diagnostics/assertions
passed 1 tests in /test/diagnostics/diagnostics.general
passed 1 tests in /test/diagnostics/errno
passed 1 tests in /test/diagnostics/std.exceptions
passed 1 tests in /test/diagnostics/std.exceptions/domain.error
passed 1 tests in /test/diagnostics/std.exceptions/invalid.argument
passed 1 tests in /test/diagnostics/std.exceptions/length.error
passed 1 tests in /test/diagnostics/std.exceptions/logic.error
passed 1 tests in /test/diagnostics/std.exceptions/out.of.range
passed 1 tests in /test/diagnostics/std.exceptions/overflow.error
passed 1 tests in /test/diagnostics/std.exceptions/range.error
passed 1 tests in /test/diagnostics/std.exceptions/runtime.error
passed 1 tests in /test/diagnostics/std.exceptions/underflow.error
passed 1 tests in /test/diagnostics/syserr
passed 1 tests in /test/diagnostics/syserr/syserr.compare
passed 1 tests in /test/diagnostics/syserr/syserr.errcat
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.derived
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.nonvirtuals
passed 2 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.objects
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.overview
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.virtuals
passed 1 tests in /test/diagnostics/syserr/syserr.errcode
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.modifiers
./testit: line 96: 21416 Abort trap              ./a.out
stream_inserter.pass.cpp failed at run time
failed 1 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.nonmembers
passed 2 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.nonmembers
passed 5 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.overview
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.modifiers
passed 2 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.nonmembers
passed 4 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.overview
passed 1 tests in /test/diagnostics/syserr/syserr.hash
passed 1 tests in /test/diagnostics/syserr/syserr.syserr
passed 6 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.members
passed 1 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.overview
passed 1 tests in /test/input.output
passed 1 tests in /test/input.output/file.streams
cinttypes.pass.cpp:274:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
cinttypes.pass.cpp:278:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
cinttypes.pass.cpp:282:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
cinttypes.pass.cpp:286:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
cinttypes.pass.cpp:290:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
cinttypes.pass.cpp:294:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
cinttypes.pass.cpp:298:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
cinttypes.pass.cpp:302:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
cinttypes.pass.cpp:306:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
cinttypes.pass.cpp:310:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
cinttypes.pass.cpp:314:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
cinttypes.pass.cpp:318:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
cinttypes.pass.cpp:322:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
cinttypes.pass.cpp:326:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
cinttypes.pass.cpp:330:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
cinttypes.pass.cpp:334:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
cinttypes.pass.cpp:338:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
cinttypes.pass.cpp:342:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
cinttypes.pass.cpp:346:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
cinttypes.pass.cpp:350:2: error: #error PRIiLEAST16 not defined
#error PRIiLEAST16 not defined
 ^
cinttypes.pass.cpp:354:2: error: #error PRIiLEAST32 not defined
#error PRIiLEAST32 not defined
 ^
cinttypes.pass.cpp:358:2: error: #error PRIiLEAST64 not defined
#error PRIiLEAST64 not defined
 ^
cinttypes.pass.cpp:362:2: error: #error PRIiFAST8 not defined
#error PRIiFAST8 not defined
 ^
cinttypes.pass.cpp:366:2: error: #error PRIiFAST16 not defined
#error PRIiFAST16 not defined
 ^
cinttypes.pass.cpp:370:2: error: #error PRIiFAST32 not defined
#error PRIiFAST32 not defined
 ^
cinttypes.pass.cpp:374:2: error: #error PRIiFAST64 not defined
#error PRIiFAST64 not defined
 ^
cinttypes.pass.cpp:378:2: error: #error PRIiMAX not defined
#error PRIiMAX not defined
 ^
cinttypes.pass.cpp:382:2: error: #error PRIiPTR not defined
#error PRIiPTR not defined
 ^
cinttypes.pass.cpp:386:2: error: #error PRIo8 not defined
#error PRIo8 not defined
 ^
cinttypes.pass.cpp:390:2: error: #error PRIo16 not defined
#error PRIo16 not defined
 ^
cinttypes.pass.cpp:394:2: error: #error PRIo32 not defined
#error PRIo32 not defined
 ^
cinttypes.pass.cpp:398:2: error: #error PRIo64 not defined
#error PRIo64 not defined
 ^
cinttypes.pass.cpp:402:2: error: #error PRIoLEAST8 not defined
#error PRIoLEAST8 not defined
 ^
cinttypes.pass.cpp:406:2: error: #error PRIoLEAST16 not defined
#error PRIoLEAST16 not defined
 ^
cinttypes.pass.cpp:410:2: error: #error PRIoLEAST32 not defined
#error PRIoLEAST32 not defined
 ^
cinttypes.pass.cpp:414:2: error: #error PRIoLEAST64 not defined
#error PRIoLEAST64 not defined
 ^
cinttypes.pass.cpp:418:2: error: #error PRIoFAST8 not defined
#error PRIoFAST8 not defined
 ^
cinttypes.pass.cpp:422:2: error: #error PRIoFAST16 not defined
#error PRIoFAST16 not defined
 ^
cinttypes.pass.cpp:426:2: error: #error PRIoFAST32 not defined
#error PRIoFAST32 not defined
 ^
cinttypes.pass.cpp:430:2: error: #error PRIoFAST64 not defined
#error PRIoFAST64 not defined
 ^
cinttypes.pass.cpp:434:2: error: #error PRIoMAX not defined
#error PRIoMAX not defined
 ^
cinttypes.pass.cpp:438:2: error: #error PRIoPTR not defined
#error PRIoPTR not defined
 ^
cinttypes.pass.cpp:442:2: error: #error PRIu8 not defined
#error PRIu8 not defined
 ^
cinttypes.pass.cpp:446:2: error: #error PRIu16 not defined
#error PRIu16 not defined
 ^
cinttypes.pass.cpp:450:2: error: #error PRIu32 not defined
#error PRIu32 not defined
 ^
cinttypes.pass.cpp:454:2: error: #error PRIu64 not defined
#error PRIu64 not defined
 ^
cinttypes.pass.cpp:458:2: error: #error PRIuLEAST8 not defined
#error PRIuLEAST8 not defined
 ^
cinttypes.pass.cpp:462:2: error: #error PRIuLEAST16 not defined
#error PRIuLEAST16 not defined
 ^
cinttypes.pass.cpp:466:2: error: #error PRIuLEAST32 not defined
#error PRIuLEAST32 not defined
 ^
cinttypes.pass.cpp:470:2: error: #error PRIuLEAST64 not defined
#error PRIuLEAST64 not defined
 ^
cinttypes.pass.cpp:474:2: error: #error PRIuFAST8 not defined
#error PRIuFAST8 not defined
 ^
cinttypes.pass.cpp:478:2: error: #error PRIuFAST16 not defined
#error PRIuFAST16 not defined
 ^
cinttypes.pass.cpp:482:2: error: #error PRIuFAST32 not defined
#error PRIuFAST32 not defined
 ^
cinttypes.pass.cpp:486:2: error: #error PRIuFAST64 not defined
#error PRIuFAST64 not defined
 ^
cinttypes.pass.cpp:490:2: error: #error PRIuMAX not defined
#error PRIuMAX not defined
 ^
cinttypes.pass.cpp:494:2: error: #error PRIuPTR not defined
#error PRIuPTR not defined
 ^
cinttypes.pass.cpp:498:2: error: #error PRIx8 not defined
#error PRIx8 not defined
 ^
cinttypes.pass.cpp:502:2: error: #error PRIx16 not defined
#error PRIx16 not defined
 ^
cinttypes.pass.cpp:506:2: error: #error PRIx32 not defined
#error PRIx32 not defined
 ^
cinttypes.pass.cpp:510:2: error: #error PRIx64 not defined
#error PRIx64 not defined
 ^
cinttypes.pass.cpp:514:2: error: #error PRIxLEAST8 not defined
#error PRIxLEAST8 not defined
 ^
cinttypes.pass.cpp:518:2: error: #error PRIxLEAST16 not defined
#error PRIxLEAST16 not defined
 ^
cinttypes.pass.cpp:522:2: error: #error PRIxLEAST32 not defined
#error PRIxLEAST32 not defined
 ^
cinttypes.pass.cpp:526:2: error: #error PRIxLEAST64 not defined
#error PRIxLEAST64 not defined
 ^
cinttypes.pass.cpp:530:2: error: #error PRIxFAST8 not defined
#error PRIxFAST8 not defined
 ^
cinttypes.pass.cpp:534:2: error: #error PRIxFAST16 not defined
#error PRIxFAST16 not defined
 ^
cinttypes.pass.cpp:538:2: error: #error PRIxFAST32 not defined
#error PRIxFAST32 not defined
 ^
cinttypes.pass.cpp:542:2: error: #error PRIxFAST64 not defined
#error PRIxFAST64 not defined
 ^
cinttypes.pass.cpp:546:2: error: #error PRIxMAX not defined
#error PRIxMAX not defined
 ^
cinttypes.pass.cpp:550:2: error: #error PRIxPTR not defined
#error PRIxPTR not defined
 ^
cinttypes.pass.cpp:554:2: error: #error PRIX8 not defined
#error PRIX8 not defined
 ^
cinttypes.pass.cpp:558:2: error: #error PRIX16 not defined
#error PRIX16 not defined
 ^
cinttypes.pass.cpp:562:2: error: #error PRIX32 not defined
#error PRIX32 not defined
 ^
cinttypes.pass.cpp:566:2: error: #error PRIX64 not defined
#error PRIX64 not defined
 ^
cinttypes.pass.cpp:570:2: error: #error PRIXLEAST8 not defined
#error PRIXLEAST8 not defined
 ^
cinttypes.pass.cpp:574:2: error: #error PRIXLEAST16 not defined
#error PRIXLEAST16 not defined
 ^
cinttypes.pass.cpp:578:2: error: #error PRIXLEAST32 not defined
#error PRIXLEAST32 not defined
 ^
cinttypes.pass.cpp:582:2: error: #error PRIXLEAST64 not defined
#error PRIXLEAST64 not defined
 ^
cinttypes.pass.cpp:586:2: error: #error PRIXFAST8 not defined
#error PRIXFAST8 not defined
 ^
cinttypes.pass.cpp:590:2: error: #error PRIXFAST16 not defined
#error PRIXFAST16 not defined
 ^
cinttypes.pass.cpp:594:2: error: #error PRIXFAST32 not defined
#error PRIXFAST32 not defined
 ^
cinttypes.pass.cpp:598:2: error: #error PRIXFAST64 not defined
#error PRIXFAST64 not defined
 ^
cinttypes.pass.cpp:602:2: error: #error PRIXMAX not defined
#error PRIXMAX not defined
 ^
cinttypes.pass.cpp:606:2: error: #error PRIXPTR not defined
#error PRIXPTR not defined
 ^
cinttypes.pass.cpp:610:2: error: #error SCNd8 not defined
#error SCNd8 not defined
 ^
cinttypes.pass.cpp:614:2: error: #error SCNd16 not defined
#error SCNd16 not defined
 ^
cinttypes.pass.cpp:618:2: error: #error SCNd32 not defined
#error SCNd32 not defined
 ^
cinttypes.pass.cpp:622:2: error: #error SCNd64 not defined
#error SCNd64 not defined
 ^
cinttypes.pass.cpp:626:2: error: #error SCNdLEAST8 not defined
#error SCNdLEAST8 not defined
 ^
cinttypes.pass.cpp:630:2: error: #error SCNdLEAST16 not defined
#error SCNdLEAST16 not defined
 ^
cinttypes.pass.cpp:634:2: error: #error SCNdLEAST32 not defined
#error SCNdLEAST32 not defined
 ^
cinttypes.pass.cpp:638:2: error: #error SCNdLEAST64 not defined
#error SCNdLEAST64 not defined
 ^
cinttypes.pass.cpp:642:2: error: #error SCNdFAST8 not defined
#error SCNdFAST8 not defined
 ^
cinttypes.pass.cpp:646:2: error: #error SCNdFAST16 not defined
#error SCNdFAST16 not defined
 ^
cinttypes.pass.cpp:650:2: error: #error SCNdFAST32 not defined
#error SCNdFAST32 not defined
 ^
cinttypes.pass.cpp:654:2: error: #error SCNdFAST64 not defined
#error SCNdFAST64 not defined
 ^
cinttypes.pass.cpp:658:2: error: #error SCNdMAX not defined
#error SCNdMAX not defined
 ^
cinttypes.pass.cpp:662:2: error: #error SCNdPTR not defined
#error SCNdPTR not defined
 ^
cinttypes.pass.cpp:666:2: error: #error SCNi8 not defined
#error SCNi8 not defined
 ^
cinttypes.pass.cpp:670:2: error: #error SCNi16 not defined
#error SCNi16 not defined
 ^
cinttypes.pass.cpp:674:2: error: #error SCNi32 not defined
#error SCNi32 not defined
 ^
cinttypes.pass.cpp:678:2: error: #error SCNi64 not defined
#error SCNi64 not defined
 ^
cinttypes.pass.cpp:682:2: error: #error SCNiLEAST8 not defined
#error SCNiLEAST8 not defined
 ^
cinttypes.pass.cpp:686:2: error: #error SCNiLEAST16 not defined
#error SCNiLEAST16 not defined
 ^
cinttypes.pass.cpp:690:2: error: #error SCNiLEAST32 not defined
#error SCNiLEAST32 not defined
 ^
cinttypes.pass.cpp:694:2: error: #error SCNiLEAST64 not defined
#error SCNiLEAST64 not defined
 ^
cinttypes.pass.cpp:698:2: error: #error SCNiFAST8 not defined
#error SCNiFAST8 not defined
 ^
cinttypes.pass.cpp:702:2: error: #error SCNiFAST16 not defined
#error SCNiFAST16 not defined
 ^
cinttypes.pass.cpp:706:2: error: #error SCNiFAST32 not defined
#error SCNiFAST32 not defined
 ^
cinttypes.pass.cpp:710:2: error: #error SCNiFAST64 not defined
#error SCNiFAST64 not defined
 ^
cinttypes.pass.cpp:714:2: error: #error SCNiMAX not defined
#error SCNiMAX not defined
 ^
cinttypes.pass.cpp:718:2: error: #error SCNiPTR not defined
#error SCNiPTR not defined
 ^
cinttypes.pass.cpp:722:2: error: #error SCNo8 not defined
#error SCNo8 not defined
 ^
cinttypes.pass.cpp:726:2: error: #error SCNo16 not defined
#error SCNo16 not defined
 ^
cinttypes.pass.cpp:730:2: error: #error SCNo32 not defined
#error SCNo32 not defined
 ^
cinttypes.pass.cpp:734:2: error: #error SCNo64 not defined
#error SCNo64 not defined
 ^
cinttypes.pass.cpp:738:2: error: #error SCNoLEAST8 not defined
#error SCNoLEAST8 not defined
 ^
cinttypes.pass.cpp:742:2: error: #error SCNoLEAST16 not defined
#error SCNoLEAST16 not defined
 ^
cinttypes.pass.cpp:746:2: error: #error SCNoLEAST32 not defined
#error SCNoLEAST32 not defined
 ^
cinttypes.pass.cpp:750:2: error: #error SCNoLEAST64 not defined
#error SCNoLEAST64 not defined
 ^
cinttypes.pass.cpp:754:2: error: #error SCNoFAST8 not defined
#error SCNoFAST8 not defined
 ^
cinttypes.pass.cpp:758:2: error: #error SCNoFAST16 not defined
#error SCNoFAST16 not defined
 ^
cinttypes.pass.cpp:762:2: error: #error SCNoFAST32 not defined
#error SCNoFAST32 not defined
 ^
cinttypes.pass.cpp:766:2: error: #error SCNoFAST64 not defined
#error SCNoFAST64 not defined
 ^
cinttypes.pass.cpp:770:2: error: #error SCNoMAX not defined
#error SCNoMAX not defined
 ^
cinttypes.pass.cpp:774:2: error: #error SCNoPTR not defined
#error SCNoPTR not defined
 ^
cinttypes.pass.cpp:778:2: error: #error SCNu8 not defined
#error SCNu8 not defined
 ^
cinttypes.pass.cpp:782:2: error: #error SCNu16 not defined
#error SCNu16 not defined
 ^
cinttypes.pass.cpp:786:2: error: #error SCNu32 not defined
#error SCNu32 not defined
 ^
cinttypes.pass.cpp:790:2: error: #error SCNu64 not defined
#error SCNu64 not defined
 ^
cinttypes.pass.cpp:794:2: error: #error SCNuLEAST8 not defined
#error SCNuLEAST8 not defined
 ^
cinttypes.pass.cpp:798:2: error: #error SCNuLEAST16 not defined
#error SCNuLEAST16 not defined
 ^
cinttypes.pass.cpp:802:2: error: #error SCNuLEAST32 not defined
#error SCNuLEAST32 not defined
 ^
cinttypes.pass.cpp:806:2: error: #error SCNuLEAST64 not defined
#error SCNuLEAST64 not defined
 ^
cinttypes.pass.cpp:810:2: error: #error SCNuFAST8 not defined
#error SCNuFAST8 not defined
 ^
cinttypes.pass.cpp:814:2: error: #error SCNuFAST16 not defined
#error SCNuFAST16 not defined
 ^
cinttypes.pass.cpp:818:2: error: #error SCNuFAST32 not defined
#error SCNuFAST32 not defined
 ^
cinttypes.pass.cpp:822:2: error: #error SCNuFAST64 not defined
#error SCNuFAST64 not defined
 ^
cinttypes.pass.cpp:826:2: error: #error SCNuMAX not defined
#error SCNuMAX not defined
 ^
cinttypes.pass.cpp:830:2: error: #error SCNuPTR not defined
#error SCNuPTR not defined
 ^
cinttypes.pass.cpp:834:2: error: #error SCNx8 not defined
#error SCNx8 not defined
 ^
cinttypes.pass.cpp:838:2: error: #error SCNx16 not defined
#error SCNx16 not defined
 ^
cinttypes.pass.cpp:842:2: error: #error SCNx32 not defined
#error SCNx32 not defined
 ^
cinttypes.pass.cpp:846:2: error: #error SCNx64 not defined
#error SCNx64 not defined
 ^
cinttypes.pass.cpp:850:2: error: #error SCNxLEAST8 not defined
#error SCNxLEAST8 not defined
 ^
cinttypes.pass.cpp:854:2: error: #error SCNxLEAST16 not defined
#error SCNxLEAST16 not defined
 ^
cinttypes.pass.cpp:858:2: error: #error SCNxLEAST32 not defined
#error SCNxLEAST32 not defined
 ^
cinttypes.pass.cpp:862:2: error: #error SCNxLEAST64 not defined
#error SCNxLEAST64 not defined
 ^
cinttypes.pass.cpp:866:2: error: #error SCNxFAST8 not defined
#error SCNxFAST8 not defined
 ^
cinttypes.pass.cpp:870:2: error: #error SCNxFAST16 not defined
#error SCNxFAST16 not defined
 ^
cinttypes.pass.cpp:874:2: error: #error SCNxFAST32 not defined
#error SCNxFAST32 not defined
 ^
cinttypes.pass.cpp:878:2: error: #error SCNxFAST64 not defined
#error SCNxFAST64 not defined
 ^
cinttypes.pass.cpp:882:2: error: #error SCNxMAX not defined
#error SCNxMAX not defined
 ^
cinttypes.pass.cpp:886:2: error: #error SCNxPTR not defined
#error SCNxPTR not defined
 ^
154 errors generated.
cinttypes.pass.cpp failed to compile
cstdio.pass.cpp:111:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:111:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:111:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:112:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:112:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:112:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:114:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:114:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:114:54: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                                     ^~
cstdio.pass.cpp:116:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:116:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:116:61: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                                            ^~
cstdio.pass.cpp:117:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:117:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:117:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:119:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:119:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:119:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:121:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:121:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:121:55: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                                      ^~
cstdio.pass.cpp:123:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:123:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:123:62: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                                             ^~
cstdio.pass.cpp:124:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:124:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:124:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                                          ^~
9 warnings generated.
failed 1 tests in /test/input.output/file.streams/c.files
passed 1 tests in /test/input.output/file.streams/c.files
passed 1 tests in /test/input.output/file.streams/fstreams
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf
./testit: line 96: 21745 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 21759 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/filebuf.assign
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf.assign
./testit: line 96: 21771 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 1 tests in /test/input.output/file.streams/fstreams/filebuf.cons
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf.cons
./testit: line 96: 21790 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
failed 1 tests in /test/input.output/file.streams/fstreams/filebuf.members
./testit: line 96: 21801 Abort trap              ./a.out
overflow.pass.cpp failed at run time
./testit: line 96: 21808 Abort trap              ./a.out
pbackfail.pass.cpp failed at run time
./testit: line 96: 21815 Abort trap              ./a.out
seekoff.pass.cpp failed at run time
./testit: line 96: 21822 Abort trap              ./a.out
underflow.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/filebuf.virtuals
passed 1 tests in /test/input.output/file.streams/fstreams/fstream
./testit: line 96: 21844 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 21858 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/fstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/fstream.assign
./testit: line 96: 21871 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 21885 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 21892 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/fstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/fstream.cons
./testit: line 96: 21904 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 21911 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 21918 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 21925 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/fstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream
./testit: line 96: 21947 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 21961 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/ifstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream.assign
./testit: line 96: 21973 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 21987 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 21995 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/ifstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream.cons
./testit: line 96: 22009 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 22020 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 22027 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 22035 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/ifstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream
./testit: line 96: 22057 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 22072 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/ofstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream.assign
./testit: line 96: 22085 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 22099 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 22106 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/ofstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream.cons
./testit: line 96: 22119 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 22126 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 22133 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 22140 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/ofstream.members
passed 1 tests in /test/input.output/input.output.general
passed 1 tests in /test/input.output/iostream.format
./testit: line 96: 22173 Abort trap              ./a.out
get_money.pass.cpp failed at run time
./testit: line 96: 22180 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 22187 Abort trap              ./a.out
put_money.pass.cpp failed at run time
./testit: line 96: 22194 Abort trap              ./a.out
put_time.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostream.format/ext.manip
passed 1 tests in /test/input.output/iostream.format/input.streams
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass
./testit: line 96: 22227 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.assign
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.assign
./testit: line 96: 22253 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.dest
passed 1 tests in /test/input.output/iostream.format/input.streams/istream
./testit: line 96: 22287 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.assign
passed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.assign
./testit: line 96: 22313 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.cons
./testit: line 96: 22325 Abort trap              ./a.out
ctor.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream::sentry
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted
./testit: line 96: 22347 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 22354 Abort trap              ./a.out
double.pass.cpp failed at run time
./testit: line 96: 22361 Abort trap              ./a.out
float.pass.cpp failed at run time
./testit: line 96: 22368 Abort trap              ./a.out
int.pass.cpp failed at run time
./testit: line 96: 22375 Abort trap              ./a.out
long.pass.cpp failed at run time
./testit: line 96: 22382 Abort trap              ./a.out
long_double.pass.cpp failed at run time
./testit: line 96: 22389 Abort trap              ./a.out
long_long.pass.cpp failed at run time
./testit: line 96: 22396 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 22403 Abort trap              ./a.out
short.pass.cpp failed at run time
./testit: line 96: 22410 Abort trap              ./a.out
unsigned_int.pass.cpp failed at run time
./testit: line 96: 22417 Abort trap              ./a.out
unsigned_long.pass.cpp failed at run time
./testit: line 96: 22425 Abort trap              ./a.out
unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 22435 Abort trap              ./a.out
unsigned_short.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.arithmetic
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.reqmts
./testit: line 96: 22457 Abort trap              ./a.out
basic_ios.pass.cpp failed at run time
./testit: line 96: 22464 Abort trap              ./a.out
chart.pass.cpp failed at run time
./testit: line 96: 22471 Abort trap              ./a.out
ios_base.pass.cpp failed at run time
./testit: line 96: 22478 Abort trap              ./a.out
istream.pass.cpp failed at run time
./testit: line 96: 22485 Abort trap              ./a.out
signed_char.pass.cpp failed at run time
./testit: line 96: 22492 Abort trap              ./a.out
signed_char_pointer.pass.cpp failed at run time
./testit: line 96: 22499 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
./testit: line 96: 22506 Abort trap              ./a.out
unsigned_char.pass.cpp failed at run time
./testit: line 96: 22514 Abort trap              ./a.out
unsigned_char_pointer.pass.cpp failed at run time
./testit: line 96: 22521 Abort trap              ./a.out
wchar_t_pointer.pass.cpp failed at run time
failed 10 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream::extractors
./testit: line 96: 22532 Abort trap              ./a.out
ws.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream.manip
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.rvalue
./testit: line 96: 22554 Abort trap              ./a.out
get.pass.cpp failed at run time
./testit: line 96: 22561 Abort trap              ./a.out
get_chart.pass.cpp failed at run time
./testit: line 96: 22568 Abort trap              ./a.out
get_pointer_size.pass.cpp failed at run time
./testit: line 96: 22575 Abort trap              ./a.out
get_pointer_size_chart.pass.cpp failed at run time
./testit: line 96: 22582 Abort trap              ./a.out
get_streambuf.pass.cpp failed at run time
./testit: line 96: 22589 Abort trap              ./a.out
get_streambuf_chart.pass.cpp failed at run time
./testit: line 96: 22596 Abort trap              ./a.out
getline_pointer_size.pass.cpp failed at run time
./testit: line 96: 22603 Abort trap              ./a.out
getline_pointer_size_chart.pass.cpp failed at run time
./testit: line 96: 22611 Abort trap              ./a.out
ignore.pass.cpp failed at run time
./testit: line 96: 22618 Abort trap              ./a.out
peek.pass.cpp failed at run time
./testit: line 96: 22625 Abort trap              ./a.out
putback.pass.cpp failed at run time
./testit: line 96: 22633 Abort trap              ./a.out
read.pass.cpp failed at run time
./testit: line 96: 22640 Abort trap              ./a.out
readsome.pass.cpp failed at run time
./testit: line 96: 22647 Abort trap              ./a.out
seekg.pass.cpp failed at run time
./testit: line 96: 22654 Abort trap              ./a.out
seekg_off.pass.cpp failed at run time
./testit: line 96: 22661 Abort trap              ./a.out
sync.pass.cpp failed at run time
./testit: line 96: 22668 Abort trap              ./a.out
tellg.pass.cpp failed at run time
./testit: line 96: 22675 Abort trap              ./a.out
unget.pass.cpp failed at run time
failed 18 tests in /test/input.output/iostream.format/input.streams/istream.unformatted
passed 1 tests in /test/input.output/iostream.format/output.streams
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream
./testit: line 96: 22709 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/output.streams/ostream.assign
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.assign
./testit: line 96: 22735 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/output.streams/ostream.cons
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.cons
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.reqmts
./testit: line 96: 22769 Abort trap              ./a.out
basic_ios.pass.cpp failed at run time
./testit: line 96: 22777 Abort trap              ./a.out
ios_base.pass.cpp failed at run time
./testit: line 96: 22784 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 22791 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters
./testit: line 96: 22802 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 22809 Abort trap              ./a.out
double.pass.cpp failed at run time
./testit: line 96: 22816 Abort trap              ./a.out
float.pass.cpp failed at run time
./testit: line 96: 22824 Abort trap              ./a.out
int.pass.cpp failed at run time
./testit: line 96: 22831 Abort trap              ./a.out
long.pass.cpp failed at run time
./testit: line 96: 22838 Abort trap              ./a.out
long_double.pass.cpp failed at run time
./testit: line 96: 22845 Abort trap              ./a.out
long_long.pass.cpp failed at run time
./testit: line 96: 22852 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 22859 Abort trap              ./a.out
short.pass.cpp failed at run time
./testit: line 96: 22866 Abort trap              ./a.out
unsigned_int.pass.cpp failed at run time
./testit: line 96: 22873 Abort trap              ./a.out
unsigned_long.pass.cpp failed at run time
./testit: line 96: 22880 Abort trap              ./a.out
unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 22887 Abort trap              ./a.out
unsigned_short.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.arithmetic
./testit: line 96: 22898 Abort trap              ./a.out
CharT.pass.cpp failed at run time
./testit: line 96: 22905 Abort trap              ./a.out
CharT_pointer.pass.cpp failed at run time
./testit: line 96: 22912 Abort trap              ./a.out
char.pass.cpp failed at run time
./testit: line 96: 22919 Abort trap              ./a.out
char_pointer.pass.cpp failed at run time
./testit: line 96: 22926 Abort trap              ./a.out
char_to_wide.pass.cpp failed at run time
./testit: line 96: 22933 Abort trap              ./a.out
char_to_wide_pointer.pass.cpp failed at run time
./testit: line 96: 22940 Abort trap              ./a.out
signed_char.pass.cpp failed at run time
./testit: line 96: 22947 Abort trap              ./a.out
signed_char_pointer.pass.cpp failed at run time
./testit: line 96: 22954 Abort trap              ./a.out
unsigned_char.pass.cpp failed at run time
./testit: line 96: 22961 Abort trap              ./a.out
unsigned_char_pointer.pass.cpp failed at run time
failed 10 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.character
./testit: line 96: 22974 Abort trap              ./a.out
endl.pass.cpp failed at run time
./testit: line 96: 22981 Abort trap              ./a.out
ends.pass.cpp failed at run time
./testit: line 96: 22988 Abort trap              ./a.out
flush.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.manip
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.rvalue
./testit: line 96: 23010 Abort trap              ./a.out
seekp.pass.cpp failed at run time
./testit: line 96: 23017 Abort trap              ./a.out
seekp2.pass.cpp failed at run time
./testit: line 96: 23024 Abort trap              ./a.out
tellp.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.seeks
./testit: line 96: 23035 Abort trap              ./a.out
flush.pass.cpp failed at run time
./testit: line 96: 23042 Abort trap              ./a.out
put.pass.cpp failed at run time
./testit: line 96: 23049 Abort trap              ./a.out
write.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.unformatted
./testit: line 96: 23060 Abort trap              ./a.out
construct.pass.cpp failed at run time
./testit: line 96: 23067 Abort trap              ./a.out
destruct.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostream.format/output.streams/ostream::sentry
./testit: line 96: 23078 Abort trap              ./a.out
resetiosflags.pass.cpp failed at run time
./testit: line 96: 23085 Abort trap              ./a.out
setbase.pass.cpp failed at run time
./testit: line 96: 23092 Abort trap              ./a.out
setfill.pass.cpp failed at run time
./testit: line 96: 23099 Abort trap              ./a.out
setiosflags.pass.cpp failed at run time
./testit: line 96: 23106 Abort trap              ./a.out
setprecision.pass.cpp failed at run time
./testit: line 96: 23113 Abort trap              ./a.out
setw.pass.cpp failed at run time
failed 6 tests in /test/input.output/iostream.format/std.manip
passed 1 tests in /test/input.output/iostream.forward
passed 1 tests in /test/input.output/iostream.objects
passed 4 tests in /test/input.output/iostream.objects/narrow.stream.objects
passed 4 tests in /test/input.output/iostream.objects/wide.stream.objects
passed 1 tests in /test/input.output/iostreams.base
passed 1 tests in /test/input.output/iostreams.base/fpos
passed 1 tests in /test/input.output/iostreams.base/fpos/fpos.members
passed 7 tests in /test/input.output/iostreams.base/fpos/fpos.operations
passed 1 tests in /test/input.output/iostreams.base/ios
./testit: line 96: 23457 Abort trap              ./a.out
ctor_streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios/basic.ios.cons
./testit: line 96: 23489 Abort trap              ./a.out
copyfmt.pass.cpp failed at run time
./testit: line 96: 23503 Abort trap              ./a.out
fill.pass.cpp failed at run time
./testit: line 96: 23517 Abort trap              ./a.out
fill_char_type.pass.cpp failed at run time
./testit: line 96: 23538 Abort trap              ./a.out
imbue.pass.cpp failed at run time
./testit: line 96: 23549 Segmentation fault      ./a.out
move.pass.cpp failed at run time
./testit: line 96: 23559 Abort trap              ./a.out
narow.pass.cpp failed at run time
./testit: line 96: 23570 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 23577 Abort trap              ./a.out
rdbuf_streambuf.pass.cpp failed at run time
./testit: line 96: 23591 Abort trap              ./a.out
set_rdbuf.pass.cpp failed at run time
./testit: line 96: 23609 Abort trap              ./a.out
swap.pass.cpp failed at run time
./testit: line 96: 23626 Abort trap              ./a.out
tie.pass.cpp failed at run time
./testit: line 96: 23647 Abort trap              ./a.out
tie_ostream.pass.cpp failed at run time
./testit: line 96: 23672 Abort trap              ./a.out
widen.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostreams.base/ios/basic.ios.members
./testit: line 96: 23701 Abort trap              ./a.out
bad.pass.cpp failed at run time
./testit: line 96: 23722 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 23747 Abort trap              ./a.out
clear.pass.cpp failed at run time
./testit: line 96: 23780 Abort trap              ./a.out
eof.pass.cpp failed at run time
./testit: line 96: 23801 Abort trap              ./a.out
exceptions.pass.cpp failed at run time
./testit: line 96: 23811 Abort trap              ./a.out
exceptions_iostate.pass.cpp failed at run time
./testit: line 96: 23822 Abort trap              ./a.out
fail.pass.cpp failed at run time
./testit: line 96: 23840 Abort trap              ./a.out
good.pass.cpp failed at run time
./testit: line 96: 23861 Abort trap              ./a.out
not.pass.cpp failed at run time
./testit: line 96: 23879 Abort trap              ./a.out
rdstate.pass.cpp failed at run time
./testit: line 96: 23890 Abort trap              ./a.out
setstate.pass.cpp failed at run time
failed 11 tests in /test/input.output/iostreams.base/ios/iostate.flags
passed 1 tests in /test/input.output/iostreams.base/ios.base
./testit: line 96: 23926 Abort trap              ./a.out
flags.pass.cpp failed at run time
./testit: line 96: 23955 Abort trap              ./a.out
flags_fmtflags.pass.cpp failed at run time
./testit: line 96: 23963 Abort trap              ./a.out
precision.pass.cpp failed at run time
./testit: line 96: 23976 Abort trap              ./a.out
precision_streamsize.pass.cpp failed at run time
./testit: line 96: 23995 Abort trap              ./a.out
setf_fmtflags.pass.cpp failed at run time
./testit: line 96: 24028 Abort trap              ./a.out
setf_fmtflags_mask.pass.cpp failed at run time
./testit: line 96: 24049 Abort trap              ./a.out
unsetf_mask.pass.cpp failed at run time
./testit: line 96: 24060 Abort trap              ./a.out
width.pass.cpp failed at run time
./testit: line 96: 24074 Abort trap              ./a.out
width_streamsize.pass.cpp failed at run time
failed 9 tests in /test/input.output/iostreams.base/ios.base/fmtflags.state
./testit: line 96: 24092 Abort trap              ./a.out
register_callback.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.callback
./testit: line 96: 24109 Abort trap              ./a.out
dtor.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.cons
./testit: line 96: 24121 Abort trap              ./a.out
getloc.pass.cpp failed at run time
./testit: line 96: 24147 Abort trap              ./a.out
imbue.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostreams.base/ios.base/ios.base.locales
./testit: line 96: 24165 Abort trap              ./a.out
iword.pass.cpp failed at run time
./testit: line 96: 24176 Abort trap              ./a.out
pword.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostreams.base/ios.base/ios.base.storage
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.storage
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.members.static
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::Init
passed 2 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::failure
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::fmtflags
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::iostate
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::openmode
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::seekdir
passed 1 tests in /test/input.output/iostreams.base/std.ios.manip
./testit: line 96: 24410 Abort trap              ./a.out
internal.pass.cpp failed at run time
./testit: line 96: 24430 Abort trap              ./a.out
left.pass.cpp failed at run time
./testit: line 96: 24449 Abort trap              ./a.out
right.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostreams.base/std.ios.manip/adjustfield.manip
./testit: line 96: 24474 Abort trap              ./a.out
dec.pass.cpp failed at run time
./testit: line 96: 24496 Abort trap              ./a.out
hex.pass.cpp failed at run time
./testit: line 96: 24513 Abort trap              ./a.out
oct.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostreams.base/std.ios.manip/basefield.manip
passed 3 tests in /test/input.output/iostreams.base/std.ios.manip/error.reporting
./testit: line 96: 24581 Abort trap              ./a.out
defaultfloat.pass.cpp failed at run time
./testit: line 96: 24592 Abort trap              ./a.out
fixed.pass.cpp failed at run time
./testit: line 96: 24616 Abort trap              ./a.out
hexfloat.pass.cpp failed at run time
./testit: line 96: 24628 Abort trap              ./a.out
scientific.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostreams.base/std.ios.manip/floatfield.manip
./testit: line 96: 24656 Abort trap              ./a.out
boolalpha.pass.cpp failed at run time
./testit: line 96: 24677 Abort trap              ./a.out
noboolalpha.pass.cpp failed at run time
./testit: line 96: 24705 Abort trap              ./a.out
noshowbase.pass.cpp failed at run time
./testit: line 96: 24724 Abort trap              ./a.out
noshowpoint.pass.cpp failed at run time
./testit: line 96: 24731 Abort trap              ./a.out
noshowpos.pass.cpp failed at run time
./testit: line 96: 24745 Abort trap              ./a.out
noskipws.pass.cpp failed at run time
./testit: line 96: 24755 Abort trap              ./a.out
nounitbuf.pass.cpp failed at run time
./testit: line 96: 24812 Abort trap              ./a.out
nouppercase.pass.cpp failed at run time
./testit: line 96: 24837 Abort trap              ./a.out
showbase.pass.cpp failed at run time
./testit: line 96: 24870 Abort trap              ./a.out
showpoint.pass.cpp failed at run time
./testit: line 96: 24910 Abort trap              ./a.out
showpos.pass.cpp failed at run time
./testit: line 96: 24927 Abort trap              ./a.out
skipws.pass.cpp failed at run time
./testit: line 96: 24964 Abort trap              ./a.out
unitbuf.pass.cpp failed at run time
./testit: line 96: 24996 Abort trap              ./a.out
uppercase.pass.cpp failed at run time
failed 14 tests in /test/input.output/iostreams.base/std.ios.manip/fmtflags.manip
passed 2 tests in /test/input.output/iostreams.base/stream.types
passed 1 tests in /test/input.output/iostreams.requirements
passed 1 tests in /test/input.output/iostreams.requirements/iostream.limits.imbue
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.limits.pos
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.threadsafety
passed 1 tests in /test/input.output/stream.buffers
passed 1 tests in /test/input.output/stream.buffers/streambuf
default.fail.cpp should not compile
failed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.cons
passed 3 tests in /test/input.output/stream.buffers/streambuf/streambuf.cons
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.buffer
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.locales
passed 5 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.get
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.put
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.assign
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.get.area
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.put.area
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.buffer
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.get
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.locales
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.put
passed 1 tests in /test/input.output/stream.buffers/streambuf.reqts
passed 1 tests in /test/input.output/string.streams
passed 1 tests in /test/input.output/string.streams/istringstream
./testit: line 96: 25921 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 25975 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/istringstream/istringstream.assign
passed 1 tests in /test/input.output/string.streams/istringstream/istringstream.assign
./testit: line 96: 26003 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 26055 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/istringstream/istringstream.cons
passed 1 tests in /test/input.output/string.streams/istringstream/istringstream.cons
./testit: line 96: 26114 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/istringstream/istringstream.members
passed 1 tests in /test/input.output/string.streams/ostringstream
./testit: line 96: 26203 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 26306 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/ostringstream/ostringstream.assign
passed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.assign
./testit: line 96: 26364 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 26452 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/ostringstream/ostringstream.cons
passed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.cons
./testit: line 96: 26536 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.members
passed 1 tests in /test/input.output/string.streams/stringbuf
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.assign
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.cons
passed 1 tests in /test/input.output/string.streams/stringbuf/stringbuf.members
passed 6 tests in /test/input.output/string.streams/stringbuf/stringbuf.virtuals
passed 1 tests in /test/input.output/string.streams/stringstream
./testit: line 96: 27162 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 27229 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/stringstream.cons
passed 1 tests in /test/input.output/string.streams/stringstream.cons
./testit: line 96: 27289 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 27363 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/stringstream.cons/stringstream.assign
passed 1 tests in /test/input.output/string.streams/stringstream.cons/stringstream.assign
./testit: line 96: 27389 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/stringstream.members
passed 1 tests in /test/iterators
passed 1 tests in /test/iterators/iterator.primitives
passed 1 tests in /test/iterators/iterator.primitives/iterator.basic
passed 4 tests in /test/iterators/iterator.primitives/iterator.operations
passed 4 tests in /test/iterators/iterator.primitives/iterator.traits
passed 5 tests in /test/iterators/iterator.primitives/std.iterator.tags
passed 1 tests in /test/iterators/iterator.requirements
passed 1 tests in /test/iterators/iterator.requirements/bidirectional.iterators
passed 1 tests in /test/iterators/iterator.requirements/forward.iterators
passed 1 tests in /test/iterators/iterator.requirements/input.iterators
passed 1 tests in /test/iterators/iterator.requirements/iterator.iterators
passed 1 tests in /test/iterators/iterator.requirements/iterator.requirements.general
passed 1 tests in /test/iterators/iterator.requirements/output.iterators
passed 1 tests in /test/iterators/iterator.requirements/random.access.iterators
passed 1 tests in /test/iterators/iterator.synopsis
passed 1 tests in /test/iterators/iterators.general
passed 1 tests in /test/iterators/predef.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iterator
passed 1 tests in /test/iterators/predef.iterators/move.iterators
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops
passed 3 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.nonmember
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-=
passed 6 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.comp
passed 5 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.const
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.conv
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.decr
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.incr
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.index
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.ref
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.requirements
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iterator
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops
passed 5 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.cons
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.conv
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op!=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op++
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op--
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op==
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opdiff
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opindex
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opref
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opsum
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.requirements
types.pass.cpp:66:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((std::is_same<typename R::pointer, It>::value), "");
    ^
In file included from types.pass.cpp:42:
In file included from ../../../../../include/iterator:334:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
types.pass.cpp:72:5: note: in instantiation of function template specialization 'test<bidirectional_iterator<char *> >' requested here
    test<bidirectional_iterator<char*> >();
    ^
In file included from types.pass.cpp:42:
In file included from ../../../../../include/iterator:334:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
types.pass.cpp:66:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((std::is_same<typename R::pointer, It>::value), "");
    ^
In file included from types.pass.cpp:42:
In file included from ../../../../../include/iterator:334:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
types.pass.cpp:73:5: note: in instantiation of function template specialization 'test<random_access_iterator<char *> >' requested here
    test<random_access_iterator<char*> >();
    ^
In file included from types.pass.cpp:42:
In file included from ../../../../../include/iterator:334:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
2 errors generated.
types.pass.cpp failed to compile
failed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iterator
passed 1 tests in /test/iterators/stream.iterators
passed 1 tests in /test/iterators/stream.iterators/istream.iterator
./testit: line 96: 29108 Abort trap              ./a.out
copy.pass.cpp failed at run time
./testit: line 96: 29148 Abort trap              ./a.out
istream.pass.cpp failed at run time
failed 2 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.cons
passed 1 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.cons
./testit: line 96: 29180 Abort trap              ./a.out
arrow.pass.cpp failed at run time
./testit: line 96: 29208 Abort trap              ./a.out
dereference.pass.cpp failed at run time
./testit: line 96: 29236 Abort trap              ./a.out
equal.pass.cpp failed at run time
./testit: line 96: 29269 Abort trap              ./a.out
post_increment.pass.cpp failed at run time
./testit: line 96: 29298 Abort trap              ./a.out
pre_increment.pass.cpp failed at run time
failed 5 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator
./testit: line 96: 29369 Abort trap              ./a.out
istream.pass.cpp failed at run time
./testit: line 96: 29405 Abort trap              ./a.out
proxy.pass.cpp failed at run time
./testit: line 96: 29444 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator.cons
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator.cons
./testit: line 96: 29499 Abort trap              ./a.out
equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::equal
./testit: line 96: 29535 Abort trap              ./a.out
not_equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op!=
./testit: line 96: 29589 Abort trap              ./a.out
dereference.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op++
./testit: line 96: 29624 Abort trap              ./a.out
equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op==
./testit: line 96: 29664 Abort trap              ./a.out
arrow.pass.cpp failed at run time
./testit: line 96: 29727 Abort trap              ./a.out
post_increment.pass.cpp failed at run time
./testit: line 96: 29823 Abort trap              ./a.out
pre_increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op_astrk
./testit: line 96: 29924 Abort trap              ./a.out
proxy.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::proxy
passed 6 tests in /test/iterators/stream.iterators/iterator.range
passed 1 tests in /test/iterators/stream.iterators/ostream.iterator
./testit: line 96: 30215 Abort trap              ./a.out
copy.pass.cpp failed at run time
./testit: line 96: 30258 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 30307 Abort trap              ./a.out
ostream_delem.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.cons.des
./testit: line 96: 30386 Abort trap              ./a.out
assign_t.pass.cpp failed at run time
./testit: line 96: 30457 Abort trap              ./a.out
dereference.pass.cpp failed at run time
./testit: line 96: 30515 Abort trap              ./a.out
increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/ostreambuf.iterator
./testit: line 96: 30551 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 30565 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 2 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.cons
./testit: line 96: 30598 Abort trap              ./a.out
assign_c.pass.cpp failed at run time
./testit: line 96: 30612 Abort trap              ./a.out
deref.pass.cpp failed at run time
./testit: line 96: 30647 Abort trap              ./a.out
increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.ops
passed 1 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.ops
passed 1 tests in /test/language.support
passed 1 tests in /test/language.support/cstdint
passed 1 tests in /test/language.support/cstdint/cstdint.syn
passed 1 tests in /test/language.support/support.dynamic
passed 1 tests in /test/language.support/support.dynamic/alloc.errors
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/bad.alloc
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.badlength
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.handler
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/set.new.handler
passed 1 tests in /test/language.support/support.dynamic/new.delete
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.array
passed 1 tests in /test/language.support/support.dynamic/new.delete/new.delete.dataraces
passed 2 tests in /test/language.support/support.dynamic/new.delete/new.delete.placement
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.single
passed 1 tests in /test/language.support/support.exception
not implemented:  /test/language.support/support.exception/except.nested
passed 1 tests in /test/language.support/support.exception/exception
passed 1 tests in /test/language.support/support.exception/exception.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/set.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate.handler
passed 1 tests in /test/language.support/support.exception/exception.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/bad.exception
passed 1 tests in /test/language.support/support.exception/exception.unexpected/set.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected.handler
Assertion failed: (A::constructed == 0), function main, file current_exception.pass.cpp, line 59.
./testit: line 96: 31014 Abort trap              ./a.out
current_exception.pass.cpp failed at run time
Assertion failed: (A::constructed == 0), function main, file make_exception_ptr.pass.cpp, line 61.
./testit: line 96: 31036 Abort trap              ./a.out
make_exception_ptr.pass.cpp failed at run time
Assertion failed: (A::constructed == 0), function main, file rethrow_exception.pass.cpp, line 69.
./testit: line 96: 31043 Abort trap              ./a.out
rethrow_exception.pass.cpp failed at run time
failed 3 tests in /test/language.support/support.exception/propagation
passed 1 tests in /test/language.support/support.exception/propagation
passed 1 tests in /test/language.support/support.exception/uncaught
not implemented:  /test/language.support/support.general
passed 1 tests in /test/language.support/support.initlist
passed 1 tests in /test/language.support/support.initlist/support.initlist.access
passed 1 tests in /test/language.support/support.initlist/support.initlist.cons
not implemented:  /test/language.support/support.initlist/support.initlist.range
passed 1 tests in /test/language.support/support.limits
passed 2 tests in /test/language.support/support.limits/c.limits
passed 1 tests in /test/language.support/support.limits/limits
passed 1 tests in /test/language.support/support.limits/limits/denorm.style
passed 1 tests in /test/language.support/support.limits/limits/numeric.limits
passed 31 tests in /test/language.support/support.limits/limits/numeric.limits.members
passed 1 tests in /test/language.support/support.limits/limits/numeric.special
passed 1 tests in /test/language.support/support.limits/limits/round.style
passed 1 tests in /test/language.support/support.rtti
passed 1 tests in /test/language.support/support.rtti/bad.cast
passed 1 tests in /test/language.support/support.rtti/bad.typeid
passed 2 tests in /test/language.support/support.rtti/type.info
passed 6 tests in /test/language.support/support.runtime
quick_exit.pass.cpp:33:10: error: no member named 'at_quick_exit' in namespace 'std'
    std::at_quick_exit(f);
    ~~~~~^
quick_exit.pass.cpp:34:5: error: use of undeclared identifier 'quick_exit'
    quick_exit(0);
    ^
2 errors generated.
quick_exit.pass.cpp failed to compile
failed 1 tests in /test/language.support/support.start.term
passed 6 tests in /test/language.support/support.types
passed 1 tests in /test/localization
passed 1 tests in /test/localization/c.locales
./testit: line 96: 31681 Abort trap              ./a.out
__scan_keyword.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories
passed 1 tests in /test/localization/locale.categories/category.collate
Assertion failed: (std::has_facet<std::collate<char> >(l)), function main, file types.pass.cpp, line 44.
./testit: line 96: 31730 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.collate/locale.collate
passed 1 tests in /test/localization/locale.categories/category.collate/locale.collate
./testit: line 96: 31752 Abort trap              ./a.out
compare.pass.cpp failed at run time
./testit: line 96: 31761 Abort trap              ./a.out
hash.pass.cpp failed at run time
./testit: line 96: 31777 Abort trap              ./a.out
transform.pass.cpp failed at run time
failed 3 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.members
passed 1 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.virtuals
passed 4 tests in /test/localization/locale.categories/category.collate/locale.collate.byname
passed 1 tests in /test/localization/locale.categories/category.ctype
Assertion failed: (std::has_facet<std::ctype<char> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 32006 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.dtor
./testit: line 96: 32147 Abort trap              ./a.out
is_1.pass.cpp failed at run time
./testit: line 96: 32189 Abort trap              ./a.out
is_many.pass.cpp failed at run time
./testit: line 96: 32227 Abort trap              ./a.out
narrow_1.pass.cpp failed at run time
./testit: line 96: 32268 Abort trap              ./a.out
narrow_many.pass.cpp failed at run time
./testit: line 96: 32310 Abort trap              ./a.out
scan_is.pass.cpp failed at run time
./testit: line 96: 32372 Abort trap              ./a.out
scan_not.pass.cpp failed at run time
./testit: line 96: 32443 Abort trap              ./a.out
tolower_1.pass.cpp failed at run time
./testit: line 96: 32491 Abort trap              ./a.out
tolower_many.pass.cpp failed at run time
./testit: line 96: 32537 Abort trap              ./a.out
toupper_1.pass.cpp failed at run time
./testit: line 96: 32595 Abort trap              ./a.out
toupper_many.pass.cpp failed at run time
./testit: line 96: 32658 Abort trap              ./a.out
widen_1.pass.cpp failed at run time
./testit: line 96: 32673 Abort trap              ./a.out
widen_many.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.members
passed 2 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.members
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.statics
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.virtuals
Assertion failed: (std::has_facet<F>(l)), function main, file types_char.pass.cpp, line 51.
./testit: line 96: 32790 Abort trap              ./a.out
types_char.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_char16_t.pass.cpp, line 52.
./testit: line 96: 32803 Abort trap              ./a.out
types_char16_t.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_char32_t.pass.cpp, line 52.
./testit: line 96: 32822 Abort trap              ./a.out
types_char32_t.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_wchar_t.pass.cpp, line 51.
./testit: line 96: 32839 Abort trap              ./a.out
types_wchar_t.pass.cpp failed at run time
failed 4 tests in /test/localization/locale.categories/category.ctype/locale.codecvt
passed 5 tests in /test/localization/locale.categories/category.ctype/locale.codecvt
./testit: line 96: 32860 Abort trap              ./a.out
char16_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 32876 Abort trap              ./a.out
char16_t_encoding.pass.cpp failed at run time
./testit: line 96: 32891 Abort trap              ./a.out
char16_t_in.pass.cpp failed at run time
./testit: line 96: 32910 Abort trap              ./a.out
char16_t_length.pass.cpp failed at run time
./testit: line 96: 32952 Abort trap              ./a.out
char16_t_max_length.pass.cpp failed at run time
./testit: line 96: 32975 Abort trap              ./a.out
char16_t_out.pass.cpp failed at run time
./testit: line 96: 33011 Abort trap              ./a.out
char16_t_unshift.pass.cpp failed at run time
./testit: line 96: 33077 Abort trap              ./a.out
char32_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 33135 Abort trap              ./a.out
char32_t_encoding.pass.cpp failed at run time
./testit: line 96: 33211 Abort trap              ./a.out
char32_t_in.pass.cpp failed at run time
./testit: line 96: 33238 Abort trap              ./a.out
char32_t_length.pass.cpp failed at run time
./testit: line 96: 33245 Abort trap              ./a.out
char32_t_max_length.pass.cpp failed at run time
./testit: line 96: 33252 Abort trap              ./a.out
char32_t_out.pass.cpp failed at run time
./testit: line 96: 33259 Abort trap              ./a.out
char32_t_unshift.pass.cpp failed at run time
./testit: line 96: 33266 Abort trap              ./a.out
char_always_noconv.pass.cpp failed at run time
./testit: line 96: 33273 Abort trap              ./a.out
char_encoding.pass.cpp failed at run time
./testit: line 96: 33280 Abort trap              ./a.out
char_in.pass.cpp failed at run time
./testit: line 96: 33287 Abort trap              ./a.out
char_length.pass.cpp failed at run time
./testit: line 96: 33294 Abort trap              ./a.out
char_max_length.pass.cpp failed at run time
./testit: line 96: 33301 Abort trap              ./a.out
char_out.pass.cpp failed at run time
./testit: line 96: 33308 Abort trap              ./a.out
char_unshift.pass.cpp failed at run time
./testit: line 96: 33315 Abort trap              ./a.out
utf_sanity_check.pass.cpp failed at run time
./testit: line 96: 33322 Abort trap              ./a.out
wchar_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 33329 Abort trap              ./a.out
wchar_t_encoding.pass.cpp failed at run time
./testit: line 96: 33336 Abort trap              ./a.out
wchar_t_in.pass.cpp failed at run time
./testit: line 96: 33343 Abort trap              ./a.out
wchar_t_length.pass.cpp failed at run time
./testit: line 96: 33350 Abort trap              ./a.out
wchar_t_max_length.pass.cpp failed at run time
./testit: line 96: 33357 Abort trap              ./a.out
wchar_t_out.pass.cpp failed at run time
./testit: line 96: 33364 Abort trap              ./a.out
wchar_t_unshift.pass.cpp failed at run time
failed 29 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.virtuals
passed 4 tests in /test/localization/locale.categories/category.ctype/locale.codecvt.byname
Assertion failed: (std::has_facet<std::ctype<wchar_t> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 33425 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype
./testit: line 96: 33437 Abort trap              ./a.out
is_1.pass.cpp failed at run time
./testit: line 96: 33444 Abort trap              ./a.out
is_many.pass.cpp failed at run time
./testit: line 96: 33451 Abort trap              ./a.out
narrow_1.pass.cpp failed at run time
./testit: line 96: 33458 Abort trap              ./a.out
narrow_many.pass.cpp failed at run time
./testit: line 96: 33465 Abort trap              ./a.out
scan_is.pass.cpp failed at run time
./testit: line 96: 33472 Abort trap              ./a.out
scan_not.pass.cpp failed at run time
./testit: line 96: 33479 Abort trap              ./a.out
tolower_1.pass.cpp failed at run time
./testit: line 96: 33486 Abort trap              ./a.out
tolower_many.pass.cpp failed at run time
./testit: line 96: 33493 Abort trap              ./a.out
toupper_1.pass.cpp failed at run time
./testit: line 96: 33500 Abort trap              ./a.out
toupper_many.pass.cpp failed at run time
./testit: line 96: 33508 Abort trap              ./a.out
widen_1.pass.cpp failed at run time
./testit: line 96: 33515 Abort trap              ./a.out
widen_many.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.virtuals
passed 13 tests in /test/localization/locale.categories/category.ctype/locale.ctype.byname
passed 1 tests in /test/localization/locale.categories/category.messages
passed 3 tests in /test/localization/locale.categories/category.messages/locale.messages
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.members
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.virtuals
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages.byname
passed 1 tests in /test/localization/locale.categories/category.monetary
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.get
./testit: line 96: 33732 Abort trap              ./a.out
get_long_double_en_US.pass.cpp failed at run time
./testit: line 96: 33739 Abort trap              ./a.out
get_long_double_fr_FR.pass.cpp failed at run time
./testit: line 96: 33746 Abort trap              ./a.out
get_long_double_ru_RU.pass.cpp failed at run time
./testit: line 96: 33753 Abort trap              ./a.out
get_long_double_zh_CN.pass.cpp failed at run time
./testit: line 96: 33760 Abort trap              ./a.out
get_string_en_US.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.virtuals
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.put
./testit: line 96: 33800 Abort trap              ./a.out
put_long_double_en_US.pass.cpp failed at run time
./testit: line 96: 33807 Abort trap              ./a.out
put_long_double_fr_FR.pass.cpp failed at run time
./testit: line 96: 33814 Abort trap              ./a.out
put_long_double_ru_RU.pass.cpp failed at run time
./testit: line 96: 33821 Abort trap              ./a.out
put_long_double_zh_CN.pass.cpp failed at run time
./testit: line 96: 33828 Abort trap              ./a.out
put_string_en_US.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.virtuals
passed 3 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.virtuals
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct.byname
passed 1 tests in /test/localization/locale.categories/category.numeric
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.nm.put
./testit: line 96: 34049 Abort trap              ./a.out
put_bool.pass.cpp failed at run time
./testit: line 96: 34056 Abort trap              ./a.out
put_double.pass.cpp failed at run time
./testit: line 96: 34064 Abort trap              ./a.out
put_long.pass.cpp failed at run time
./testit: line 96: 34071 Abort trap              ./a.out
put_long_double.pass.cpp failed at run time
./testit: line 96: 34079 Abort trap              ./a.out
put_long_long.pass.cpp failed at run time
./testit: line 96: 34086 Abort trap              ./a.out
put_pointer.pass.cpp failed at run time
./testit: line 96: 34093 Abort trap              ./a.out
put_unsigned_long.pass.cpp failed at run time
./testit: line 96: 34100 Abort trap              ./a.out
put_unsigned_long_long.pass.cpp failed at run time
failed 8 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.virtuals
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.num.get
./testit: line 96: 34140 Abort trap              ./a.out
get_bool.pass.cpp failed at run time
get_double.pass.cpp:122:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_double.pass.cpp:122:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 warning generated.
./testit: line 96: 34147 Abort trap              ./a.out
get_double.pass.cpp failed at run time
get_float.pass.cpp:110:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_float.pass.cpp:110:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 warning generated.
./testit: line 96: 34154 Abort trap              ./a.out
get_float.pass.cpp failed at run time
./testit: line 96: 34161 Abort trap              ./a.out
get_long.pass.cpp failed at run time
get_long_double.pass.cpp:110:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_long_double.pass.cpp:110:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 warning generated.
./testit: line 96: 34168 Abort trap              ./a.out
get_long_double.pass.cpp failed at run time
./testit: line 96: 34175 Abort trap              ./a.out
get_long_long.pass.cpp failed at run time
./testit: line 96: 34182 Abort trap              ./a.out
get_pointer.pass.cpp failed at run time
./testit: line 96: 34189 Abort trap              ./a.out
get_unsigned_int.pass.cpp failed at run time
./testit: line 96: 34196 Abort trap              ./a.out
get_unsigned_long.pass.cpp failed at run time
./testit: line 96: 34203 Abort trap              ./a.out
get_unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 34210 Abort trap              ./a.out
get_unsigned_short.pass.cpp failed at run time
failed 11 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.virtuals
passed 1 tests in /test/localization/locale.categories/category.time
passed 3 tests in /test/localization/locale.categories/category.time/locale.time.get
./testit: line 96: 34275 Abort trap              ./a.out
get_date.pass.cpp failed at run time
./testit: line 96: 34282 Abort trap              ./a.out
get_date_wide.pass.cpp failed at run time
./testit: line 96: 34289 Abort trap              ./a.out
get_many.pass.cpp failed at run time
./testit: line 96: 34296 Abort trap              ./a.out
get_monthname.pass.cpp failed at run time
./testit: line 96: 34303 Abort trap              ./a.out
get_monthname_wide.pass.cpp failed at run time
./testit: line 96: 34310 Abort trap              ./a.out
get_one.pass.cpp failed at run time
./testit: line 96: 34317 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 34324 Abort trap              ./a.out
get_time_wide.pass.cpp failed at run time
./testit: line 96: 34331 Abort trap              ./a.out
get_weekday.pass.cpp failed at run time
./testit: line 96: 34338 Abort trap              ./a.out
get_weekday_wide.pass.cpp failed at run time
./testit: line 96: 34345 Abort trap              ./a.out
get_year.pass.cpp failed at run time
failed 11 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.virtuals
./testit: line 96: 34382 Abort trap              ./a.out
get_date.pass.cpp failed at run time
./testit: line 96: 34389 Abort trap              ./a.out
get_date_wide.pass.cpp failed at run time
./testit: line 96: 34396 Abort trap              ./a.out
get_monthname.pass.cpp failed at run time
./testit: line 96: 34403 Abort trap              ./a.out
get_monthname_wide.pass.cpp failed at run time
./testit: line 96: 34410 Abort trap              ./a.out
get_one.pass.cpp failed at run time
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
                          "\x434\x435\x43A\x430\x431\x440\x44F"
                          ^
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:114:27: warning: hex escape sequence out of range [-pedantic]
                          "\x433"
                          ^
get_one_wide.pass.cpp:160:35: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                  ^
get_one_wide.pass.cpp:160:47: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                              ^
get_one_wide.pass.cpp:160:59: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                                          ^
11 warnings generated.
./testit: line 96: 34417 Abort trap              ./a.out
get_one_wide.pass.cpp failed at run time
./testit: line 96: 34424 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 34431 Abort trap              ./a.out
get_time_wide.pass.cpp failed at run time
./testit: line 96: 34438 Abort trap              ./a.out
get_weekday.pass.cpp failed at run time
./testit: line 96: 34445 Abort trap              ./a.out
get_weekday_wide.pass.cpp failed at run time
./testit: line 96: 34452 Abort trap              ./a.out
get_year.pass.cpp failed at run time
./testit: line 96: 34459 Abort trap              ./a.out
get_year_wide.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.put
./testit: line 96: 34489 Abort trap              ./a.out
put1.pass.cpp failed at run time
./testit: line 96: 34496 Abort trap              ./a.out
put2.pass.cpp failed at run time
failed 2 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.virtuals
./testit: line 96: 34518 Abort trap              ./a.out
put1.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.time/locale.time.put.byname
passed 1 tests in /test/localization/locale.categories/facet.numpunct
Assertion failed: (std::has_facet<std::numpunct<char> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 34547 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct
passed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct
./testit: line 96: 34559 Abort trap              ./a.out
decimal_point.pass.cpp failed at run time
./testit: line 96: 34566 Abort trap              ./a.out
falsename.pass.cpp failed at run time
./testit: line 96: 34573 Abort trap              ./a.out
grouping.pass.cpp failed at run time
./testit: line 96: 34580 Abort trap              ./a.out
thousands_sep.pass.cpp failed at run time
./testit: line 96: 34587 Abort trap              ./a.out
truename.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.members
passed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.virtuals
passed 3 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct.byname
passed 1 tests in /test/localization/locale.categories/facets.examples
not implemented:  /test/localization/locale.stdcvt
passed 1 tests in /test/localization/locale.syn
passed 1 tests in /test/localization/locales
passed 1 tests in /test/localization/locales/locale
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file assign.pass.cpp, line 60.
./testit: line 96: 34681 Abort trap              ./a.out
assign.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file char_pointer.pass.cpp, line 60.
./testit: line 96: 34688 Abort trap              ./a.out
char_pointer.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file copy.pass.cpp, line 60.
./testit: line 96: 34695 Abort trap              ./a.out
copy.pass.cpp failed at run time
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file default.pass.cpp, line 48.
./testit: line 96: 34702 Abort trap              ./a.out
default.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_char_pointer_cat.pass.cpp, line 60.
./testit: line 96: 34709 Abort trap              ./a.out
locale_char_pointer_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_facetptr.pass.cpp, line 60.
./testit: line 96: 34716 Abort trap              ./a.out
locale_facetptr.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_locale_cat.pass.cpp, line 60.
./testit: line 96: 34723 Abort trap              ./a.out
locale_locale_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_string_cat.pass.cpp, line 60.
./testit: line 96: 34730 Abort trap              ./a.out
locale_string_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file string.pass.cpp, line 60.
./testit: line 96: 34737 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 9 tests in /test/localization/locales/locale/locale.cons
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file combine.pass.cpp, line 48.
./testit: line 96: 34748 Abort trap              ./a.out
combine.pass.cpp failed at run time
failed 1 tests in /test/localization/locales/locale/locale.members
passed 1 tests in /test/localization/locales/locale/locale.members
./testit: line 96: 34767 Abort trap              ./a.out
compare.pass.cpp failed at run time
./testit: line 96: 34774 Abort trap              ./a.out
eq.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale/locale.operators
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file classic.pass.cpp, line 33.
./testit: line 96: 34785 Abort trap              ./a.out
classic.pass.cpp failed at run time
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file global.pass.cpp, line 33.
./testit: line 96: 34792 Abort trap              ./a.out
global.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale/locale.statics
passed 1 tests in /test/localization/locales/locale/locale.types
passed 1 tests in /test/localization/locales/locale/locale.types/locale.category
passed 1 tests in /test/localization/locales/locale/locale.types/locale.facet
passed 1 tests in /test/localization/locales/locale/locale.types/locale.id
passed 1 tests in /test/localization/locales/locale.convenience
./testit: line 96: 34858 Abort trap              ./a.out
isalnum.pass.cpp failed at run time
./testit: line 96: 34865 Abort trap              ./a.out
isalpha.pass.cpp failed at run time
./testit: line 96: 34872 Abort trap              ./a.out
iscntrl.pass.cpp failed at run time
./testit: line 96: 34879 Abort trap              ./a.out
isdigit.pass.cpp failed at run time
./testit: line 96: 34886 Abort trap              ./a.out
isgraph.pass.cpp failed at run time
./testit: line 96: 34893 Abort trap              ./a.out
islower.pass.cpp failed at run time
./testit: line 96: 34900 Abort trap              ./a.out
isprint.pass.cpp failed at run time
./testit: line 96: 34907 Abort trap              ./a.out
ispunct.pass.cpp failed at run time
./testit: line 96: 34914 Abort trap              ./a.out
isspace.pass.cpp failed at run time
./testit: line 96: 34921 Abort trap              ./a.out
isupper.pass.cpp failed at run time
./testit: line 96: 34928 Abort trap              ./a.out
isxdigit.pass.cpp failed at run time
failed 11 tests in /test/localization/locales/locale.convenience/classification
passed 1 tests in /test/localization/locales/locale.convenience/conversions
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.buffer
./testit: line 96: 34953 Abort trap              ./a.out
tolower.pass.cpp failed at run time
./testit: line 96: 34960 Abort trap              ./a.out
toupper.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale.convenience/conversions/conversions.character
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.string
Assertion failed: (std::has_facet<std::ctype<char> >(loc)), function main, file has_facet.pass.cpp, line 42.
./testit: line 96: 34974 Abort trap              ./a.out
has_facet.pass.cpp failed at run time
failed 1 tests in /test/localization/locales/locale.global.templates
passed 1 tests in /test/localization/locales/locale.global.templates
passed 1 tests in /test/localization/localization.general
passed 1 tests in /test/numerics
cmath.pass.cpp:1106:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(std::nextafter(0,1) == 0x1p-1074);
    ^
cmath.pass.cpp:1106:35: note: instantiated from:
    assert(std::nextafter(0,1) == 0x1p-1074);
                                  ^
cmath.pass.cpp:1124:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(std::nexttoward(0, 1) == 0x1p-1074);
    ^
cmath.pass.cpp:1124:37: note: instantiated from:
    assert(std::nexttoward(0, 1) == 0x1p-1074);
                                    ^
2 warnings generated.
tgmath_h.pass.cpp:26:2: error: #error <tgmath.h> is not implemented
#error <tgmath.h> is not implemented
 ^
1 error generated.
tgmath_h.pass.cpp failed to compile
failed 1 tests in /test/numerics/c.math
passed 2 tests in /test/numerics/c.math
passed 1 tests in /test/numerics/cfenv
passed 1 tests in /test/numerics/cfenv/cfenv.syn
passed 1 tests in /test/numerics/complex.number
passed 1 tests in /test/numerics/complex.number/ccmplx
passed 7 tests in /test/numerics/complex.number/cmplx.over
passed 1 tests in /test/numerics/complex.number/complex
passed 10 tests in /test/numerics/complex.number/complex.member.ops
passed 2 tests in /test/numerics/complex.number/complex.members
stream_input.pass.cpp:30:2: error: #error operator>>(basic_istream<charT, traits>& is, complex<T>& x) not implemented.
#error operator>>(basic_istream<charT, traits>& is, complex<T>& x) not implemented.
 ^
1 error generated.
stream_input.pass.cpp failed to compile
stream_output.pass.cpp:30:2: error: #error operator<<(basic_ostream<charT, traits>& o, const complex<T>& x) not implemented.
#error operator<<(basic_ostream<charT, traits>& o, const complex<T>& x) not implemented.
 ^
1 error generated.
stream_output.pass.cpp failed to compile
failed 2 tests in /test/numerics/complex.number/complex.ops
passed 20 tests in /test/numerics/complex.number/complex.ops
passed 12 tests in /test/numerics/complex.number/complex.special
passed 1 tests in /test/numerics/complex.number/complex.synopsis
passed 19 tests in /test/numerics/complex.number/complex.transcendentals
passed 8 tests in /test/numerics/complex.number/complex.value.ops
passed 1 tests in /test/numerics/numarray
passed 1 tests in /test/numerics/numarray/class.gslice
passed 1 tests in /test/numerics/numarray/class.gslice/gslice.access
passed 2 tests in /test/numerics/numarray/class.gslice/gslice.cons
passed 1 tests in /test/numerics/numarray/class.slice
passed 2 tests in /test/numerics/numarray/class.slice/cons.slice
passed 1 tests in /test/numerics/numarray/class.slice/slice.access
passed 2 tests in /test/numerics/numarray/template.gslice.array
passed 2 tests in /test/numerics/numarray/template.gslice.array/gslice.array.assign
passed 10 tests in /test/numerics/numarray/template.gslice.array/gslice.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.gslice.array/gslice.array.fill
passed 2 tests in /test/numerics/numarray/template.indirect.array
passed 2 tests in /test/numerics/numarray/template.indirect.array/indirect.array.assign
passed 10 tests in /test/numerics/numarray/template.indirect.array/indirect.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.indirect.array/indirect.array.fill
passed 2 tests in /test/numerics/numarray/template.mask.array
passed 2 tests in /test/numerics/numarray/template.mask.array/mask.array.assign
passed 10 tests in /test/numerics/numarray/template.mask.array/mask.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.mask.array/mask.array.fill
passed 2 tests in /test/numerics/numarray/template.slice.array
passed 2 tests in /test/numerics/numarray/template.slice.array/slice.arr.assign
passed 10 tests in /test/numerics/numarray/template.slice.array/slice.arr.comp.assign
passed 1 tests in /test/numerics/numarray/template.slice.array/slice.arr.fill
passed 1 tests in /test/numerics/numarray/template.valarray
passed 2 tests in /test/numerics/numarray/template.valarray/valarray.access
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.assign
passed 20 tests in /test/numerics/numarray/template.valarray/valarray.cassign
passed 11 tests in /test/numerics/numarray/template.valarray/valarray.cons
passed 10 tests in /test/numerics/numarray/template.valarray/valarray.members
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.sub
passed 4 tests in /test/numerics/numarray/template.valarray/valarray.unary
passed 1 tests in /test/numerics/numarray/valarray.nonmembers
passed 30 tests in /test/numerics/numarray/valarray.nonmembers/valarray.binary
passed 24 tests in /test/numerics/numarray/valarray.nonmembers/valarray.comparison
passed 1 tests in /test/numerics/numarray/valarray.nonmembers/valarray.special
./testit: line 96: 37123 Abort trap              ./a.out
acos_valarray.pass.cpp failed at run time
./testit: line 96: 37131 Abort trap              ./a.out
asin_valarray.pass.cpp failed at run time
./testit: line 96: 37138 Abort trap              ./a.out
atan2_valarray_valarray.pass.cpp failed at run time
./testit: line 96: 37145 Abort trap              ./a.out
atan2_valarray_value.pass.cpp failed at run time
./testit: line 96: 37152 Abort trap              ./a.out
atan2_value_valarray.pass.cpp failed at run time
./testit: line 96: 37159 Abort trap              ./a.out
atan_valarray.pass.cpp failed at run time
./testit: line 96: 37166 Abort trap              ./a.out
cos_valarray.pass.cpp failed at run time
./testit: line 96: 37173 Abort trap              ./a.out
cosh_valarray.pass.cpp failed at run time
./testit: line 96: 37180 Abort trap              ./a.out
exp_valarray.pass.cpp failed at run time
./testit: line 96: 37187 Abort trap              ./a.out
log10_valarray.pass.cpp failed at run time
./testit: line 96: 37194 Abort trap              ./a.out
log_valarray.pass.cpp failed at run time
./testit: line 96: 37201 Abort trap              ./a.out
pow_valarray_valarray.pass.cpp failed at run time
./testit: line 96: 37208 Abort trap              ./a.out
pow_valarray_value.pass.cpp failed at run time
./testit: line 96: 37215 Abort trap              ./a.out
pow_value_valarray.pass.cpp failed at run time
./testit: line 96: 37222 Abort trap              ./a.out
sin_valarray.pass.cpp failed at run time
./testit: line 96: 37229 Abort trap              ./a.out
sinh_valarray.pass.cpp failed at run time
./testit: line 96: 37236 Abort trap              ./a.out
sqrt_valarray.pass.cpp failed at run time
./testit: line 96: 37243 Abort trap              ./a.out
tan_valarray.pass.cpp failed at run time
./testit: line 96: 37250 Abort trap              ./a.out
tanh_valarray.pass.cpp failed at run time
failed 19 tests in /test/numerics/numarray/valarray.nonmembers/valarray.transcend
passed 1 tests in /test/numerics/numarray/valarray.nonmembers/valarray.transcend
passed 4 tests in /test/numerics/numarray/valarray.range
passed 1 tests in /test/numerics/numarray/valarray.syn
passed 1 tests in /test/numerics/numeric.ops
passed 2 tests in /test/numerics/numeric.ops/accumulate
passed 2 tests in /test/numerics/numeric.ops/adjacent.difference
passed 2 tests in /test/numerics/numeric.ops/inner.product
not implemented:  /test/numerics/numeric.ops/numeric.iota
passed 2 tests in /test/numerics/numeric.ops/partial.sum
passed 1 tests in /test/numerics/numeric.requirements
not implemented:  /test/numerics/numerics.general
not implemented:  /test/numerics/rand
not implemented:  /test/numerics/rand/rand.adapt
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.disc
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.ibits
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.shuf
not implemented:  /test/numerics/rand/rand.device
not implemented:  /test/numerics/rand/rand.dis
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bernoulli
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bin
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.geo
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.negbin
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.cauchy
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.chisq
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.f
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.lognormal
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.normal
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.t
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.exp
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.extreme
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.gamma
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.poisson
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.weibull
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.discrete
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.genpdf
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.pconst
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.int
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.real
not implemented:  /test/numerics/rand/rand.eng
not implemented:  /test/numerics/rand/rand.eng/rand.eng.lcong
not implemented:  /test/numerics/rand/rand.eng/rand.eng.mers
not implemented:  /test/numerics/rand/rand.eng/rand.eng.sub
not implemented:  /test/numerics/rand/rand.predef
not implemented:  /test/numerics/rand/rand.req
not implemented:  /test/numerics/rand/rand.req/rand.req.adapt
not implemented:  /test/numerics/rand/rand.req/rand.req.dst
not implemented:  /test/numerics/rand/rand.req/rand.req.eng
not implemented:  /test/numerics/rand/rand.req/rand.req.genl
not implemented:  /test/numerics/rand/rand.req/rand.req.seedseq
not implemented:  /test/numerics/rand/rand.req/rand.req.urng
not implemented:  /test/numerics/rand/rand.synopsis
not implemented:  /test/numerics/rand/rand.util
not implemented:  /test/numerics/rand/rand.util/rand.util.canonical
not implemented:  /test/numerics/rand/rand.util/rand.util.seedseq
not implemented:  /test/re
not implemented:  /test/re/re.alg
not implemented:  /test/re/re.alg/re.alg.match
not implemented:  /test/re/re.alg/re.alg.replace
not implemented:  /test/re/re.alg/re.alg.search
not implemented:  /test/re/re.alg/re.except
not implemented:  /test/re/re.badexp
not implemented:  /test/re/re.const
not implemented:  /test/re/re.const/re.err
not implemented:  /test/re/re.const/re.matchflag
not implemented:  /test/re/re.const/re.synopt
not implemented:  /test/re/re.def
not implemented:  /test/re/re.def/defns.regex.collating.element
not implemented:  /test/re/re.def/defns.regex.finite.state.machine
not implemented:  /test/re/re.def/defns.regex.format.specifier
not implemented:  /test/re/re.def/defns.regex.matched
not implemented:  /test/re/re.def/defns.regex.primary.equivalence.class
not implemented:  /test/re/re.def/defns.regex.regular.expression
not implemented:  /test/re/re.def/defns.regex.subexpression
not implemented:  /test/re/re.general
not implemented:  /test/re/re.grammar
not implemented:  /test/re/re.iter
not implemented:  /test/re/re.iter/re.regiter
not implemented:  /test/re/re.iter/re.regiter/re.regiter.cnstr
not implemented:  /test/re/re.iter/re.regiter/re.regiter.comp
not implemented:  /test/re/re.iter/re.regiter/re.regiter.deref
not implemented:  /test/re/re.iter/re.regiter/re.regiter.incr
not implemented:  /test/re/re.iter/re.tokiter
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.cnstr
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.comp
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.deref
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.incr
not implemented:  /test/re/re.regex
not implemented:  /test/re/re.regex/re.regex.assign
not implemented:  /test/re/re.regex/re.regex.const
not implemented:  /test/re/re.regex/re.regex.construct
not implemented:  /test/re/re.regex/re.regex.locale
not implemented:  /test/re/re.regex/re.regex.nonmemb
not implemented:  /test/re/re.regex/re.regex.nonmemb/re.regex.nmswap
not implemented:  /test/re/re.regex/re.regex.operations
not implemented:  /test/re/re.regex/re.regex.swap
not implemented:  /test/re/re.req
not implemented:  /test/re/re.results
not implemented:  /test/re/re.results/re.results.acc
not implemented:  /test/re/re.results/re.results.all
not implemented:  /test/re/re.results/re.results.const
not implemented:  /test/re/re.results/re.results.form
not implemented:  /test/re/re.results/re.results.nonmember
not implemented:  /test/re/re.results/re.results.size
not implemented:  /test/re/re.results/re.results.swap
not implemented:  /test/re/re.submatch
not implemented:  /test/re/re.submatch/re.submatch.members
not implemented:  /test/re/re.submatch/re.submatch.op
not implemented:  /test/re/re.syn
not implemented:  /test/re/re.traits
passed 1 tests in /test/strings
passed 1 tests in /test/strings/basic.string
passed 4 tests in /test/strings/basic.string/string.access
passed 10 tests in /test/strings/basic.string/string.capacity
passed 16 tests in /test/strings/basic.string/string.cons
passed 8 tests in /test/strings/basic.string/string.iterators
passed 1 tests in /test/strings/basic.string/string.modifiers
passed 8 tests in /test/strings/basic.string/string.modifiers/string::append
passed 8 tests in /test/strings/basic.string/string.modifiers/string::assign
passed 1 tests in /test/strings/basic.string/string.modifiers/string::copy
passed 4 tests in /test/strings/basic.string/string.modifiers/string::erase
passed 9 tests in /test/strings/basic.string/string.modifiers/string::insert
passed 4 tests in /test/strings/basic.string/string.modifiers/string::op+=
passed 11 tests in /test/strings/basic.string/string.modifiers/string::replace
passed 1 tests in /test/strings/basic.string/string.modifiers/string::swap
passed 1 tests in /test/strings/basic.string/string.nonmembers
./testit: line 96: 38398 Abort trap              ./a.out
get_line.pass.cpp failed at run time
./testit: line 96: 38406 Abort trap              ./a.out
get_line_delim.pass.cpp failed at run time
./testit: line 96: 38427 Abort trap              ./a.out
stream_extract.pass.cpp failed at run time
./testit: line 96: 38434 Abort trap              ./a.out
stream_insert.pass.cpp failed at run time
failed 4 tests in /test/strings/basic.string/string.nonmembers/string.io
passed 2 tests in /test/strings/basic.string/string.nonmembers/string.io
passed 1 tests in /test/strings/basic.string/string.nonmembers/string.special
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::op!=
passed 5 tests in /test/strings/basic.string/string.nonmembers/string::op+
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::operator==
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::opgt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::opgt=
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::oplt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::oplt=
passed 1 tests in /test/strings/basic.string/string.ops
passed 3 tests in /test/strings/basic.string/string.ops/string.accessors
passed 6 tests in /test/strings/basic.string/string.ops/string::compare
passed 4 tests in /test/strings/basic.string/string.ops/string::find
passed 4 tests in /test/strings/basic.string/string.ops/string::find.first.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.first.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.last.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.last.of
passed 4 tests in /test/strings/basic.string/string.ops/string::rfind
passed 1 tests in /test/strings/basic.string/string.ops/string::substr
passed 1 tests in /test/strings/basic.string/string.require
passed 1 tests in /test/strings/basic.string.hash
cuchar.pass.cpp:26:10: fatal error: 'cuchar' file not found
#include <cuchar>
         ^
1 error generated.
cuchar.pass.cpp failed to compile
failed 1 tests in /test/strings/c.strings
passed 4 tests in /test/strings/c.strings
passed 1 tests in /test/strings/char.traits
passed 1 tests in /test/strings/char.traits/char.traits.require
passed 1 tests in /test/strings/char.traits/char.traits.specializations
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char32_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.wchar.t
passed 1 tests in /test/strings/char.traits/char.traits.typedefs
passed 1 tests in /test/strings/string.classes
not implemented:  /test/strings/string.conversions
not implemented:  /test/strings/strings.general
passed 1 tests in /test/thread
passed 1 tests in /test/thread/futures
not implemented:  /test/thread/futures/futures.async
not implemented:  /test/thread/futures/futures.atomic_future
not implemented:  /test/thread/futures/futures.errors
not implemented:  /test/thread/futures/futures.future_error
passed 3 tests in /test/thread/futures/futures.overview
not implemented:  /test/thread/futures/futures.promise
not implemented:  /test/thread/futures/futures.shared_future
not implemented:  /test/thread/futures/futures.state
not implemented:  /test/thread/futures/futures.tas
not implemented:  /test/thread/futures/futures.tas/futures.taask.nonmembers
not implemented:  /test/thread/futures/futures.tas/futures.task.members
not implemented:  /test/thread/futures/futures.unique_future
passed 1 tests in /test/thread/thread.condition
passed 13 tests in /test/thread/thread.condition/thread.condition.condvar
passed 12 tests in /test/thread/thread.condition/thread.condition.condvarany
passed 1 tests in /test/thread/thread.general
passed 1 tests in /test/thread/thread.mutex
passed 1 tests in /test/thread/thread.mutex/thread.lock
passed 6 tests in /test/thread/thread.mutex/thread.lock/thread.lock.guard
passed 1 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique
passed 11 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.cons
passed 5 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.locking
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.mod
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.obs
passed 2 tests in /test/thread/thread.mutex/thread.lock.algorithm
passed 1 tests in /test/thread/thread.mutex/thread.mutex.requirements
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.class
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.recursive
passed 1 tests in /test/thread/thread.mutex/thread.once
passed 1 tests in /test/thread/thread.mutex/thread.once/thread.once.callonce
passed 3 tests in /test/thread/thread.mutex/thread.once/thread.once.onceflag
passed 1 tests in /test/thread/thread.mutex/thread.timedmutex.requirements
passed 7 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.class
passed 7 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.recursive
passed 1 tests in /test/thread/thread.req
passed 1 tests in /test/thread/thread.req/thread.req.exception
passed 1 tests in /test/thread/thread.req/thread.req.native
passed 1 tests in /test/thread/thread.req/thread.req.paramname
passed 1 tests in /test/thread/thread.req/thread.req.timing
passed 1 tests in /test/thread/thread.threads
passed 1 tests in /test/thread/thread.threads/thread.thread.class
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.algorithm
passed 2 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.assign
passed 4 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.constr
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.destr
./testit: line 96: 40449 Abort trap              ./a.out
stream.pass.cpp failed at run time
failed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.id
passed 6 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.id
passed 6 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.member
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.static
passed 4 tests in /test/thread/thread.threads/thread.thread.this
passed 1 tests in /test/utilities
passed 1 tests in /test/utilities/date.time
passed 1 tests in /test/utilities/function.objects
passed 6 tests in /test/utilities/function.objects/arithmetic.operations
passed 1 tests in /test/utilities/function.objects/base
passed 1 tests in /test/utilities/function.objects/bind
passed 1 tests in /test/utilities/function.objects/bind/func.bind
invoke_int_0.pass.cpp:58:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:59:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:60:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:61:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()), 5);
               ~~~~~^
invoke_int_0.pass.cpp:63:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:64:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:65:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:66:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<int>(A_int_0()), 5);
               ~~~~~^
8 errors generated.
invoke_int_0.pass.cpp failed to compile
invoke_lvalue.pass.cpp:64:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:70:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:78:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:85:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:93:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:100:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:108:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:112:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:119:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:123:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:131:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:135:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:142:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:146:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:179:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:179:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(i) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:180:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, i)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:180:17: note: instantiated from:
    assert(std::bind(f_int_1, i)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:186:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(i) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:186:17: note: instantiated from:
    assert(std::bind(fp, _1)(i) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:187:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, i)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:187:17: note: instantiated from:
    assert(std::bind(fp, i)() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:192:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:192:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(i) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:193:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), i)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:193:17: note: instantiated from:
    assert(std::bind(A_int_1(), i)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:198:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(a) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:198:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(a) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:199:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, a)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:199:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, a)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:201:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(ap) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:201:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(ap) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:202:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, ap)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:202:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, ap)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:207:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:207:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:208:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:208:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:210:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(ap) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:210:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(ap) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:211:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, ap)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:211:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, ap)() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:216:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:216:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:217:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, a)() == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:217:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, a)() == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:219:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:219:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:220:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(a) = 6;
    ~~~~~^
invoke_lvalue.pass.cpp:221:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:221:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
           ~~~~~^
invoke_lvalue.pass.cpp:222:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(ap) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:222:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(ap) == 6);
           ~~~~~^
invoke_lvalue.pass.cpp:223:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(ap) = 7;
    ~~~~~^
invoke_lvalue.pass.cpp:224:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(ap) == 7);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:224:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(ap) == 7);
           ~~~~~^
invoke_lvalue.pass.cpp:255:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, _1, _2)(i, j);
    ~~~~~^
invoke_lvalue.pass.cpp:258:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, i, _1)(j);
    ~~~~~^
invoke_lvalue.pass.cpp:261:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, i, j)();
    ~~~~~^
invoke_lvalue.pass.cpp:268:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _1, _2)(A_void_2(), j);
    ~~~~~^
invoke_lvalue.pass.cpp:271:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _2, _1)(j, A_void_2());
    ~~~~~^
41 errors generated.
invoke_lvalue.pass.cpp failed to compile
invoke_rvalue.pass.cpp:63:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(2);
    ~~~~~^
invoke_rvalue.pass.cpp:68:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, 2)();
    ~~~~~^
invoke_rvalue.pass.cpp:75:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(3);
    ~~~~~^
invoke_rvalue.pass.cpp:81:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, 3)();
    ~~~~~^
invoke_rvalue.pass.cpp:88:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(4);
    ~~~~~^
invoke_rvalue.pass.cpp:94:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, 4)();
    ~~~~~^
invoke_rvalue.pass.cpp:101:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:105:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:111:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:115:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:122:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:126:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:132:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:136:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:168:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(2) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:168:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(2) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:169:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, 2)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:169:17: note: instantiated from:
    assert(std::bind(f_int_1, 2)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:174:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(3) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:174:17: note: instantiated from:
    assert(std::bind(fp, _1)(3) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:175:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, 3)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:175:17: note: instantiated from:
    assert(std::bind(fp, 3)() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:179:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(4) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:179:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(4) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:180:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), 4)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:180:17: note: instantiated from:
    assert(std::bind(A_int_1(), 4)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:184:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(A_int_1()) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:184:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(A_int_1()) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:185:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, A_int_1())() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:185:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, A_int_1())() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:187:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(&a) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:187:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(&a) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:188:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, &a)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:188:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, &a)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:192:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:192:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:193:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:193:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:195:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(&a) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:195:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(&a) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:196:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, &a)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:196:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, &a)() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:200:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(A_int_1()) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:200:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(A_int_1()) == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:201:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, A_int_1())() == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:201:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, A_int_1())() == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:203:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:203:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:204:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(a) = 6;
    ~~~~~^
invoke_rvalue.pass.cpp:205:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:205:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
           ~~~~~^
invoke_rvalue.pass.cpp:206:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(&a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:206:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(&a) == 6);
           ~~~~~^
invoke_rvalue.pass.cpp:207:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(&a) = 7;
    ~~~~~^
invoke_rvalue.pass.cpp:208:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(&a) == 7);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:208:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(&a) == 7);
           ~~~~~^
invoke_rvalue.pass.cpp:237:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, _1, _2)(2, 3);
    ~~~~~^
invoke_rvalue.pass.cpp:240:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, 2, _1)(3);
    ~~~~~^
invoke_rvalue.pass.cpp:243:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, 2, 3)();
    ~~~~~^
invoke_rvalue.pass.cpp:249:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _1, _2)(A_void_2(), 3);
    ~~~~~^
invoke_rvalue.pass.cpp:252:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _2, _1)(3, A_void_2());
    ~~~~~^
41 errors generated.
invoke_rvalue.pass.cpp failed to compile
invoke_void_0.pass.cpp:64:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f));
         ~~~~~^
invoke_void_0.pass.cpp:65:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f));
         ~~~~~^
invoke_void_0.pass.cpp:66:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:67:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()));
               ~~~~~^
invoke_void_0.pass.cpp:69:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(f));
         ~~~~~^
invoke_void_0.pass.cpp:70:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(&f));
         ~~~~~^
invoke_void_0.pass.cpp:71:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:72:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<void>(A_int_0()));
               ~~~~~^
8 errors generated.
invoke_void_0.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/bind/func.bind/func.bind.bind
is_bind_expression.pass.cpp:41:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C()));
               ~~~~~^
is_bind_expression.pass.cpp:42:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C(), std::placeholders::_2));
               ~~~~~^
is_bind_expression.pass.cpp:43:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind<int>(C()));
               ~~~~~^
3 errors generated.
is_bind_expression.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isbind
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isbind
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.place
passed 3 tests in /test/utilities/function.objects/bitwise.operations
passed 6 tests in /test/utilities/function.objects/comparisons
passed 1 tests in /test/utilities/function.objects/func.def
member_function.pass.cpp:45:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:45:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function.pass.cpp:77:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function.pass.cpp:47:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:47:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<is_base_of<A, remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:45:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function.pass.cpp:45:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function.pass.cpp:77:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:47:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function.pass.cpp:47:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function.pass.cpp:77:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function.pass.cpp:57:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:57:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function.pass.cpp:78:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:1012:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:1012:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:71:8: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
       ^
../../../../include/__functional_03:72:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function.pass.cpp:79:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function.pass.cpp:69:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:69:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function.pass.cpp:79:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
2 warnings and 5 errors generated.
member_function.pass.cpp failed to compile
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:123:12: error: functional-style cast from 'char (A::*)() const' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_const.pass.cpp:45:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:45:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_const.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_const.pass.cpp:47:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:47:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_const.pass.cpp:49:5: warning: comparison between pointer and integer ('__apply_cv<A const, char ()>::type *' and 'int') [-pedantic]
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:49:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<is_base_of<A, remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:45:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_const.pass.cpp:45:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_const.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:47:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_const.pass.cpp:47:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_const.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A const, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A const *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:49:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A const *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_const.pass.cpp:49:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_const.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:131:12: error: functional-style cast from 'char (A::*)(int) const' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:139:12: error: functional-style cast from 'char (A::*)(int, double) const' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:1012:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:1012:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:71:8: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
       ^
../../../../include/__functional_03:72:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_const.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_const.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_const.pass.cpp failed to compile
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:187:12: error: functional-style cast from 'char (A::*)() const volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_const_volatile.pass.cpp:45:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:45:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_const_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_const_volatile.pass.cpp:47:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:47:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_const_volatile.pass.cpp:49:5: warning: comparison between pointer and integer ('__apply_cv<A const volatile, char ()>::type *' and 'int') [-pedantic]
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:49:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<is_base_of<A, remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:45:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_const_volatile.pass.cpp:45:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_const_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:47:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_const_volatile.pass.cpp:47:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_const_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A const volatile, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A const volatile *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:49:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A const volatile *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_const_volatile.pass.cpp:49:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_const_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:195:12: error: functional-style cast from 'char (A::*)(int) const volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const_volatile.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:203:12: error: functional-style cast from 'char (A::*)(int, double) const volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:1012:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:1012:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:71:8: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
       ^
../../../../include/__functional_03:72:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_const_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_const_volatile.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_const_volatile.pass.cpp failed to compile
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:155:12: error: functional-style cast from 'char (A::*)() volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
member_function_volatile.pass.cpp:45:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(a) == 'a');
    ^~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:45:17: note: instantiated from:
    assert(f(a) == 'a');
           ~~~~ ^  ~~~
member_function_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
member_function_volatile.pass.cpp:47:5: warning: comparison between pointer and integer ('__apply_cv<A, char ()>::type *' and 'int') [-pedantic]
    assert(f(ap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:47:18: note: instantiated from:
    assert(f(ap) == 'a');
           ~~~~~ ^  ~~~
member_function_volatile.pass.cpp:49:5: warning: comparison between pointer and integer ('__apply_cv<A volatile, char ()>::type *' and 'int') [-pedantic]
    assert(f(cap) == 'a');
    ^~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:49:19: note: instantiated from:
    assert(f(cap) == 'a');
           ~~~~~~ ^  ~~~
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<is_base_of<A, remove_reference<A>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:45:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A>' requested here
    assert(f(a) == 'a');
    ^
member_function_volatile.pass.cpp:45:12: note: instantiated from:
    assert(f(a) == 'a');
           ^
member_function_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:47:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A *>' requested here
    assert(f(ap) == 'a');
    ^
member_function_volatile.pass.cpp:47:12: note: instantiated from:
    assert(f(ap) == 'a');
           ^
member_function_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:60:22: error: non-const lvalue reference to type '__apply_cv<A volatile, char ()>::type' (aka 'char ()') cannot bind to a temporary of type 'enable_if<!is_base_of<A, remove_reference<A volatile *>::type>::value, char>::type' (aka 'char')
              return __invoke(__f_, __a0);
                     ^~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:49:5: note: in instantiation of function template specialization 'std::__mem_fn<char (A::*)()>::operator()<A volatile *>' requested here
    assert(f(cap) == 'a');
    ^
member_function_volatile.pass.cpp:49:12: note: instantiated from:
    assert(f(cap) == 'a');
           ^
member_function_volatile.pass.cpp:83:5: note: in instantiation of function template specialization 'test0<std::__mem_fn<char (A::*)()> >' requested here
    test0(std::mem_fn(&A::test0));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:163:12: error: functional-style cast from 'char (A::*)(int) volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_volatile.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:171:12: error: functional-style cast from 'char (A::*)(int, double) volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:1012:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:1012:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_Tp>(), _STD::declval<_A0>(),
                     ^~~~~~~~
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:71:8: note: in instantiation of template class 'std::__invoke_return2<char (A::*)(int, double), A, int, int>' requested here
       typename __invoke_return2<type, _A0, _A1, _A2>::type
       ^
../../../../include/__functional_03:72:11: note: while substituting deduced template arguments into function template 'operator()' [with $0 = A, $1 = int, $2 = int]
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
member_function_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
member_function_volatile.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:905:
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
3 warnings and 9 errors generated.
member_function_volatile.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.require
passed 1 tests in /test/utilities/function.objects/func.wrap
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall/func.wrap.badcall.const
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.alg
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.cap
alloc.pass.cpp:35:2: error: #error template<class A> function(allocator_arg_t, const A&); not implemented
#error template<class A> function(allocator_arg_t, const A&); not implemented
 ^
1 error generated.
alloc.pass.cpp failed to compile
alloc_F.pass.cpp:35:2: error: #error template<class F, class A> function(allocator_arg_t, const A&, F); not implemented
#error template<class F, class A> function(allocator_arg_t, const A&, F); not implemented
 ^
1 error generated.
alloc_F.pass.cpp failed to compile
alloc_function.pass.cpp:35:2: error: #error template<class A> function(allocator_arg_t, const A&, const function&); not implemented
#error template<class A> function(allocator_arg_t, const A&, const function&); not implemented
 ^
1 error generated.
alloc_function.pass.cpp failed to compile
alloc_nullptr.pass.cpp:35:2: error: #error template<class A> function(allocator_arg_t, const A&, nullptr_t); not implemented
#error template<class A> function(allocator_arg_t, const A&, nullptr_t); not implemented
 ^
1 error generated.
alloc_nullptr.pass.cpp failed to compile
alloc_rfunction.pass.cpp:35:2: error: #error template<class A> function(allocator_arg_t, const A&, function&&); not implemented
#error template<class A> function(allocator_arg_t, const A&, function&&); not implemented
 ^
1 error generated.
alloc_rfunction.pass.cpp failed to compile
failed 5 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.con
passed 7 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.con
In file included from invoke_int_0.pass.cpp:30:
In file included from ../../../../../../include/functional:905:
../../../../../../include/__functional_03:377:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:327:14: note: in instantiation of member function 'std::__function::__func<A_int_0, std::allocator<A_int_0>, int ()>::operator()' requested here
    explicit __func(_F __f, _Alloc __a) : __f_(_STD::move(__f), _STD::move(__a)) {}
             ^
In file included from invoke_int_0.pass.cpp:30:
In file included from ../../../../../../include/functional:510:
In file included from ../../../../../../include/memory:217:
In file included from ../../../../../../include/__functional_base:71:
../../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke_int_0.pass.cpp:30:
In file included from ../../../../../../include/functional:905:
../../../../../../include/__functional_03:377:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:327:14: note: in instantiation of member function 'std::__function::__func<int (*)(), std::allocator<int (*)()>, int ()>::operator()' requested here
    explicit __func(_F __f, _Alloc __a) : __f_(_STD::move(__f), _STD::move(__a)) {}
             ^
In file included from invoke_int_0.pass.cpp:30:
In file included from ../../../../../../include/functional:510:
In file included from ../../../../../../include/memory:217:
In file included from ../../../../../../include/__functional_base:71:
../../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
invoke_int_0.pass.cpp failed to compile
In file included from invoke_void_0.pass.cpp:30:
In file included from ../../../../../../include/functional:905:
../../../../../../include/__functional_03:377:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:327:14: note: in instantiation of member function 'std::__function::__func<A_void_0, std::allocator<A_void_0>, void ()>::operator()' requested here
    explicit __func(_F __f, _Alloc __a) : __f_(_STD::move(__f), _STD::move(__a)) {}
             ^
In file included from invoke_void_0.pass.cpp:30:
In file included from ../../../../../../include/functional:510:
In file included from ../../../../../../include/memory:217:
In file included from ../../../../../../include/__functional_base:71:
../../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke_void_0.pass.cpp:30:
In file included from ../../../../../../include/functional:905:
../../../../../../include/__functional_03:377:12: error: no matching function for call to '__invoke'
    return __invoke<_R>(__f_.first());
           ^~~~~~~~~~~~
../../../../../../include/__functional_03:327:14: note: in instantiation of member function 'std::__function::__func<void (*)(), std::allocator<void (*)()>, void ()>::operator()' requested here
    explicit __func(_F __f, _Alloc __a) : __f_(_STD::move(__f), _STD::move(__a)) {}
             ^
In file included from invoke_void_0.pass.cpp:30:
In file included from ../../../../../../include/functional:510:
In file included from ../../../../../../include/memory:217:
In file included from ../../../../../../include/__functional_base:71:
../../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
invoke_void_0.pass.cpp failed to compile
failed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.inv
passed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.inv
assign_F_alloc.pass.cpp:35:2: error: #error template<class F, class A> void assign(F&&, const A&); not implemented
#error template<class F, class A> void assign(F&&, const A&); not implemented
 ^
1 error generated.
assign_F_alloc.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.mod
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.mod
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.nullptr
passed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.targ
passed 4 tests in /test/utilities/function.objects/function.pointer.adaptors
passed 3 tests in /test/utilities/function.objects/logical.operations
passed 16 tests in /test/utilities/function.objects/member.pointer.adaptors
passed 4 tests in /test/utilities/function.objects/negators
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
    ^
binary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
                   ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<char, int, double>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
    ^
binary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<char, int, double>,
                   ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<float (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<float (*())(int)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:84:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:84:21: note: instantiated from:
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
                    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:84:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:84:21: note: instantiated from:
    static_assert((!std::is_base_of<std::binary_function<int, int, float>,
                    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<float (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<float (*())(int, int)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:86:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:86:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
                   ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
binary.pass.cpp:86:5: note: in instantiation of template class 'std::is_base_of<std::binary_function<int, int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
    ^
binary.pass.cpp:86:20: note: instantiated from:
    static_assert((std::is_base_of<std::binary_function<int, int, float>,
                   ^
In file included from binary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
binary.pass.cpp failed to compile
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: type 'C' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<C (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<C ()>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
type.pass.cpp:37:5: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    static_assert((std::is_same<std::reference_wrapper<C>::type,
    ^
type.pass.cpp:37:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<C>::type,
                                ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
type.pass.cpp:37:5: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    static_assert((std::is_same<std::reference_wrapper<C>::type,
    ^
type.pass.cpp:37:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<C>::type,
                                ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<int *(*())(double *), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<int *(*())(double *)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
    ^
type.pass.cpp:45:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
    ^
type.pass.cpp:45:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
                                ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
    ^
type.pass.cpp:45:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
    ^
type.pass.cpp:45:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::type,
                                ^
In file included from type.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
4 errors generated.
type.pass.cpp failed to compile
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, int>,
    ^
unary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, int>,
                   ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:72:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, int>, std::reference_wrapper<functor4> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, int>,
    ^
unary.pass.cpp:72:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, int>,
                   ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<float (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<float (*())(int)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:82:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:82:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, float>,
                   ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:82:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int)> >' requested here
    static_assert((std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:82:20: note: instantiated from:
    static_assert((std::is_base_of<std::unary_function<int, float>,
                   ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<float (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<float (*())(int, int)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = float (*)(int, int)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:84:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((!std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:84:21: note: instantiated from:
    static_assert((!std::is_base_of<std::unary_function<int, float>,
                    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<float (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:664:44: note: in instantiation of template class 'std::reference_wrapper<float (*)(int, int)>' requested here
    static const size_t __complete_check = sizeof(_Dp);
                                           ^
../../../../include/type_traits:678:38: note: in instantiation of template class 'std::__is_base_of_imp<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    : public integral_constant<bool, __is_base_of_imp<_Bp, _Dp>::value> {};
                                     ^
../../../../include/type_traits:682:7: note: in instantiation of template class 'std::__yuga_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)>, 1, 1, 0>' requested here
    : public __yuga_base_of<typename remove_cv<_Bp>::type, typename remove_cv<_Dp>::type>
      ^
unary.pass.cpp:84:5: note: in instantiation of template class 'std::is_base_of<std::unary_function<int, float>, std::reference_wrapper<float (*)(int, int)> >' requested here
    static_assert((!std::is_base_of<std::unary_function<int, float>,
    ^
unary.pass.cpp:84:21: note: instantiated from:
    static_assert((!std::is_base_of<std::unary_function<int, float>,
                    ^
In file included from unary.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
unary.pass.cpp failed to compile
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<int *(*())(double *), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<int *(*())(double *)>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int *(*)(double *)]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:85:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
    ^
weak_result.pass.cpp:85:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
                                ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int *(*&)(double *), 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:85:5: note: in instantiation of template class 'std::reference_wrapper<int *(*)(double *)>' requested here
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
    ^
weak_result.pass.cpp:85:33: note: instantiated from:
    static_assert((std::is_same<std::reference_wrapper<int*(*)(double*)>::result_type,
                                ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: type 'functor4' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<functor4 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<functor4 ()>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = functor4]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:66:66: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:66:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:94:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<functor4> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
    ^
weak_result.pass.cpp:94:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
                   ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<functor4 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:66:66: note: in instantiation of template class 'std::reference_wrapper<functor4>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:66:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:94:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<functor4> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
    ^
weak_result.pass.cpp:94:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<functor4> >::value, "");
                   ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:507:
../../../../include/type_traits:1299:13: error: type 'C' does not provide a call operator
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<C (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<C ()>' requested here
typename result_of<_F()>::type
^
../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = C]
__invoke(_F __f)
^
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:66:66: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:66:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:95:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<C> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
    ^
weak_result.pass.cpp:95:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
                   ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<C &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
weak_result.pass.cpp:66:66: note: in instantiation of template class 'std::reference_wrapper<C>' requested here
    template <class U> static char test(typename U::result_type* = 0);
                                                                 ^
weak_result.pass.cpp:66:36: note: while substituting explicitly-specified template arguments into function template 'test' 
    template <class U> static char test(typename U::result_type* = 0);
                                   ^
weak_result.pass.cpp:95:5: note: in instantiation of template class 'has_result_type<std::reference_wrapper<C> >' requested here
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
    ^
weak_result.pass.cpp:95:20: note: instantiated from:
    static_assert(!has_result_type<std::reference_wrapper<C> >::value, "");
                   ^
In file included from weak_result.pass.cpp:30:
In file included from ../../../../include/functional:510:
In file included from ../../../../include/memory:217:
In file included from ../../../../include/__functional_base:71:
../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
6 errors generated.
weak_result.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/refwrap
In file included from conversion.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
conversion.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
conversion.pass.cpp:57:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from conversion.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
conversion.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
conversion.pass.cpp:59:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from conversion.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
conversion.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.access
In file included from copy_assign.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
copy_assign.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_assign.pass.cpp:69:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from copy_assign.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
copy_assign.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_assign.pass.cpp:71:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from copy_assign.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
copy_assign.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.assign
In file included from copy_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
copy_ctor.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_ctor.pass.cpp:57:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from copy_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
copy_ctor.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
copy_ctor.pass.cpp:59:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from copy_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
copy_ctor.pass.cpp failed to compile
In file included from type_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
type_ctor.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<T> r(t);
                              ^
type_ctor.pass.cpp:56:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(i);
    ^
In file included from type_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
type_ctor.pass.cpp:42:31: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<T> r(t);
                              ^
type_ctor.pass.cpp:58:5: note: in instantiation of function template specialization 'test<int const>' requested here
    test(j);
    ^
In file included from type_ctor.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
2 errors generated.
type_ctor.pass.cpp failed to compile
failed 2 tests in /test/utilities/function.objects/refwrap/refwrap.const
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.const
In file included from cref_1.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
cref_1.pass.cpp:36:43: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<const int> r = std::cref(i);
                                          ^
In file included from cref_1.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
cref_1.pass.cpp failed to compile
In file included from cref_2.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int const &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
cref_2.pass.cpp:36:44: note: in instantiation of template class 'std::reference_wrapper<int const>' requested here
    std::reference_wrapper<const int> r1 = std::cref(i);
                                           ^
In file included from cref_2.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
cref_2.pass.cpp failed to compile
In file included from ref_1.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
ref_1.pass.cpp:36:37: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<int> r = std::ref(i);
                                    ^
In file included from ref_1.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
ref_1.pass.cpp failed to compile
In file included from ref_2.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
ref_2.pass.cpp:36:38: note: in instantiation of template class 'std::reference_wrapper<int>' requested here
    std::reference_wrapper<int> r1 = std::ref(i);
                                     ^
In file included from ref_2.pass.cpp:30:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
1 error generated.
ref_2.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<void (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<void (*())(int)>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = void (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<void (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:71:43: note: in instantiation of template class 'std::reference_wrapper<void (*)(int)>' requested here
    std::reference_wrapper<void (*)(int)> r1(fp);
                                          ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<void (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:71:43: note: in instantiation of template class 'std::reference_wrapper<void (*)(int)>' requested here
    std::reference_wrapper<void (*)(int)> r1(fp);
                                          ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: no matching function for call to object of type 'A_void_1'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<A_void_1 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<A_void_1 ()>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_void_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_void_1 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:80:38: note: in instantiation of template class 'std::reference_wrapper<A_void_1>' requested here
    std::reference_wrapper<A_void_1> r1(a0);
                                     ^
invoke.pass.cpp:47:10: note: candidate function not viable: requires 1 argument, but 0 were provided
    void operator()(int i)
         ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_void_1 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:80:38: note: in instantiation of template class 'std::reference_wrapper<A_void_1>' requested here
    std::reference_wrapper<A_void_1> r1(a0);
                                     ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<int (*())(int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<int (*())(int)>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int (*)(int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:146:42: note: in instantiation of template class 'std::reference_wrapper<int (*)(int)>' requested here
    std::reference_wrapper<int (*)(int)> r1(fp);
                                         ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int (*&)(int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:146:42: note: in instantiation of template class 'std::reference_wrapper<int (*)(int)>' requested here
    std::reference_wrapper<int (*)(int)> r1(fp);
                                         ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: no matching function for call to object of type 'A_int_1'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<A_int_1 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<A_int_1 ()>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_int_1]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_int_1 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:153:37: note: in instantiation of template class 'std::reference_wrapper<A_int_1>' requested here
    std::reference_wrapper<A_int_1> r1(a0);
                                    ^
invoke.pass.cpp:124:9: note: candidate function not viable: requires 1 argument, but 0 were provided
    int operator()(int i)
        ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_int_1 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:153:37: note: in instantiation of template class 'std::reference_wrapper<A_int_1>' requested here
    std::reference_wrapper<A_int_1> r1(a0);
                                    ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
invoke.pass.cpp:181:11: error: expression is not assignable
    r1(a) = 6;
    ~~~~~ ^
invoke.pass.cpp:185:12: error: expression is not assignable
    r1(ap) = 7;
    ~~~~~~ ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<void (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<void (*())(int, int)>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = void (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<void (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:224:48: note: in instantiation of template class 'std::reference_wrapper<void (*)(int, int)>' requested here
    std::reference_wrapper<void (*)(int, int)> r1(fp);
                                               ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<void (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:224:48: note: in instantiation of template class 'std::reference_wrapper<void (*)(int, int)>' requested here
    std::reference_wrapper<void (*)(int, int)> r1(fp);
                                               ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: no matching function for call to object of type 'A_void_2'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<A_void_2 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<A_void_2 ()>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_void_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_void_2 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:234:38: note: in instantiation of template class 'std::reference_wrapper<A_void_2>' requested here
    std::reference_wrapper<A_void_2> r1(a0);
                                     ^
invoke.pass.cpp:199:10: note: candidate function not viable: requires 2 arguments, but 0 were provided
    void operator()(int i, int j)
         ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_void_2 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:234:38: note: in instantiation of template class 'std::reference_wrapper<A_void_2>' requested here
    std::reference_wrapper<A_void_2> r1(a0);
                                     ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: too few arguments to function call
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:37: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ~~~~~~~~~~~~~~ ^
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<int (*())(int, int), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<int (*())(int, int)>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = int (*)(int, int)]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:302:47: note: in instantiation of template class 'std::reference_wrapper<int (*)(int, int)>' requested here
    std::reference_wrapper<int (*)(int, int)> r1(fp);
                                              ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<int (*&)(int, int), 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:302:47: note: in instantiation of template class 'std::reference_wrapper<int (*)(int, int)>' requested here
    std::reference_wrapper<int (*)(int, int)> r1(fp);
                                              ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:507:
../../../../../include/type_traits:1299:13: error: no matching function for call to object of type 'A_int_2'
    typedef decltype(declval<_Fn>()()) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/type_traits:1299:22: note: instantiated from:
    typedef decltype(declval<_Fn>()()) type;
                     ^~~~~~~~~~~~~~
../../../../../include/type_traits:1325:7: note: in instantiation of template class 'std::__result_of<A_int_2 (), 1>' requested here
    : public __result_of<_Fn(),
      ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:895:1: note: in instantiation of template class 'std::result_of<A_int_2 ()>' requested here
typename result_of<_F()>::type
^
../../../../../include/__functional_base_03:896:1: note: while substituting deduced template arguments into function template '__invoke' [with _F = A_int_2]
__invoke(_F __f)
^
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_int_2 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:310:37: note: in instantiation of template class 'std::reference_wrapper<A_int_2>' requested here
    std::reference_wrapper<A_int_2> r1(a0);
                                    ^
invoke.pass.cpp:280:9: note: candidate function not viable: requires 2 arguments, but 0 were provided
    int operator()(int i, int j)
        ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:981:13: error: no matching function for call to '__invoke'
    typedef decltype(__invoke(_STD::declval<_F>())) type;
            ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
../../../../../include/__functional_base_03:981:22: note: instantiated from:
    typedef decltype(__invoke(_STD::declval<_F>())) type;
                     ^~~~~~~~
../../../../../include/__functional_base_03:1037:5: note: in instantiation of template class 'std::__invoke_return<A_int_2 &, 0>' requested here
    typename __invoke_return<type&>::type
    ^
invoke.pass.cpp:310:37: note: in instantiation of template class 'std::reference_wrapper<A_int_2>' requested here
    std::reference_wrapper<A_int_2> r1(a0);
                                    ^
In file included from invoke.pass.cpp:33:
In file included from ../../../../../include/functional:510:
In file included from ../../../../../include/memory:217:
In file included from ../../../../../include/__functional_base:71:
../../../../../include/__functional_base_03:442:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1& __t1)
^
../../../../../include/__functional_base_03:454:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:466:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:478:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:490:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1& __t1)
^
../../../../../include/__functional_base_03:502:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:514:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:526:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:538:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:550:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:562:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:574:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:586:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1& __t1)
^
../../../../../include/__functional_base_03:598:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1& __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:610:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1& __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:622:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1& __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:636:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(), _T1 __t1)
^
../../../../../include/__functional_base_03:648:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0), _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:660:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1), _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:672:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2), _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:684:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const, _T1 __t1)
^
../../../../../include/__functional_base_03:696:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:708:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:720:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:732:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:744:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:756:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:768:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:780:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)() const volatile, _T1 __t1)
^
../../../../../include/__functional_base_03:792:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0) const volatile, _T1 __t1, _A0& __a0)
^
../../../../../include/__functional_base_03:804:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1) const volatile, _T1 __t1, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:816:1: note: candidate template ignored: failed template argument deduction
__invoke(_R (_T::*__f)(_A0, _A1, _A2) const volatile, _T1 __t1, _A0& __a0, _A1& __a1, _A2& __a2)
^
../../../../../include/__functional_base_03:830:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:838:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::*)
^
../../../../../include/__functional_base_03:874:1: note: candidate template ignored: failed template argument deduction
__invoke(_R _T::* __f, _T1& __t1)
^
../../../../../include/__functional_base_03:896:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f)
^
../../../../../include/__functional_base_03:904:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0)
^
../../../../../include/__functional_base_03:912:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1)
^
../../../../../include/__functional_base_03:920:1: note: candidate template ignored: failed template argument deduction
__invoke(_F __f, _A0& __a0, _A1& __a1, _A2& __a2)
^
18 errors generated.
invoke.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 3 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 4 tests in /test/utilities/function.objects/unord.hash
passed 1 tests in /test/utilities/memory
passed 1 tests in /test/utilities/memory/allocator.adaptor
passed 5 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.cnstr
passed 9 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.members
passed 4 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.types
passed 1 tests in /test/utilities/memory/allocator.tag
passed 3 tests in /test/utilities/memory/allocator.traits
passed 7 tests in /test/utilities/memory/allocator.traits/allocator.traits.members
passed 10 tests in /test/utilities/memory/allocator.traits/allocator.traits.types
passed 1 tests in /test/utilities/memory/allocator.uses
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.construction
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.trait
passed 1 tests in /test/utilities/memory/c.malloc
passed 2 tests in /test/utilities/memory/default.allocator
passed 1 tests in /test/utilities/memory/default.allocator/allocator.globals
passed 4 tests in /test/utilities/memory/default.allocator/allocator.members
passed 5 tests in /test/utilities/memory/pointer.traits
passed 1 tests in /test/utilities/memory/pointer.traits/pointer.traits.functions
passed 3 tests in /test/utilities/memory/pointer.traits/pointer.traits.types
passed 1 tests in /test/utilities/memory/ptr.align
passed 1 tests in /test/utilities/memory/specialized.algorithms
passed 1 tests in /test/utilities/memory/specialized.algorithms/specialized.addressof
passed 2 tests in /test/utilities/memory/specialized.algorithms/uninitialized.copy
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill.n
passed 1 tests in /test/utilities/memory/storage.iterator
passed 1 tests in /test/utilities/memory/temporary.buffer
passed 1 tests in /test/utilities/memory/unique.ptr
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt1
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.general
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-evievH.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
move01.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
passed 17 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
default01.fail.cpp should not compile
pointer01.fail.cpp should not compile
pointer_deleter04.fail.cpp should not compile
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-fsJtIx.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
move01.pass.cpp failed to compile
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-1cTGZX.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
pointer_deleter01.pass.cpp failed to compile
failed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
passed 37 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-pzn3T4.o
      _main in cc-pzn3T4.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.observers
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single
move_convert13.fail.cpp should not compile
Assertion failed: (s2.get() == p), function main, file move01.pass.cpp, line 57.
./testit: line 96: 42373 Abort trap              ./a.out
move01.pass.cpp failed at run time
In file included from move_convert01.pass.cpp:30:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1213:12: error: non-const lvalue reference to type 'std::default_delete<A>' cannot bind to a value of unrelated type 'std::default_delete<B>'
    return t;
           ^
In file included from move_convert01.pass.cpp:30:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<std::default_delete<A>, std::default_delete<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert01.pass.cpp:30:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert01.pass.cpp:61:8: note: in instantiation of function template specialization 'std::unique_ptr<A, std::default_delete<A> >::operator=<B, std::default_delete<B> >' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert01.pass.cpp failed to compile
In file included from move_convert02.pass.cpp:30:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1225:14: error: functional-style cast from 'Deleter<B>' to '__rv<Deleter<A> >' is not allowed
    return T(__rv<T>(t));
             ^~~~~~~~
In file included from move_convert02.pass.cpp:30:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<Deleter<A>, Deleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert02.pass.cpp:30:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert02.pass.cpp:63:8: note: in instantiation of function template specialization 'std::unique_ptr<A, Deleter<A> >::operator=<B, Deleter<B> >' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert02.pass.cpp failed to compile
In file included from move_convert03.pass.cpp:32:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1213:12: error: non-const lvalue reference to type 'CDeleter<A>' cannot bind to a value of unrelated type 'CDeleter<B>'
    return t;
           ^
In file included from move_convert03.pass.cpp:32:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<CDeleter<A> &, CDeleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert03.pass.cpp:32:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert03.pass.cpp:66:8: note: in instantiation of function template specialization 'std::unique_ptr<A, CDeleter<A> &>::operator=<B, CDeleter<B> &>' requested here
    s2 = std::move(s);
       ^
1 error generated.
move_convert03.pass.cpp failed to compile
failed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
passed 12 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
default01.fail.cpp should not compile
pointer01.fail.cpp should not compile
pointer_deleter04.fail.cpp should not compile
move_convert01.pass.cpp:63:24: error: no matching constructor for initialization of 'std::unique_ptr<A>'
    std::unique_ptr<A> s2(std::move(s));
                       ^  ~~~~~~~~~~~~
In file included from move_convert01.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
1 error generated.
move_convert01.pass.cpp failed to compile
move_convert02.pass.cpp:65:37: error: no matching constructor for initialization of 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2(std::move(s));
                                    ^  ~~~~~~~~~~~~
In file included from move_convert02.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
1 error generated.
move_convert02.pass.cpp failed to compile
move_convert03.pass.cpp:81:38: error: no matching constructor for initialization of 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2(std::move(s));
                                     ^  ~~~~~~~~~~~~
In file included from move_convert03.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
1 error generated.
move_convert03.pass.cpp failed to compile
move_convert04.pass.cpp:63:24: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A>'
    std::unique_ptr<A> s2 = std::move(s);
                       ^    ~~~~~~~~~~~~
In file included from move_convert04.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
1 error generated.
move_convert04.pass.cpp failed to compile
move_convert05.pass.cpp:65:37: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2 = std::move(s);
                                    ^    ~~~~~~~~~~~~
In file included from move_convert05.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
1 error generated.
move_convert05.pass.cpp failed to compile
move_convert06.pass.cpp:81:38: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert06.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
1 error generated.
move_convert06.pass.cpp failed to compile
move_convert07.pass.cpp:66:38: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> >'
    std::unique_ptr<A, CDeleter<A> > s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert07.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<B> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'unique_ptr<B, CDeleter<B> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to '__rv<std::unique_ptr<A, CDeleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
1 error generated.
move_convert07.pass.cpp failed to compile
failed 10 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 38 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.dtor
passed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.observers
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-oLyssT.o
      _main in cc-oLyssT.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 2 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 3 tests in /test/utilities/memory/util.dynamic.safety
passed 1 tests in /test/utilities/memory/util.smartptr
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.enab
not implemented:  /test/utilities/memory/util.smartptr/util.smartptr.hash
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.getdeleter
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_Y_rv.pass.cpp, line 67.
./testit: line 96: 42818 Abort trap              ./a.out
shared_ptr_Y_rv.pass.cpp failed at run time
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_rv.pass.cpp, line 67.
./testit: line 96: 42826 Abort trap              ./a.out
shared_ptr_rv.pass.cpp failed at run time
failed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 4 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cast
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cmp
Assertion failed: (A::count == 1), function main, file unique_ptr.pass.cpp, line 94.
./testit: line 96: 43014 Abort trap              ./a.out
unique_ptr.pass.cpp failed at run time
failed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 19 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.dest
./testit: line 96: 43062 Abort trap              ./a.out
io.pass.cpp failed at run time
failed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.io
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.mod
passed 6 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.spec
not implemented:  /test/utilities/memory/util.smartptr/util.smartptr.shared.atomic
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.ownerless
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.assign
passed 4 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.const
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.dest
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.mod
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.spec
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weakptr
passed 1 tests in /test/utilities/meta
passed 1 tests in /test/utilities/meta/meta.hel
is_convertible.pass.cpp:111:5: warning: qualifier on function type 'Function' (aka 'void ()') has unspecified behavior
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_convertible.pass.cpp:111:52: note: instantiated from:
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
                                                   ^~~~~~~~~~~~~~
is_convertible.pass.cpp:289:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((!std::is_convertible<char, char&>::value), "");
    ^
In file included from is_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
1 warning and 1 error generated.
is_convertible.pass.cpp failed to compile
is_explicitly_convertible.pass.cpp:36:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:36:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:36:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:36:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:37:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:37:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:37:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:37:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:38:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:38:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:38:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:38:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:39:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:39:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:39:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:39:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:41:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:41:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:41:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:41:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:42:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:42:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:42:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:42:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:44:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:44:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:44:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:44:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:45:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:45:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:45:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:45:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:47:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:47:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:47:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:47:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:48:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:48:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:48:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:48:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:49:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:49:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:49:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:49:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:50:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:50:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:50:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:50:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:52:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:52:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:52:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:52:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:53:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:53:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:53:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:53:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:54:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:54:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:54:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:54:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:55:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:55:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:55:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:55:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:57:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:57:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:57:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:57:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:58:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:58:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:58:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:58:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:59:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:59:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:59:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:59:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:60:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:60:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:60:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:60:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:62:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:62:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:62:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:62:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:63:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:63:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:63:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:63:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:64:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:64:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:64:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:64:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:65:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:65:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:65:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:65:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:67:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:67:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:67:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:67:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:68:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:68:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:68:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:68:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:69:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:69:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:69:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:69:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:70:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:70:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:70:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:70:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:72:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:72:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:72:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:72:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:73:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:73:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:73:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:73:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:74:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:74:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:74:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:74:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:75:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:75:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:75:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:75:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:78:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:78:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:78:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:78:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:79:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:79:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:79:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:79:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:81:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:81:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:81:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:81:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:83:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:83:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:83:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:83:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:84:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:84:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:84:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:84:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:86:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:86:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:86:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:86:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:87:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:87:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:87:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:87:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:89:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:89:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:89:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:89:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:90:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:90:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:90:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:90:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:92:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:92:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:92:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:92:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:93:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:93:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:93:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:93:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:95:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:95:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:95:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:95:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:96:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:96:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:96:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:96:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:98:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:98:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:98:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:98:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:99:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:99:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:99:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:99:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:101:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:101:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:101:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:101:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:102:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:102:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:102:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:102:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:105:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:105:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:105:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:105:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:106:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:106:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:106:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:106:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:108:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:108:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:108:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:108:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:110:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:110:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:110:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:110:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:111:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:111:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:111:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:111:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:113:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:113:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:113:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:113:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:114:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:114:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:114:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:114:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:116:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:116:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:116:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:116:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:117:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:117:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:117:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:117:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:119:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:119:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:119:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:119:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:120:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:120:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:120:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:120:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:122:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:122:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:122:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:122:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:123:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:123:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:123:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:123:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:125:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:125:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:125:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:125:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:126:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:126:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:126:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:126:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:128:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:128:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:128:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:128:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:129:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:129:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:129:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:129:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:132:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:132:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:132:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:132:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:133:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:133:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:133:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:133:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:134:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:134:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:134:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:134:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:135:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:135:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:135:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:135:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:137:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:137:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:137:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:137:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:138:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:138:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:138:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:138:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:140:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:140:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:140:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:140:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:141:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:141:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:141:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:141:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:143:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:143:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:143:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:143:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:144:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:144:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:144:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:144:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:145:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:145:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:145:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:145:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:146:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:146:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:146:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:146:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:148:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:148:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:148:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:148:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:149:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:149:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:149:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:149:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:150:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:150:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:150:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:150:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:151:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:151:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:151:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:151:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:153:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:153:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:153:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:153:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:154:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:154:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:154:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:154:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:155:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:155:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:155:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:155:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:156:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:156:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:156:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:156:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:158:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:158:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:158:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:158:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:159:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:159:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:159:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:159:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:160:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:160:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:160:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:160:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:161:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:161:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:161:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:161:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:163:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:163:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:163:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:163:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:164:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:164:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:164:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:164:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:165:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:165:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:165:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:165:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:166:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:166:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:166:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:166:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:168:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:168:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:168:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:168:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:169:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:169:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:169:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:169:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:170:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:170:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:170:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:170:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:171:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:171:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:171:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:171:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:174:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:174:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:174:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:174:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:175:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:175:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:175:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:175:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:176:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:176:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:176:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:176:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:177:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:177:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:177:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:177:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:179:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:179:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:179:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:179:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:180:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:180:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:180:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:180:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:182:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:182:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:182:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:182:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:183:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:183:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:183:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:183:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:185:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:185:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:185:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:185:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:186:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:186:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:186:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:186:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:187:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:187:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:187:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:187:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:188:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:188:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:188:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:188:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:190:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:190:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:190:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:190:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:191:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:191:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:191:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:191:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:192:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:192:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:192:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:192:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:193:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:193:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:193:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:193:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:195:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:195:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:195:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:195:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:196:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:196:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:196:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:196:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:197:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:197:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:197:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:197:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:198:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:198:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:198:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:198:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:200:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:200:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:200:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:200:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:201:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:201:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:201:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:201:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:202:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:202:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:202:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:202:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:203:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:203:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:203:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:203:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:205:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:205:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:205:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:205:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:206:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:206:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:206:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:206:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:207:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:207:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:207:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:207:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:208:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:208:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:208:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:208:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:210:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:210:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:210:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:210:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:211:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:211:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:211:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:211:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:212:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:212:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:212:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:212:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:213:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:213:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:213:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:213:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:216:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:216:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:216:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:216:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:217:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:217:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:217:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:217:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:218:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:218:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:218:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:218:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:219:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:219:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:219:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:219:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:221:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:221:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:221:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:221:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:222:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:222:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:222:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:222:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:224:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:224:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:224:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:224:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:225:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:225:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:225:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:225:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:227:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:227:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:227:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:227:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:228:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:228:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:228:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:228:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:229:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:229:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:229:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:229:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:230:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:230:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:230:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:230:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:232:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:232:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:232:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:232:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:233:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:233:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:233:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:233:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:234:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:234:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:234:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:234:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:235:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:235:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:235:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:235:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:237:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:237:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:237:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:237:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:238:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:238:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:238:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:238:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:239:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:239:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:239:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:239:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:240:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:240:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:240:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:240:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:242:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:242:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:242:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:242:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:243:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:243:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:243:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:243:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:244:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:244:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:244:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:244:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:245:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:245:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:245:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:245:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:247:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:247:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:247:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:247:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:248:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:248:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:248:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:248:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:249:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:249:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:249:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:249:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:250:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:250:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:250:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:250:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:252:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:252:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:252:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:252:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:253:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:253:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:253:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:253:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:254:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:254:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:254:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:254:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:255:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:255:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:255:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:255:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:258:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:258:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:258:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:258:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:259:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:259:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:259:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:259:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:260:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:260:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:260:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:260:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:261:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:261:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:261:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:261:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:263:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:263:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:263:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:263:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:264:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:264:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:264:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:264:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:266:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:266:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:266:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:266:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:267:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:267:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:267:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:267:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:269:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:269:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:269:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:269:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:270:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:270:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:270:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:270:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:271:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:271:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:271:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:271:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:272:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:272:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:272:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:272:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:274:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:274:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:274:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:274:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:275:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:275:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:275:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:275:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:276:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:276:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:276:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:276:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:277:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:277:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:277:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:277:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:279:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:279:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:279:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:279:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:280:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:280:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:280:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:280:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:281:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:281:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:281:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:281:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:282:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:282:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:282:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:282:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:284:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:284:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:284:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:284:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:285:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:285:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:285:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:285:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:286:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:286:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:286:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:286:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:287:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:287:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:287:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:287:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:289:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:289:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:289:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:289:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:290:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:290:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:290:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:290:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:291:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:291:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:291:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:291:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:292:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:292:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:292:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:292:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:294:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:294:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:294:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:294:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:295:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:295:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:295:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:295:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:296:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:296:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:296:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:296:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:297:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:297:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:297:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:297:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:300:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:300:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:300:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:300:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:301:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:301:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:301:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:301:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:302:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:302:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:302:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:302:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:303:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:303:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:303:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:303:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:305:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:305:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:305:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:305:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:306:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:306:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:306:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:306:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:308:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:308:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:308:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:308:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:309:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:309:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:309:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:309:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:311:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:311:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:311:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:311:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:312:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:312:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:312:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:312:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:313:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:313:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:313:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:313:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:314:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:314:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:314:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:314:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:316:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:316:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:316:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:316:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:317:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:317:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:317:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:317:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:318:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:318:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:318:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:318:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:319:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:319:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:319:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:319:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:321:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:321:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:321:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:321:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:322:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:322:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:322:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:322:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:323:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:323:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:323:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:323:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:324:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:324:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:324:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:324:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:326:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:326:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:326:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:326:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:327:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:327:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:327:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:327:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:328:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:328:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:328:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:328:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:329:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:329:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:329:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:329:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:331:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:331:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:331:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:331:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:332:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:332:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:332:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:332:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:333:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:333:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:333:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:333:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:334:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:334:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:334:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:334:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:336:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:336:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:336:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:336:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:337:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:337:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:337:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:337:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:338:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:338:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:338:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:338:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:339:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:339:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:339:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:339:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:342:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:342:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:342:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:342:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:343:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:343:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:343:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:343:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:344:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:344:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:344:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:344:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:345:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:345:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:345:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:345:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:347:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:347:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:347:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:347:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:348:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:348:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:348:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:348:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:350:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:350:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:350:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:350:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:351:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:351:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:351:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:351:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:353:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:353:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:353:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:353:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:354:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:354:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:354:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:354:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:355:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:355:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:355:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:355:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:356:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:356:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:356:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:356:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:358:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:358:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:358:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:358:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:359:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:359:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:359:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:359:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:360:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:360:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:360:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:360:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:361:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:361:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:361:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:361:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:363:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:363:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:363:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:363:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:364:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:364:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:364:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:364:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:365:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:365:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:365:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:365:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:366:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:366:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:366:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:366:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:368:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:368:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:368:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:368:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:369:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:369:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:369:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:369:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:370:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:370:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:370:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:370:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:371:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:371:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:371:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:371:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:373:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:373:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:373:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:373:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:374:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:374:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:374:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:374:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:375:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:375:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:375:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:375:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:376:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:376:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:376:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:376:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:378:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:378:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:378:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:378:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:379:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:379:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:379:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:379:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:380:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:380:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:380:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:380:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:381:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:381:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:381:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:381:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:154:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
774 errors generated.
is_explicitly_convertible.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.rel
passed 2 tests in /test/utilities/meta/meta.rel
passed 1 tests in /test/utilities/meta/meta.rqmts
passed 1 tests in /test/utilities/meta/meta.trans
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.arr
passed 6 tests in /test/utilities/meta/meta.trans/meta.trans.cv
aligned_storage.pass.cpp:39:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 12, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:49:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:50:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:54:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:55:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:59:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:60:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:64:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:65:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:69:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:70:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 64, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:74:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:75:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:84:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:89:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:90:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:94:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:99:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:100:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:104:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:105:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:109:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:114:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:115:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == (sizeof(long) == 4 ? 12 : 16), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:119:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:120:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:124:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:129:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:130:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:134:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:135:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == (sizeof(long) == 4 ? 12 : 16), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
33 errors generated.
aligned_storage.pass.cpp failed to compile
underlying_type.pass.cpp:32:2: error: #error underlying_type is not implemented
#error underlying_type is not implemented
 ^
1 error generated.
underlying_type.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 6 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.ptr
passed 3 tests in /test/utilities/meta/meta.trans/meta.trans.ref
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.sign
passed 1 tests in /test/utilities/meta/meta.type.synop
passed 1 tests in /test/utilities/meta/meta.unary
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union_imp<Union>' requested here
    test_union_imp<T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:52:5: note: in instantiation of function template specialization 'test_union_imp<Union const>' requested here
    test_union_imp<const T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:53:5: note: in instantiation of function template specialization 'test_union_imp<Union volatile>' requested here
    test_union_imp<volatile T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:54:5: note: in instantiation of function template specialization 'test_union_imp<Union const volatile>' requested here
    test_union_imp<const volatile T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
8 errors generated.
union.pass.cpp failed to compile
failed 1 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 12 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 13 tests in /test/utilities/meta/meta.unary/meta.unary.comp
has_copy_assign.pass.cpp:32:2: error: #error has_copy_assign not implemented
#error has_copy_assign not implemented
 ^
1 error generated.
has_copy_assign.pass.cpp failed to compile
has_copy_constructor.pass.cpp:32:2: error: #error has_copy_constructor not implemented
#error has_copy_constructor not implemented
 ^
1 error generated.
has_copy_constructor.pass.cpp failed to compile
has_default_constructor.pass.cpp:32:2: error: #error has_default_constructor not implemented
#error has_default_constructor not implemented
 ^
1 error generated.
has_default_constructor.pass.cpp failed to compile
has_move_assign.pass.cpp:32:2: error: #error has_move_assign not implemented
#error has_move_assign not implemented
 ^
1 error generated.
has_move_assign.pass.cpp failed to compile
has_move_constructor.pass.cpp:32:2: error: #error has_move_constructor not implemented
#error has_move_constructor not implemented
 ^
1 error generated.
has_move_constructor.pass.cpp failed to compile
has_nothrow_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Union>' requested here
    test_has_nothrow_assign<Union>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Abstract>' requested here
    test_has_nothrow_assign<Abstract>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Empty>' requested here
    test_has_nothrow_assign<Empty>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<NotEmpty>' requested here
    test_has_nothrow_assign<NotEmpty>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_assign.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<bit_zero>' requested here
    test_has_nothrow_assign<bit_zero>();
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
has_nothrow_copy_assign.pass.cpp failed to compile
has_nothrow_copy_constructor.pass.cpp:42:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:78:5: note: in instantiation of function template specialization 'test_has_not_nothrow_copy_constructor<int &>' requested here
    test_has_not_nothrow_copy_constructor<int&>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Union>' requested here
    test_has_nothrow_copy_constructor<Union>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Abstract>' requested here
    test_has_nothrow_copy_constructor<Abstract>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Empty>' requested here
    test_has_nothrow_copy_constructor<Empty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<NotEmpty>' requested here
    test_has_nothrow_copy_constructor<NotEmpty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<bit_zero>' requested here
    test_has_nothrow_copy_constructor<bit_zero>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
24 errors generated.
has_nothrow_copy_constructor.pass.cpp failed to compile
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Union>' requested here
    test_has_nothrow_default_constructor<Union>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Abstract>' requested here
    test_has_nothrow_default_constructor<Abstract>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Empty>' requested here
    test_has_nothrow_default_constructor<Empty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<NotEmpty>' requested here
    test_has_nothrow_default_constructor<NotEmpty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<bit_zero>' requested here
    test_has_nothrow_default_constructor<bit_zero>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
20 errors generated.
has_nothrow_default_constructor.pass.cpp failed to compile
has_nothrow_move_assign.pass.cpp:32:2: error: #error has_nothrow_move_assign not implemented
#error has_nothrow_move_assign not implemented
 ^
1 error generated.
has_nothrow_move_assign.pass.cpp failed to compile
has_nothrow_move_constructor.pass.cpp:32:2: error: #error has_nothrow_move_constructor not implemented
#error has_nothrow_move_constructor not implemented
 ^
1 error generated.
has_nothrow_move_constructor.pass.cpp failed to compile
has_trivial_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Union>' requested here
    test_has_trivial_assign<Union>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Abstract>' requested here
    test_has_trivial_assign<Abstract>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Empty>' requested here
    test_has_trivial_assign<Empty>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_assign<NotEmpty>' requested here
    test_has_trivial_assign<NotEmpty>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_assign.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_assign<bit_zero>' requested here
    test_has_trivial_assign<bit_zero>();
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_assign<volatile T>::value, "");
    ^
In file included from has_trivial_copy_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
has_trivial_copy_assign.pass.cpp failed to compile
has_trivial_copy_constructor.pass.cpp:42:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:78:5: note: in instantiation of function template specialization 'test_has_not_trivial_copy_constructor<int &>' requested here
    test_has_not_trivial_copy_constructor<int&>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Union>' requested here
    test_has_trivial_copy_constructor<Union>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Abstract>' requested here
    test_has_trivial_copy_constructor<Abstract>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Empty>' requested here
    test_has_trivial_copy_constructor<Empty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<NotEmpty>' requested here
    test_has_trivial_copy_constructor<NotEmpty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<bit_zero>' requested here
    test_has_trivial_copy_constructor<bit_zero>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
24 errors generated.
has_trivial_copy_constructor.pass.cpp failed to compile
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Union>' requested here
    test_has_trivial_default_constructor<Union>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Abstract>' requested here
    test_has_trivial_default_constructor<Abstract>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Empty>' requested here
    test_has_trivial_default_constructor<Empty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<NotEmpty>' requested here
    test_has_trivial_default_constructor<NotEmpty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<bit_zero>' requested here
    test_has_trivial_default_constructor<bit_zero>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
20 errors generated.
has_trivial_default_constructor.pass.cpp failed to compile
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Union>' requested here
    test_has_trivial_destructor<Union>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:83:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Empty>' requested here
    test_has_trivial_destructor<Empty>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<bit_zero>' requested here
    test_has_trivial_destructor<bit_zero>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
12 errors generated.
has_trivial_destructor.pass.cpp failed to compile
has_trivial_move_assign.pass.cpp:32:2: error: #error has_trivial_move_assign not implemented
#error has_trivial_move_assign not implemented
 ^
1 error generated.
has_trivial_move_assign.pass.cpp failed to compile
has_trivial_move_constructor.pass.cpp:32:2: error: #error has_trivial_move_constructor not implemented
#error has_trivial_move_constructor not implemented
 ^
1 error generated.
has_trivial_move_constructor.pass.cpp failed to compile
has_virtual_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<Abstract>' requested here
    test_has_virtual_destructor<Abstract>();
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<NotEmpty>' requested here
    test_has_virtual_destructor<NotEmpty>();
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
8 errors generated.
has_virtual_destructor.pass.cpp failed to compile
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:690:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:701:54: note: in instantiation of template class 'std::__is_empty1<Union>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:705:40: note: in instantiation of template class 'std::__yuga_empty<Union, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:42:5: note: in instantiation of template class 'std::is_empty<Union>' requested here
    static_assert(!std::is_empty<T>::value, "");
    ^
is_empty.pass.cpp:42:20: note: instantiated from:
    static_assert(!std::is_empty<T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:690:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:701:54: note: in instantiation of template class 'std::__is_empty1<Union const>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:705:40: note: in instantiation of template class 'std::__yuga_empty<Union const, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:43:5: note: in instantiation of template class 'std::is_empty<Union const>' requested here
    static_assert(!std::is_empty<const T>::value, "");
    ^
is_empty.pass.cpp:43:20: note: instantiated from:
    static_assert(!std::is_empty<const T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:690:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:701:54: note: in instantiation of template class 'std::__is_empty1<Union volatile>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:705:40: note: in instantiation of template class 'std::__yuga_empty<Union volatile, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:44:5: note: in instantiation of template class 'std::is_empty<Union volatile>' requested here
    static_assert(!std::is_empty<volatile T>::value, "");
    ^
is_empty.pass.cpp:44:20: note: instantiated from:
    static_assert(!std::is_empty<volatile T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:690:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:701:54: note: in instantiation of template class 'std::__is_empty1<Union const volatile>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:705:40: note: in instantiation of template class 'std::__yuga_empty<Union const volatile, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:45:5: note: in instantiation of template class 'std::is_empty<Union const volatile>' requested here
    static_assert(!std::is_empty<const volatile T>::value, "");
    ^
is_empty.pass.cpp:45:20: note: instantiated from:
    static_assert(!std::is_empty<const volatile T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
4 errors generated.
is_empty.pass.cpp failed to compile
is_literal_type.pass.cpp:32:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_literal_type<int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:33:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:33:25: note: instantiated from:
    static_assert( std::is_literal_type<const int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:34:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_literal_type<int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:35:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:35:25: note: instantiated from:
    static_assert(!std::is_literal_type<volatile int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:35:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:35:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
12 errors generated.
is_literal_type.pass.cpp failed to compile
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_pod<int>' requested here
    test_is_pod<int>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:61:5: note: in instantiation of function template specialization 'test_is_pod<double>' requested here
    test_is_pod<double>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:62:5: note: in instantiation of function template specialization 'test_is_pod<int *>' requested here
    test_is_pod<int*>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:63:5: note: in instantiation of function template specialization 'test_is_pod<int const *>' requested here
    test_is_pod<const int*>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:64:5: note: in instantiation of function template specialization 'test_is_pod<char [3]>' requested here
    test_is_pod<char[3]>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
10 errors generated.
is_pod.pass.cpp failed to compile
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:709:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:714:38: note: in instantiation of template class 'std::__is_polymorphic1<Union>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:718:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:42:5: note: in instantiation of template class 'std::is_polymorphic<Union>' requested here
    static_assert(!std::is_polymorphic<T>::value, "");
    ^
is_polymorphic.pass.cpp:42:20: note: instantiated from:
    static_assert(!std::is_polymorphic<T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:709:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:714:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:718:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union const, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:43:5: note: in instantiation of template class 'std::is_polymorphic<Union const>' requested here
    static_assert(!std::is_polymorphic<const T>::value, "");
    ^
is_polymorphic.pass.cpp:43:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:709:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:714:38: note: in instantiation of template class 'std::__is_polymorphic1<Union volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:718:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:44:5: note: in instantiation of template class 'std::is_polymorphic<Union volatile>' requested here
    static_assert(!std::is_polymorphic<volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:44:20: note: instantiated from:
    static_assert(!std::is_polymorphic<volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:709:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:714:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:718:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union const volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:45:5: note: in instantiation of template class 'std::is_polymorphic<Union const volatile>' requested here
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:45:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
4 errors generated.
is_polymorphic.pass.cpp failed to compile
is_standard_layout.pass.cpp:32:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert( std::is_standard_layout<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_standard_layout<int>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:33:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:33:25: note: instantiated from:
    static_assert(!std::is_standard_layout<int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:34:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 errors generated.
is_standard_layout.pass.cpp failed to compile
is_trivial.pass.cpp:32:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert( std::is_trivial<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_trivial<int>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:33:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:33:25: note: instantiated from:
    static_assert(!std::is_trivial<int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:34:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_trivial<volatile int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 errors generated.
is_trivial.pass.cpp failed to compile
is_trivialially_copyable.pass.cpp:44:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:44:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:44:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:44:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:45:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:45:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:45:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:45:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:46:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:46:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<int&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:46:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:46:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:47:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:47:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:47:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:47:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:48:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:48:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:48:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:48:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:49:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:49:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:49:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:49:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:50:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:50:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<B>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:50:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:50:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:154:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
21 errors generated.
is_trivialially_copyable.pass.cpp failed to compile
failed 24 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 10 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 1 tests in /test/utilities/ratio
passed 8 tests in /test/utilities/ratio/ratio.arithmetic
passed 6 tests in /test/utilities/ratio/ratio.comparison
passed 4 tests in /test/utilities/ratio/ratio.ratio
passed 1 tests in /test/utilities/ratio/ratio.si
passed 1 tests in /test/utilities/template.bitset
passed 4 tests in /test/utilities/template.bitset/bitset.cons
passed 1 tests in /test/utilities/template.bitset/bitset.hash
passed 26 tests in /test/utilities/template.bitset/bitset.members
./testit: line 96: 44300 Abort trap              ./a.out
stream_in.pass.cpp failed at run time
./testit: line 96: 44308 Abort trap              ./a.out
stream_out.pass.cpp failed at run time
failed 2 tests in /test/utilities/template.bitset/bitset.operators
passed 3 tests in /test/utilities/template.bitset/bitset.operators
passed 6 tests in /test/utilities/time
passed 1 tests in /test/utilities/time/time.clock
passed 2 tests in /test/utilities/time/time.clock/time.clock.hires
passed 2 tests in /test/utilities/time/time.clock/time.clock.monotonic
passed 5 tests in /test/utilities/time/time.clock/time.clock.system
passed 1 tests in /test/utilities/time/time.clock.req
passed 5 tests in /test/utilities/time/time.duration
passed 12 tests in /test/utilities/time/time.duration/time.duration.arithmetic
passed 2 tests in /test/utilities/time/time.duration/time.duration.cast
passed 2 tests in /test/utilities/time/time.duration/time.duration.comparisons
passed 11 tests in /test/utilities/time/time.duration/time.duration.cons
passed 11 tests in /test/utilities/time/time.duration/time.duration.nonmember
passed 1 tests in /test/utilities/time/time.duration/time.duration.observer
passed 3 tests in /test/utilities/time/time.duration/time.duration.special
passed 2 tests in /test/utilities/time/time.point
passed 2 tests in /test/utilities/time/time.point/time.point.arithmetic
passed 2 tests in /test/utilities/time/time.point/time.point.cast
passed 4 tests in /test/utilities/time/time.point/time.point.comparisons
passed 5 tests in /test/utilities/time/time.point/time.point.cons
passed 3 tests in /test/utilities/time/time.point/time.point.nonmember
passed 1 tests in /test/utilities/time/time.point/time.point.observer
passed 2 tests in /test/utilities/time/time.point/time.point.special
passed 1 tests in /test/utilities/time/time.traits
passed 3 tests in /test/utilities/time/time.traits/time.traits.duration_values
passed 1 tests in /test/utilities/time/time.traits/time.traits.is_fp
passed 2 tests in /test/utilities/time/time.traits/time.traits.specializations
passed 1 tests in /test/utilities/tuple
passed 1 tests in /test/utilities/tuple/tuple.general
empty_member.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, A> T;
                ~~~~~^
empty_member.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int, A> T;
                          ^
empty_member.pass.cpp:40:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:40:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int> T;
                ~~~~~^
empty_member.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<A, int> T;
                          ^
empty_member.pass.cpp:44:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:44:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int, B> T;
                ~~~~~^
empty_member.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<A, int, B> T;
                          ^
empty_member.pass.cpp:48:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:48:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:48:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:48:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, B, int> T;
                ~~~~~^
empty_member.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<A, B, int> T;
                          ^
empty_member.pass.cpp:52:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:52:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:52:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:52:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, A, B> T;
                ~~~~~^
empty_member.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, A, B> T;
                          ^
empty_member.pass.cpp:56:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:56:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
25 errors generated.
empty_member.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple
const_pair.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:41:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
const_pair.pass.cpp:42:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
const_pair.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:44:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
6 errors generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:53:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:54:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:55:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:61:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:63:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_copy.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_copy.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_copy.pass.cpp:70:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_copy.pass.cpp:71:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:72:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:73:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:74:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:75:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_copy.pass.cpp:80:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_copy.pass.cpp:80:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_copy.pass.cpp:81:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_copy.pass.cpp:81:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_copy.pass.cpp:82:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d2);
        ^
convert_copy.pass.cpp:83:9: error: use of undeclared identifier 'T1'
        T1 t1(1.5, 'b', d);
        ^
convert_copy.pass.cpp:84:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:85:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:86:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:87:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
37 errors generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:56:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:57:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:58:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:64:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:65:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:66:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:68:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_move.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_move.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_move.pass.cpp:73:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_move.pass.cpp:74:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:75:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:76:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:77:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:77:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:78:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_move.pass.cpp:83:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_move.pass.cpp:83:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_move.pass.cpp:84:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_move.pass.cpp:84:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_move.pass.cpp:85:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d2);
        ^
convert_move.pass.cpp:86:9: error: use of undeclared identifier 'T1'
        T1 t1(1.5, 'b', d);
        ^
convert_move.pass.cpp:87:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:88:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:89:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:90:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:90:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
convert_move.pass.cpp:93:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                ~~~~~^
convert_move.pass.cpp:93:27: error: expected unqualified-id
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                          ^
convert_move.pass.cpp:94:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                ~~~~~^
convert_move.pass.cpp:94:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                          ^
convert_move.pass.cpp:95:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', std::unique_ptr<D>(new D(3)));
        ^
convert_move.pass.cpp:96:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:97:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:98:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:98:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:99:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:99:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:100:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:100:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
47 errors generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:40:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:46:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:51:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:52:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:53:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:55:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int, char, std::string> T;
                          ^
copy.pass.cpp:59:9: error: use of undeclared identifier 'T'
        T t0(2, 'a', "some text");
        ^
copy.pass.cpp:60:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:61:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:62:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:63:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:63:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "some text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:64:21: note: instantiated from:
        assert(std::get<2>(t) == "some text");
               ~~~~~^
26 errors generated.
copy.pass.cpp failed to compile
move.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:41:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:47:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:52:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:54:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:55:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:56:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:60:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
move.pass.cpp:61:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:62:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:63:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:63:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:65:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
26 errors generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:55:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:58:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
move_pair.pass.cpp:59:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
move_pair.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:60:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:61:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:57:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
8 errors generated.
move_pair.pass.cpp failed to compile
failed 6 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
UTypes.pass.cpp:39:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:40:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:43:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t(MoveOnly(0), MoveOnly(1));
        ~~~~~^
UTypes.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:44:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:45:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:48:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:53:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
UTypes.pass.cpp:57:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
17 errors generated.
UTypes.pass.cpp failed to compile
In file included from alloc.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:45:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc.pass.cpp:49:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:54:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_first> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:60:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_last> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:62:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_last());
               ~~~~~^
alloc.pass.cpp:66:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:69:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:74:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:76:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:78:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:80:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last());
               ~~~~~^
alloc.pass.cpp:85:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:87:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:89:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:91:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:91:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last());
               ~~~~~^
50 errors generated.
alloc.pass.cpp failed to compile
In file included from alloc_UTypes.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_UTypes.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_UTypes.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly> t(std::allocator_arg, A1<int>(), MoveOnly(0));
        ~~~~~^
alloc_UTypes.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(),
        ~~~~~^
alloc_UTypes.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:49:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:52:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:55:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:56:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:57:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
alloc_UTypes.pass.cpp:62:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_UTypes.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_UTypes.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:68:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
alloc_UTypes.pass.cpp:72:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:74:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:75:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:76:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
alloc_UTypes.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:81:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:82:21: note: instantiated from:
        assert(std::get<1>(t) == MoveOnly());
               ~~~~~^
alloc_UTypes.pass.cpp:83:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:83:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
51 errors generated.
alloc_UTypes.pass.cpp failed to compile
In file included from alloc_const_Types.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_Types.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_const_Types.pass.cpp:41:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(std::allocator_arg, A1<int>(), 3);
        ~~~~~^
alloc_const_Types.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
alloc_const_Types.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_first> t(std::allocator_arg, A1<int>(5), alloc_first(3));
        ~~~~~^
alloc_const_Types.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_first(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_first(3));
               ~~~~~^
alloc_const_Types.pass.cpp:52:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_last> t(std::allocator_arg, A1<int>(5), alloc_last(3));
        ~~~~~^
alloc_const_Types.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_last(3));
               ~~~~~^
alloc_const_Types.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first> t(std::allocator_arg, A1<int>(5),
        ~~~~~^
alloc_const_Types.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 10);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:60:21: note: instantiated from:
        assert(std::get<0>(t) == 10);
               ~~~~~^
alloc_const_Types.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(15));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:62:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(15));
               ~~~~~^
alloc_const_Types.pass.cpp:67:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_const_Types.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:70:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_const_Types.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:72:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_const_Types.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:74:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
alloc_const_Types.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_const_Types.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:82:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_const_Types.pass.cpp:84:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:84:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_const_Types.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:86:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
47 errors generated.
alloc_const_Types.pass.cpp failed to compile
In file included from alloc_const_pair.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_pair.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_const_pair.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
alloc_const_pair.pass.cpp:45:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:47:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_const_pair.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, double> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, double> T1;
                          ^
alloc_const_pair.pass.cpp:54:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:57:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_const_pair.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T1;
                          ^
alloc_const_pair.pass.cpp:65:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:68:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:69:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
45 errors generated.
alloc_const_pair.pass.cpp failed to compile
In file included from alloc_convert_copy.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_copy.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_convert_copy.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
alloc_convert_copy.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
alloc_convert_copy.pass.cpp:43:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
alloc_convert_copy.pass.cpp:44:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(), t0);
        ^
alloc_convert_copy.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<int> T0;
                          ^
alloc_convert_copy.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T1;
                          ^
alloc_convert_copy.pass.cpp:50:9: error: use of undeclared identifier 'T0'
        T0 t0(2);
        ^
alloc_convert_copy.pass.cpp:52:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<int, int> T0;
                          ^
alloc_convert_copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T1;
                          ^
alloc_convert_copy.pass.cpp:59:9: error: use of undeclared identifier 'T0'
        T0 t0(2, 3);
        ^
alloc_convert_copy.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_convert_copy.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, int, int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<double, int, int> T0;
                          ^
alloc_convert_copy.pass.cpp:70:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, alloc_first, alloc_last> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:70:27: error: expected unqualified-id
        typedef std::tuple<int, alloc_first, alloc_last> T1;
                          ^
alloc_convert_copy.pass.cpp:71:9: error: use of undeclared identifier 'T0'
        T0 t0(1.5, 2, 3);
        ^
alloc_convert_copy.pass.cpp:74:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:77:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:77:21: note: instantiated from:
        assert(std::get<0>(t1) == 1);
               ~~~~~^
alloc_convert_copy.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:78:21: note: instantiated from:
        assert(std::get<1>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:79:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:79:21: note: instantiated from:
        assert(std::get<2>(t1) == 3);
               ~~~~~^
61 errors generated.
alloc_convert_copy.pass.cpp failed to compile
In file included from alloc_convert_move.pass.cpp:37:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_move.pass.cpp:38:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_convert_move.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int> T0;
                          ^
alloc_convert_move.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T1;
                          ^
alloc_convert_move.pass.cpp:60:9: error: use of undeclared identifier 'T0'
        T0 t0(2);
        ^
alloc_convert_move.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:67:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:67:27: error: expected unqualified-id
        typedef std::tuple<std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:69:9: error: use of undeclared identifier 'T0'
        T0 t0(std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:70:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:71:21: note: instantiated from:
        assert(std::get<0>(t1)->id_ == 3);
               ~~~~~^
alloc_convert_move.pass.cpp:74:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:74:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:75:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:75:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:76:9: error: use of undeclared identifier 'T0'
        T0 t0(2, std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:78:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
alloc_convert_move.pass.cpp:84:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:84:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:85:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last, alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:85:27: error: expected unqualified-id
        typedef std::tuple<alloc_last, alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:86:9: error: use of undeclared identifier 'T0'
        T0 t0(1, 2, std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:89:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:92:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:92:21: note: instantiated from:
        assert(std::get<0>(t1) == 1);
               ~~~~~^
alloc_convert_move.pass.cpp:93:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:93:21: note: instantiated from:
        assert(std::get<1>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:94:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:94:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
61 errors generated.
alloc_convert_move.pass.cpp failed to compile
In file included from alloc_copy.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_copy.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_copy.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
alloc_copy.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
alloc_copy.pass.cpp:42:9: error: use of undeclared identifier 'T'
        T t0;
        ^
alloc_copy.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), t0);
        ^
alloc_copy.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
alloc_copy.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
alloc_copy.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:48:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), t0);
        ^
alloc_copy.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T;
                ~~~~~^
alloc_copy.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T;
                          ^
alloc_copy.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:55:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<alloc_last> T;
                          ^
alloc_copy.pass.cpp:61:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:63:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T;
                          ^
alloc_copy.pass.cpp:69:9: error: use of undeclared identifier 'T'
        T t0(2, 3);
        ^
alloc_copy.pass.cpp:72:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:75:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:76:21: note: instantiated from:
        assert(std::get<1>(t) == 3);
               ~~~~~^
alloc_copy.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, alloc_first, alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, alloc_first, alloc_last> T;
                          ^
alloc_copy.pass.cpp:80:9: error: use of undeclared identifier 'T'
        T t0(1, 2, 3);
        ^
alloc_copy.pass.cpp:83:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:86:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_copy.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:87:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:88:21: note: instantiated from:
        assert(std::get<2>(t) == 3);
               ~~~~~^
62 errors generated.
alloc_copy.pass.cpp failed to compile
In file included from alloc_move.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_move.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
alloc_move.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
alloc_move.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t0;
        ^
alloc_move.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), std::move(t0));
        ^
alloc_move.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
alloc_move.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
alloc_move.pass.cpp:48:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
alloc_move.pass.cpp:49:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), std::move(t0));
        ^
alloc_move.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_move.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T;
                ~~~~~^
alloc_move.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T;
                          ^
alloc_move.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t0(1);
        ^
alloc_move.pass.cpp:56:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last> T;
                ~~~~~^
alloc_move.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<alloc_last> T;
                          ^
alloc_move.pass.cpp:62:9: error: use of undeclared identifier 'T'
        T t0(1);
        ^
alloc_move.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:66:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, alloc_first> T;
                ~~~~~^
alloc_move.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, alloc_first> T;
                          ^
alloc_move.pass.cpp:70:9: error: use of undeclared identifier 'T'
        T t0(0 ,1);
        ^
alloc_move.pass.cpp:72:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:74:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_move.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:75:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:78:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, alloc_first, alloc_last> T;
                ~~~~~^
alloc_move.pass.cpp:78:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, alloc_first, alloc_last> T;
                          ^
alloc_move.pass.cpp:79:9: error: use of undeclared identifier 'T'
        T t0(1, 2, 3);
        ^
alloc_move.pass.cpp:82:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:85:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:86:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
alloc_move.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:87:21: note: instantiated from:
        assert(std::get<2>(t) == 3);
               ~~~~~^
62 errors generated.
alloc_move.pass.cpp failed to compile
In file included from alloc_move_pair.pass.cpp:37:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move_pair.pass.cpp:38:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_move_pair.pass.cpp:59:49: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<int, std::unique_ptr<D>> T0;
                                                ^~
                                                > >
alloc_move_pair.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_move_pair.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_move_pair.pass.cpp:63:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move_pair.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move_pair.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_move_pair.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move_pair.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from alloc_move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
alloc_move_pair.pass.cpp:61:12: note: in instantiation of member function 'std::pair<int, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2, std::unique_ptr<D>(new D(3)));
           ^
In file included from alloc_move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
37 errors generated.
alloc_move_pair.pass.cpp failed to compile
const_Types.pass.cpp:37:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(2);
        ~~~~~^
const_Types.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:41:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, 0);
        ~~~~~^
const_Types.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:43:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:51:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr, "text");
        ~~~~~^
const_Types.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:54:21: note: instantiated from:
        assert(std::get<2>(t) == "text");
               ~~~~~^
const_Types.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2);
        ~~~~~^
const_Types.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
const_Types.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
const_Types.pass.cpp:70:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string, double> t(2, nullptr, "text");
        ~~~~~^
const_Types.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:71:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:72:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:73:21: note: instantiated from:
        assert(std::get<2>(t) == "text");
               ~~~~~^
const_Types.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t) == 0.0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:74:21: note: instantiated from:
        assert(std::get<3>(t) == 0.0);
               ~~~~~^
25 errors generated.
const_Types.pass.cpp failed to compile
const_pair.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:40:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
const_pair.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:42:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
5 errors generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:52:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:53:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:59:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:60:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:61:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:62:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:65:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:65:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_copy.pass.cpp:66:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_copy.pass.cpp:66:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_copy.pass.cpp:67:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_copy.pass.cpp:68:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:69:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:70:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:71:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_copy.pass.cpp:75:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_copy.pass.cpp:75:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_copy.pass.cpp:76:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_copy.pass.cpp:76:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_copy.pass.cpp:77:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d);
        ^
convert_copy.pass.cpp:78:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:82:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
33 errors generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:55:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:56:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:62:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:63:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:65:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_move.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_move.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_move.pass.cpp:70:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_move.pass.cpp:71:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:72:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:73:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:74:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_move.pass.cpp:78:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_move.pass.cpp:78:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_move.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_move.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_move.pass.cpp:80:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d);
        ^
convert_move.pass.cpp:81:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:83:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:83:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:84:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:84:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:85:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
convert_move.pass.cpp:88:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                ~~~~~^
convert_move.pass.cpp:88:27: error: expected unqualified-id
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                          ^
convert_move.pass.cpp:89:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                ~~~~~^
convert_move.pass.cpp:89:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                          ^
convert_move.pass.cpp:90:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', std::unique_ptr<D>(new D(3)));
        ^
convert_move.pass.cpp:91:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:92:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:92:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:93:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:93:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:94:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:94:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
42 errors generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:49:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:50:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
copy.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, char, std::string> T;
                          ^
copy.pass.cpp:56:9: error: use of undeclared identifier 'T'
        T t0(2, 'a', "some text");
        ^
copy.pass.cpp:57:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "some text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:60:21: note: instantiated from:
        assert(std::get<2>(t) == "some text");
               ~~~~~^
22 errors generated.
copy.pass.cpp failed to compile
default.pass.cpp:39:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t;
        ~~~~~^
default.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t;
        ~~~~~^
default.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t;
        ~~~~~^
default.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:51:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t;
        ~~~~~^
default.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:54:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:57:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string, DefaultOnly> t;
        ~~~~~^
default.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:60:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:61:21: note: instantiated from:
        assert(std::get<3>(t) == DefaultOnly());
               ~~~~~^
15 errors generated.
default.pass.cpp failed to compile
move.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:50:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:51:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:57:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
move.pass.cpp:58:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
22 errors generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:54:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:57:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
move_pair.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:30:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:56:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:30:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:42: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY explicit unique_ptr(auto_ptr<_Up>& __p,
                                         ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
7 errors generated.
move_pair.pass.cpp failed to compile
failed 18 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
passed 4 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
make_tuple.pass.cpp:40:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int&, float&> t = std::make_tuple(1, std::ref(i),
        ~~~~~^
make_tuple.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:43:21: note: instantiated from:
        assert(std::get<1>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:44:21: note: instantiated from:
        assert(std::get<2>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
make_tuple.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:49:21: note: instantiated from:
        assert(std::get<2>(t) == 3.5);
               ~~~~~^
make_tuple.pass.cpp:50:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 0;
        ~~~~~^
make_tuple.pass.cpp:51:14: error: no member named 'get' in namespace 'std'
        std::get<2>(t) = 0;
        ~~~~~^
9 errors generated.
make_tuple.pass.cpp failed to compile
tie.pass.cpp:40:14: error: no member named 'tie' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
        ~~~~~^
tie.pass.cpp:40:26: error: no member named 'ignore' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
                    ~~~~~^
2 errors generated.
tie.pass.cpp failed to compile
tuple_cat.pass.cpp:53:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:54:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t2;
        ~~~~~^
tuple_cat.pass.cpp:55:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:59:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:60:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:61:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:65:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:66:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:70:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:71:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:72:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:73:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:74:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:77:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:78:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int*> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:84:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:85:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:86:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, int, double> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:87:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:88:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:89:21: note: instantiated from:
        assert(std::get<2>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:92:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:93:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:94:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double, int*> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:95:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:95:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:96:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:96:21: note: instantiated from:
        assert(std::get<1>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:97:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:97:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:100:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t1(nullptr, 1);
        ~~~~~^
tuple_cat.pass.cpp:101:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:102:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly, int, double> t3 =
        ~~~~~^
tuple_cat.pass.cpp:104:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:104:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:105:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:105:21: note: instantiated from:
        assert(std::get<1>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:106:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:106:21: note: instantiated from:
        assert(std::get<2>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:107:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:107:21: note: instantiated from:
        assert(std::get<3>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:110:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t1(nullptr, 1);
        ~~~~~^
tuple_cat.pass.cpp:111:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:112:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double, int*, MoveOnly> t3 =
        ~~~~~^
tuple_cat.pass.cpp:114:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:114:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:115:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:115:21: note: instantiated from:
        assert(std::get<1>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:116:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:116:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:117:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:117:21: note: instantiated from:
        assert(std::get<3>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:120:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t1(1, 2);
        ~~~~~^
tuple_cat.pass.cpp:121:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t2(nullptr, 4);
        ~~~~~^
tuple_cat.pass.cpp:122:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, int*, MoveOnly> t3 =
        ~~~~~^
tuple_cat.pass.cpp:124:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:124:21: note: instantiated from:
        assert(std::get<0>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:125:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:125:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:126:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:126:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:127:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:127:21: note: instantiated from:
        assert(std::get<3>(t3) == 4);
               ~~~~~^
54 errors generated.
tuple_cat.pass.cpp failed to compile
failed 3 tests in /test/utilities/tuple/tuple.tuple/tuple.creation
get_const.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_const.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_const.pass.cpp:40:15: error: unknown type name 'T'
        const T t(3);
              ^
get_const.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_const.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_const.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_const.pass.cpp:45:15: error: unknown type name 'T'
        const T t("high", 5);
              ^
get_const.pass.cpp:45:17: error: excess elements in scalar initializer
        const T t("high", 5);
                ^ ~~~~~~~~~
get_const.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_const.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:47:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_const.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_const.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_const.pass.cpp:52:15: error: unknown type name 'T'
        const T t(d, "high", 5);
              ^
get_const.pass.cpp:52:17: error: excess elements in scalar initializer
        const T t(d, "high", 5);
                ^ ~~~~~~~~~~~~
get_const.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:53:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
get_const.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:54:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_const.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:55:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
get_const.pass.cpp:56:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2.5;
        ~~~~~^
get_const.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t) == 2.5);
               ~~~~~^
get_const.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:58:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_const.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:59:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
21 errors generated.
get_const.pass.cpp failed to compile
get_non_const.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_non_const.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_non_const.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t(3);
        ^
get_non_const.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_non_const.pass.cpp:42:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2;
        ~~~~~^
get_non_const.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
get_non_const.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_non_const.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t("high", 5);
        ^
get_non_const.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_non_const.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:49:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_non_const.pass.cpp:50:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = "four";
        ~~~~~^
get_non_const.pass.cpp:51:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 4;
        ~~~~~^
get_non_const.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "four");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == "four");
               ~~~~~^
get_non_const.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == 4);
               ~~~~~^
get_non_const.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_non_const.pass.cpp:58:9: error: use of undeclared identifier 'T'
        T t(d, "high", 5);
        ^
get_non_const.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
get_non_const.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_non_const.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
get_non_const.pass.cpp:62:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2.5;
        ~~~~~^
get_non_const.pass.cpp:63:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = "four";
        ~~~~~^
get_non_const.pass.cpp:64:14: error: no member named 'get' in namespace 'std'
        std::get<2>(t) = 4;
        ~~~~~^
get_non_const.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2.5);
               ~~~~~^
get_non_const.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "four");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == "four");
               ~~~~~^
get_non_const.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == 4);
               ~~~~~^
27 errors generated.
get_non_const.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
tuple_element.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_element.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_element.pass.cpp:42:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:43:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:43:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:42:9: error: expected ')'
tuple_element.pass.cpp:42:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
tuple_element.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
tuple_element.pass.cpp:47:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:48:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:48:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:47:9: error: expected ')'
tuple_element.pass.cpp:47:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:49:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                          ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:50:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:50:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:49:9: error: expected ')'
tuple_element.pass.cpp:49:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                      ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int*, char, int> T;
                ~~~~~^
tuple_element.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<int*, char, int> T;
                          ^
tuple_element.pass.cpp:54:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:55:44: note: instantiated from:
                                    int*>::value), "");
                                           ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:55:44: note: instantiated from:
                                    int*>::value), "");
                                           ^
tuple_element.pass.cpp:54:9: error: expected ')'
tuple_element.pass.cpp:54:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:56:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                          ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:57:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:57:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:56:9: error: expected ')'
tuple_element.pass.cpp:56:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                      ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:58:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                          ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                              ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                              ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:59:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:59:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:58:9: error: expected ')'
tuple_element.pass.cpp:58:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                      ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
54 errors generated.
tuple_element.pass.cpp failed to compile
tuple_size.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
tuple_size.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
tuple_size.pass.cpp:39:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:39:9: error: expected ')'
tuple_size.pass.cpp:39:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:39:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
                      ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_size.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_size.pass.cpp:44:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:44:9: error: expected ')'
tuple_size.pass.cpp:44:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:44:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
                      ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
tuple_size.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
tuple_size.pass.cpp:49:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:49:9: error: expected ')'
tuple_size.pass.cpp:49:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:49:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
                      ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, char*, int> T;
                ~~~~~^
tuple_size.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<char, char*, int> T;
                          ^
tuple_size.pass.cpp:54:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:54:9: error: expected ')'
tuple_size.pass.cpp:54:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:54:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
                      ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
40 errors generated.
tuple_size.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.helper
begin.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int*, int*> T;
                ~~~~~^
begin.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int*, int*> T;
                          ^
begin.pass.cpp:43:15: error: unknown type name 'T'
        const T t(std::begin(array), std::end(array));
              ^
begin.pass.cpp:43:17: error: excess elements in scalar initializer
        const T t(std::begin(array), std::end(array));
                ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 errors generated.
begin.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.range
eq.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
eq.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
eq.pass.cpp:40:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
eq.pass.cpp:40:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
eq.pass.cpp:41:15: error: unknown type name 'T1'
        const T1 t1;
              ^
eq.pass.cpp:42:15: error: unknown type name 'T2'
        const T2 t2;
              ^
eq.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:49:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:50:15: error: unknown type name 'T2'
        const T2 t2(1.1);
              ^
eq.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:57:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:58:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
eq.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:64:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:64:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:65:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:65:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:66:15: error: unknown type name 'T2'
        const T2 t2(1, char(2));
              ^
eq.pass.cpp:66:18: error: excess elements in scalar initializer
        const T2 t2(1, char(2));
                 ^  ~~~~~~~~~~
eq.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:73:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:73:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:74:15: error: unknown type name 'T2'
        const T2 t2(1, char(3));
              ^
eq.pass.cpp:74:18: error: excess elements in scalar initializer
        const T2 t2(1, char(3));
                 ^  ~~~~~~~~~~
eq.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:80:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:80:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:81:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:81:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:82:15: error: unknown type name 'T2'
        const T2 t2(1.1, char(2));
              ^
eq.pass.cpp:82:18: error: excess elements in scalar initializer
        const T2 t2(1.1, char(2));
                 ^  ~~~~~~~~~~~~
eq.pass.cpp:87:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:87:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:88:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:88:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:89:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:89:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:90:15: error: unknown type name 'T2'
        const T2 t2(1.1, char(3));
              ^
eq.pass.cpp:90:18: error: excess elements in scalar initializer
        const T2 t2(1.1, char(3));
                 ^  ~~~~~~~~~~~~
eq.pass.cpp:95:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:95:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:96:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:96:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:97:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:97:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:98:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 3);
              ^
eq.pass.cpp:98:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:103:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:103:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:104:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:104:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:105:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:105:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:106:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 3);
              ^
eq.pass.cpp:106:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 3);
                 ^  ~~~~~~~~~
eq.pass.cpp:111:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:111:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:112:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:112:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:113:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:113:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:114:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 3);
              ^
eq.pass.cpp:114:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 3);
                 ^  ~~~~~~~
eq.pass.cpp:119:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:119:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:120:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:120:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:121:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:121:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:122:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 4);
              ^
eq.pass.cpp:122:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 4);
                 ^  ~~~~~~~
eq.pass.cpp:127:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:127:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:128:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:128:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:129:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:129:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:130:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 2);
              ^
eq.pass.cpp:130:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 2);
                 ^  ~~~~~~~
eq.pass.cpp:135:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:135:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:136:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:136:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:137:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:137:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:138:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 2);
              ^
eq.pass.cpp:138:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 2);
                 ^  ~~~~~~~~~
eq.pass.cpp:143:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:143:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:144:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:144:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:145:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:145:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:146:15: error: unknown type name 'T2'
        const T2 t2(1.1, 3, 3);
              ^
eq.pass.cpp:146:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 3, 3);
                 ^  ~~~~~~~~~
eq.pass.cpp:151:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:151:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:152:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:152:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:153:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:153:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:154:15: error: unknown type name 'T2'
        const T2 t2(1.1, 3, 2);
              ^
eq.pass.cpp:154:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 3, 2);
                 ^  ~~~~~~~~~
114 errors generated.
eq.pass.cpp failed to compile
lt.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
lt.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
lt.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
lt.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
lt.pass.cpp:53:15: error: unknown type name 'T1'
        const T1 t1;
              ^
lt.pass.cpp:54:15: error: unknown type name 'T2'
        const T2 t2;
              ^
lt.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:63:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:64:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
lt.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:73:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:74:15: error: unknown type name 'T2'
        const T2 t2(0.9);
              ^
lt.pass.cpp:81:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:81:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:82:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:82:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:83:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:84:15: error: unknown type name 'T2'
        const T2 t2(1.1);
              ^
lt.pass.cpp:91:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:91:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:92:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:92:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:93:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:93:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:94:15: error: unknown type name 'T2'
        const T2 t2(1, 2);
              ^
lt.pass.cpp:94:18: error: excess elements in scalar initializer
        const T2 t2(1, 2);
                 ^  ~~~~
lt.pass.cpp:101:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:101:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:102:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:102:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:103:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:103:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:104:15: error: unknown type name 'T2'
        const T2 t2(0.9, 2);
              ^
lt.pass.cpp:104:18: error: excess elements in scalar initializer
        const T2 t2(0.9, 2);
                 ^  ~~~~~~
lt.pass.cpp:111:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:111:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:112:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:112:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:113:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:113:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:114:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2);
              ^
lt.pass.cpp:114:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2);
                 ^  ~~~~~~
lt.pass.cpp:121:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:121:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:122:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:122:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:123:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:123:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:124:15: error: unknown type name 'T2'
        const T2 t2(1, 1);
              ^
lt.pass.cpp:124:18: error: excess elements in scalar initializer
        const T2 t2(1, 1);
                 ^  ~~~~
lt.pass.cpp:131:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:131:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:132:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:132:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:133:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:133:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:134:15: error: unknown type name 'T2'
        const T2 t2(1, 3);
              ^
lt.pass.cpp:134:18: error: excess elements in scalar initializer
        const T2 t2(1, 3);
                 ^  ~~~~
lt.pass.cpp:141:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:141:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:142:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:142:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:143:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:143:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:144:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 3);
              ^
lt.pass.cpp:144:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:151:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:151:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:152:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:152:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:153:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:153:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:154:15: error: unknown type name 'T2'
        const T2 t2(0.9, 2, 3);
              ^
lt.pass.cpp:154:18: error: excess elements in scalar initializer
        const T2 t2(0.9, 2, 3);
                 ^  ~~~~~~~~~
lt.pass.cpp:161:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:161:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:162:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:162:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:163:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:163:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:164:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 3);
              ^
lt.pass.cpp:164:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 3);
                 ^  ~~~~~~~~~
lt.pass.cpp:171:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:171:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:172:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:172:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:173:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:173:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:174:15: error: unknown type name 'T2'
        const T2 t2(1, 1, 3);
              ^
lt.pass.cpp:174:18: error: excess elements in scalar initializer
        const T2 t2(1, 1, 3);
                 ^  ~~~~~~~
lt.pass.cpp:181:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:181:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:182:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:182:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:183:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:183:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:184:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 3);
              ^
lt.pass.cpp:184:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 3);
                 ^  ~~~~~~~
lt.pass.cpp:191:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:191:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:192:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:192:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:193:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:193:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:194:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 2);
              ^
lt.pass.cpp:194:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 2);
                 ^  ~~~~~~~
lt.pass.cpp:201:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:201:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:202:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:202:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:203:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:203:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:204:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 4);
              ^
lt.pass.cpp:204:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 4);
                 ^  ~~~~~~~
120 errors generated.
lt.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.rel
non_member_swap.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
non_member_swap.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
non_member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t0;
        ^
non_member_swap.pass.cpp:41:9: error: use of undeclared identifier 'T'
        T t1;
        ^
non_member_swap.pass.cpp:42:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:45:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:45:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
non_member_swap.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
non_member_swap.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
non_member_swap.pass.cpp:48:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
non_member_swap.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
non_member_swap.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
non_member_swap.pass.cpp:55:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
non_member_swap.pass.cpp:56:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t0) == 2);
               ~~~~~^
non_member_swap.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:58:21: note: instantiated from:
        assert(std::get<1>(t0) == 3);
               ~~~~~^
non_member_swap.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
non_member_swap.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
non_member_swap.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
non_member_swap.pass.cpp:65:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(3), MoveOnly(4), MoveOnly(5));
        ^
non_member_swap.pass.cpp:66:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t0) == 3);
               ~~~~~^
non_member_swap.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:68:21: note: instantiated from:
        assert(std::get<1>(t0) == 4);
               ~~~~~^
non_member_swap.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t0) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:69:21: note: instantiated from:
        assert(std::get<2>(t0) == 5);
               ~~~~~^
non_member_swap.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:70:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:71:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
non_member_swap.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:72:21: note: instantiated from:
        assert(std::get<2>(t1) == 2);
               ~~~~~^
32 errors generated.
non_member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.special
member_swap.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
member_swap.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
member_swap.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t1;
        ^
member_swap.pass.cpp:41:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:41:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
member_swap.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
member_swap.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
member_swap.pass.cpp:47:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:47:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
member_swap.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
member_swap.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
member_swap.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
member_swap.pass.cpp:55:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:55:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t0) == 2);
               ~~~~~^
member_swap.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:57:21: note: instantiated from:
        assert(std::get<1>(t0) == 3);
               ~~~~~^
member_swap.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
member_swap.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
member_swap.pass.cpp:63:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
member_swap.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(3), MoveOnly(4), MoveOnly(5));
        ^
member_swap.pass.cpp:65:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:65:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:66:21: note: instantiated from:
        assert(std::get<0>(t0) == 3);
               ~~~~~^
member_swap.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:67:21: note: instantiated from:
        assert(std::get<1>(t0) == 4);
               ~~~~~^
member_swap.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t0) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:68:21: note: instantiated from:
        assert(std::get<2>(t0) == 5);
               ~~~~~^
member_swap.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:69:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:70:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
member_swap.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:71:21: note: instantiated from:
        assert(std::get<2>(t1) == 2);
               ~~~~~^
36 errors generated.
member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.swap
uses_allocator.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
uses_allocator.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
uses_allocator.pass.cpp:40:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:41:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:41:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:41:79: error: expected ')'
uses_allocator.pass.cpp:40:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
uses_allocator.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
uses_allocator.pass.cpp:45:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:45:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:45:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:45:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:45:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:46:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:46:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:46:79: error: expected ')'
uses_allocator.pass.cpp:45:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
uses_allocator.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
uses_allocator.pass.cpp:50:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:50:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:50:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:50:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:50:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:51:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:51:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:51:79: error: expected ')'
uses_allocator.pass.cpp:50:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, char, int> T;
                ~~~~~^
uses_allocator.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double&, char, int> T;
                          ^
uses_allocator.pass.cpp:55:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:55:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:55:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:55:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:55:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:56:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:56:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:56:79: error: expected ')'
uses_allocator.pass.cpp:55:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
40 errors generated.
uses_allocator.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.traits
passed 1 tests in /test/utilities/type.index
passed 1 tests in /test/utilities/type.index/type.index.hash
passed 5 tests in /test/utilities/type.index/type.index.members
passed 2 tests in /test/utilities/type.index/type.index.overview
passed 1 tests in /test/utilities/type.index/type.index.synopsis
passed 1 tests in /test/utilities/utilities.general
passed 1 tests in /test/utilities/utility
forward.pass.cpp:78:5: error: no matching function for call to 'forward'
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
forward.pass.cpp:78:31: note: instantiated from:
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
                              ^~~~~~~~~~~~~~~~~~~~~~
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:79:
In file included from ../../../../include/__tuple:39:
../../../../include/type_traits:1211:1: note: candidate function [with T = A const &, U = A] not viable: no known conversion from 'A' to 'A &' for 1st argument
forward(U& t)
^
../../../../include/type_traits:1223:1: note: candidate template ignored: failed template argument deduction
forward(U& t)
^
forward.pass.cpp:78:5: error: type name requires a specifier or qualifier
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:78:5: error: C++ requires a type specifier for all declarations
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:80:5: error: no matching function for call to 'forward'
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
forward.pass.cpp:80:31: note: instantiated from:
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
                              ^~~~~~~~~~~~~~~~~~~~~
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:79:
In file included from ../../../../include/__tuple:39:
../../../../include/type_traits:1211:1: note: candidate function [with T = A const, U = A] not viable: no known conversion from 'A' to 'A &' for 1st argument
forward(U& t)
^
../../../../include/type_traits:1223:1: note: candidate template ignored: failed template argument deduction
forward(U& t)
^
forward.pass.cpp:80:5: error: type name requires a specifier or qualifier
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:80:5: error: C++ requires a type specifier for all declarations
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
6 errors generated.
forward.pass.cpp failed to compile
failed 1 tests in /test/utilities/utility/forward
passed 12 tests in /test/utilities/utility/forward
passed 1 tests in /test/utilities/utility/operators
not implemented:  /test/utilities/utility/pairs
not implemented:  /test/utilities/utility/pairs/pair.astuple
not implemented:  /test/utilities/utility/pairs/pair.piecewise
not implemented:  /test/utilities/utility/pairs/pair.range
not implemented:  /test/utilities/utility/pairs/pairs.general
not implemented:  /test/utilities/utility/pairs/pairs.pair
passed 2 tests in /test/utilities/utility/utility.swap
passed 1 tests in /test/utilities/utility.requirements
passed 1 tests in /test/utilities/utility.requirements/allocator.requirements
passed 1 tests in /test/utilities/utility.requirements/hash.requirements
passed 1 tests in /test/utilities/utility.requirements/nullablepointer.requirements
passed 1 tests in /test/utilities/utility.requirements/swappable.requirements
passed 1 tests in /test/utilities/utility.requirements/utility.arg.requirements
****************************************************
Results for /test:
using Apple clang version 1.5 (trunk 100677)
Target: x86_64-apple-darwin10
Thread model: posix
with -nostdinc++ -nodefaultlibs /usr/lib/libSystem.B.dylib -arch x86_64 -I../include /usr/lib/libc++.dylib
----------------------------------------------------
sections without tests   : 145
sections with failures   : 159
sections without failures: 747
                       +   ----
total number of sections : 1051
----------------------------------------------------
number of tests failed   : 601
number of tests passed   : 2717
                       +   ----
total number of tests    : 3318
****************************************************
