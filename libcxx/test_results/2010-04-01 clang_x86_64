passed 1 tests in /test
passed 1 tests in /test/algorithms
passed 1 tests in /test/algorithms/alg.c.library
passed 1 tests in /test/algorithms/alg.modifying.operations
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.copy
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.fill
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.generate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.move
passed 5 tests in /test/algorithms/alg.modifying.operations/alg.partitions
random_shuffle_urng.pass.cpp:32:2: error: #error random_shuffle for UniformRandomNumberGenerator not implemented
#error random_shuffle for UniformRandomNumberGenerator not implemented
 ^
1 diagnostic generated.
random_shuffle_urng.pass.cpp failed to compile
failed 1 tests in /test/algorithms/alg.modifying.operations/alg.random.shuffle
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.random.shuffle
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.remove
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.replace
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.reverse
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.rotate
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.swap
passed 2 tests in /test/algorithms/alg.modifying.operations/alg.transform
passed 4 tests in /test/algorithms/alg.modifying.operations/alg.unique
passed 1 tests in /test/algorithms/alg.nonmodifying
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.adjacent.find
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.all_of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.any_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.count
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.equal
passed 3 tests in /test/algorithms/alg.nonmodifying/alg.find
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.end
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.find.first.of
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.foreach
passed 1 tests in /test/algorithms/alg.nonmodifying/alg.none_of
passed 2 tests in /test/algorithms/alg.nonmodifying/alg.search
passed 2 tests in /test/algorithms/alg.nonmodifying/mismatch
passed 1 tests in /test/algorithms/alg.sorting
passed 1 tests in /test/algorithms/alg.sorting/alg.binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/binary.search
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/equal.range
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/lower.bound
passed 2 tests in /test/algorithms/alg.sorting/alg.binary.search/upper.bound
passed 1 tests in /test/algorithms/alg.sorting/alg.heap.operations
passed 4 tests in /test/algorithms/alg.sorting/alg.heap.operations/is.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/make.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/pop.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/push.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.heap.operations/sort.heap
passed 2 tests in /test/algorithms/alg.sorting/alg.lex.comparison
passed 4 tests in /test/algorithms/alg.sorting/alg.merge
max_init_list.pass.cpp:33:2: error: #error max(initializer_list<T> t) is not implemented
#error max(initializer_list<T> t) is not implemented
 ^
1 diagnostic generated.
max_init_list.pass.cpp failed to compile
max_init_list_comp.pass.cpp:33:2: error: #error max(initializer_list<T> t, Compare comp) is not implemented
#error max(initializer_list<T> t, Compare comp) is not implemented
 ^
1 diagnostic generated.
max_init_list_comp.pass.cpp failed to compile
min_init_list.pass.cpp:33:2: error: #error min(initializer_list<T> t) is not implemented
#error min(initializer_list<T> t) is not implemented
 ^
1 diagnostic generated.
min_init_list.pass.cpp failed to compile
min_init_list_comp.pass.cpp:33:2: error: #error min(initializer_list<T> t, Compare comp) is not implemented
#error min(initializer_list<T> t, Compare comp) is not implemented
 ^
1 diagnostic generated.
min_init_list_comp.pass.cpp failed to compile
minmax.pass.cpp:37:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                      ~~~~~^
In file included from minmax.pass.cpp:30:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:38: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                     ^
minmax.pass.cpp:37:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b);
                                  ^
minmax.pass.cpp:47:5: note: in instantiation of function template specialization 'test<int>' requested here
    test(x, y, x, y);
    ^
In file included from minmax.pass.cpp:30:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:47: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                              ^
5 diagnostics generated.
minmax.pass.cpp failed to compile
minmax_comp.pass.cpp:39:44: error: no member named 'minmax' in namespace 'std'
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                      ~~~~~^
In file included from minmax_comp.pass.cpp:31:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:38: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                     ^
minmax_comp.pass.cpp:39:35: note: in instantiation of member function 'std::pair<int const &, int const &>::pair' requested here
    std::pair<const T&, const T&> p = std::minmax(a, b, c);
                                  ^
minmax_comp.pass.cpp:49:5: note: in instantiation of function template specialization 'test<int, std::greater<int> >' requested here
    test(x, y, std::greater<int>(), x, y);
    ^
In file included from minmax_comp.pass.cpp:31:
In file included from ../../../../include/algorithm:561:
../../../../include/utility:134:47: error: reference to type 'int const' requires an initializer
    _YUGA_INLINE_VISIBILITY pair() : first(), second() {}
                                              ^
5 diagnostics generated.
minmax_comp.pass.cpp failed to compile
minmax_init_list.pass.cpp:33:2: error: #error minmax(initializer_list<T> t) is not implemented
#error minmax(initializer_list<T> t) is not implemented
 ^
1 diagnostic generated.
minmax_init_list.pass.cpp failed to compile
minmax_init_list_comp.pass.cpp:33:2: error: #error minmax(initializer_list<T> t, Compare comp) is not implemented
#error minmax(initializer_list<T> t, Compare comp) is not implemented
 ^
1 diagnostic generated.
minmax_init_list_comp.pass.cpp failed to compile
failed 8 tests in /test/algorithms/alg.sorting/alg.min.max
passed 10 tests in /test/algorithms/alg.sorting/alg.min.max
passed 2 tests in /test/algorithms/alg.sorting/alg.nth.element
passed 4 tests in /test/algorithms/alg.sorting/alg.permutation.generators
passed 1 tests in /test/algorithms/alg.sorting/alg.set.operations
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/includes
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.intersection
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.symmetric.difference
passed 2 tests in /test/algorithms/alg.sorting/alg.set.operations/set.union
passed 1 tests in /test/algorithms/alg.sorting/alg.sort
passed 4 tests in /test/algorithms/alg.sorting/alg.sort/is.sorted
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/partial.sort.copy
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/sort
passed 2 tests in /test/algorithms/alg.sorting/alg.sort/stable.sort
passed 1 tests in /test/algorithms/algorithms.general
not implemented:  /test/atomics
not implemented:  /test/atomics/atomics.fences
not implemented:  /test/atomics/atomics.flag
not implemented:  /test/atomics/atomics.general
not implemented:  /test/atomics/atomics.lockfree
not implemented:  /test/atomics/atomics.order
not implemented:  /test/atomics/atomics.syn
not implemented:  /test/atomics/atomics.types
not implemented:  /test/atomics/atomics.types/atomics.types.address
not implemented:  /test/atomics/atomics.types/atomics.types.generic
not implemented:  /test/atomics/atomics.types/atomics.types.integral
not implemented:  /test/atomics/atomics.types.operations
passed 1 tests in /test/containers
passed 4 tests in /test/containers/associative
passed 1 tests in /test/containers/associative/map
passed 7 tests in /test/containers/associative/map/map.access
passed 17 tests in /test/containers/associative/map/map.cons
passed 12 tests in /test/containers/associative/map/map.modifiers
passed 5 tests in /test/containers/associative/map/map.ops
passed 2 tests in /test/containers/associative/map/map.special
passed 5 tests in /test/containers/associative/multimap
passed 17 tests in /test/containers/associative/multimap/multimap.cons
passed 12 tests in /test/containers/associative/multimap/multimap.modifiers
passed 5 tests in /test/containers/associative/multimap/multimap.ops
passed 2 tests in /test/containers/associative/multimap/multimap.special
passed 22 tests in /test/containers/associative/multiset
passed 17 tests in /test/containers/associative/multiset/multiset.cons
passed 2 tests in /test/containers/associative/multiset/multiset.special
passed 22 tests in /test/containers/associative/set
passed 17 tests in /test/containers/associative/set/set.cons
passed 2 tests in /test/containers/associative/set/set.special
passed 1 tests in /test/containers/container.requirements
passed 1 tests in /test/containers/container.requirements/associative.reqmts
passed 1 tests in /test/containers/container.requirements/associative.reqmts/associative.reqmts.except
passed 1 tests in /test/containers/container.requirements/container.requirements.dataraces
passed 1 tests in /test/containers/container.requirements/container.requirements.general
passed 1 tests in /test/containers/container.requirements/sequence.reqmts
passed 1 tests in /test/containers/container.requirements/unord.req
passed 1 tests in /test/containers/container.requirements/unord.req/unord.req.except
passed 1 tests in /test/containers/containers.general
passed 1 tests in /test/containers/sequences
passed 3 tests in /test/containers/sequences/array
passed 2 tests in /test/containers/sequences/array/array.cons
passed 2 tests in /test/containers/sequences/array/array.data
passed 1 tests in /test/containers/sequences/array/array.fill
passed 1 tests in /test/containers/sequences/array/array.size
passed 1 tests in /test/containers/sequences/array/array.special
passed 4 tests in /test/containers/sequences/array/array.tuple
passed 1 tests in /test/containers/sequences/array/array.zero
passed 1 tests in /test/containers/sequences/container.adaptors
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue
passed 17 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.cons
passed 8 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.members
passed 1 tests in /test/containers/sequences/container.adaptors/priority.queue/priqueue.special
passed 1 tests in /test/containers/sequences/container.adaptors/queue
passed 23 tests in /test/containers/sequences/container.adaptors/queue/queue.defn
passed 2 tests in /test/containers/sequences/container.adaptors/queue/queue.ops
passed 1 tests in /test/containers/sequences/container.adaptors/queue/queue.special
passed 1 tests in /test/containers/sequences/container.adaptors/stack
passed 21 tests in /test/containers/sequences/container.adaptors/stack/stack.defn
passed 2 tests in /test/containers/sequences/container.adaptors/stack/stack.ops
passed 1 tests in /test/containers/sequences/container.adaptors/stack/stack.special
passed 1 tests in /test/containers/sequences/deque
passed 4 tests in /test/containers/sequences/deque/deque.capacity
passed 19 tests in /test/containers/sequences/deque/deque.cons
passed 16 tests in /test/containers/sequences/deque/deque.modifiers
passed 5 tests in /test/containers/sequences/deque/deque.special
passed 2 tests in /test/containers/sequences/forwardlist
passed 1 tests in /test/containers/sequences/forwardlist/forwardlist.access
passed 21 tests in /test/containers/sequences/forwardlist/forwardlist.cons
passed 2 tests in /test/containers/sequences/forwardlist/forwardlist.iter
passed 15 tests in /test/containers/sequences/forwardlist/forwardlist.modifiers
passed 12 tests in /test/containers/sequences/forwardlist/forwardlist.ops
passed 4 tests in /test/containers/sequences/forwardlist/forwardlist.spec
passed 1 tests in /test/containers/sequences/list
passed 2 tests in /test/containers/sequences/list/list.capacity
passed 15 tests in /test/containers/sequences/list/list.cons
passed 17 tests in /test/containers/sequences/list/list.modifiers
passed 12 tests in /test/containers/sequences/list/list.ops
passed 1 tests in /test/containers/sequences/list/list.special
passed 1 tests in /test/containers/sequences/vector
passed 6 tests in /test/containers/sequences/vector/vector.capacity
passed 16 tests in /test/containers/sequences/vector/vector.cons
passed 2 tests in /test/containers/sequences/vector/vector.data
passed 11 tests in /test/containers/sequences/vector/vector.modifiers
passed 1 tests in /test/containers/sequences/vector/vector.special
passed 30 tests in /test/containers/sequences/vector.bool
passed 1 tests in /test/containers/unord
passed 29 tests in /test/containers/unord/unord.map
passed 24 tests in /test/containers/unord/unord.map/unord.map.cnstr
passed 2 tests in /test/containers/unord/unord.map/unord.map.elem
passed 1 tests in /test/containers/unord/unord.map/unord.map.swap
passed 31 tests in /test/containers/unord/unord.multimap
passed 24 tests in /test/containers/unord/unord.multimap/unord.multimap.cnstr
passed 1 tests in /test/containers/unord/unord.multimap/unord.multimap.swap
passed 31 tests in /test/containers/unord/unord.multiset
passed 24 tests in /test/containers/unord/unord.multiset/unord.multiset.cnstr
passed 1 tests in /test/containers/unord/unord.multiset/unord.multiset.swap
passed 31 tests in /test/containers/unord/unord.set
passed 24 tests in /test/containers/unord/unord.set/unord.set.cnstr
passed 1 tests in /test/containers/unord/unord.set/unord.set.swap
passed 1 tests in /test/depr
passed 1 tests in /test/depr/depr.auto.ptr
passed 1 tests in /test/depr/depr.auto.ptr/auto.ptr
passed 10 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.cons
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.conv
passed 4 tests in /test/depr/depr.auto.ptr/auto.ptr/auto.ptr.members
inttypes_h.pass.cpp:274:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
inttypes_h.pass.cpp:278:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
inttypes_h.pass.cpp:282:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
inttypes_h.pass.cpp:286:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
inttypes_h.pass.cpp:290:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
inttypes_h.pass.cpp:294:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
inttypes_h.pass.cpp:298:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
inttypes_h.pass.cpp:302:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
inttypes_h.pass.cpp:306:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
inttypes_h.pass.cpp:310:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
inttypes_h.pass.cpp:314:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
inttypes_h.pass.cpp:318:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
inttypes_h.pass.cpp:322:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
inttypes_h.pass.cpp:326:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
inttypes_h.pass.cpp:330:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
inttypes_h.pass.cpp:334:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
inttypes_h.pass.cpp:338:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
inttypes_h.pass.cpp:342:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
inttypes_h.pass.cpp:346:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
inttypes_h.pass.cpp:350:2: error: #error PRIiLEAST16 not defined
#error PRIiLEAST16 not defined
 ^
inttypes_h.pass.cpp:354:2: error: #error PRIiLEAST32 not defined
#error PRIiLEAST32 not defined
 ^
inttypes_h.pass.cpp:358:2: error: #error PRIiLEAST64 not defined
#error PRIiLEAST64 not defined
 ^
inttypes_h.pass.cpp:362:2: error: #error PRIiFAST8 not defined
#error PRIiFAST8 not defined
 ^
inttypes_h.pass.cpp:366:2: error: #error PRIiFAST16 not defined
#error PRIiFAST16 not defined
 ^
inttypes_h.pass.cpp:370:2: error: #error PRIiFAST32 not defined
#error PRIiFAST32 not defined
 ^
inttypes_h.pass.cpp:374:2: error: #error PRIiFAST64 not defined
#error PRIiFAST64 not defined
 ^
inttypes_h.pass.cpp:378:2: error: #error PRIiMAX not defined
#error PRIiMAX not defined
 ^
inttypes_h.pass.cpp:382:2: error: #error PRIiPTR not defined
#error PRIiPTR not defined
 ^
inttypes_h.pass.cpp:386:2: error: #error PRIo8 not defined
#error PRIo8 not defined
 ^
inttypes_h.pass.cpp:390:2: error: #error PRIo16 not defined
#error PRIo16 not defined
 ^
inttypes_h.pass.cpp:394:2: error: #error PRIo32 not defined
#error PRIo32 not defined
 ^
inttypes_h.pass.cpp:398:2: error: #error PRIo64 not defined
#error PRIo64 not defined
 ^
inttypes_h.pass.cpp:402:2: error: #error PRIoLEAST8 not defined
#error PRIoLEAST8 not defined
 ^
inttypes_h.pass.cpp:406:2: error: #error PRIoLEAST16 not defined
#error PRIoLEAST16 not defined
 ^
inttypes_h.pass.cpp:410:2: error: #error PRIoLEAST32 not defined
#error PRIoLEAST32 not defined
 ^
inttypes_h.pass.cpp:414:2: error: #error PRIoLEAST64 not defined
#error PRIoLEAST64 not defined
 ^
inttypes_h.pass.cpp:418:2: error: #error PRIoFAST8 not defined
#error PRIoFAST8 not defined
 ^
inttypes_h.pass.cpp:422:2: error: #error PRIoFAST16 not defined
#error PRIoFAST16 not defined
 ^
inttypes_h.pass.cpp:426:2: error: #error PRIoFAST32 not defined
#error PRIoFAST32 not defined
 ^
inttypes_h.pass.cpp:430:2: error: #error PRIoFAST64 not defined
#error PRIoFAST64 not defined
 ^
inttypes_h.pass.cpp:434:2: error: #error PRIoMAX not defined
#error PRIoMAX not defined
 ^
inttypes_h.pass.cpp:438:2: error: #error PRIoPTR not defined
#error PRIoPTR not defined
 ^
inttypes_h.pass.cpp:442:2: error: #error PRIu8 not defined
#error PRIu8 not defined
 ^
inttypes_h.pass.cpp:446:2: error: #error PRIu16 not defined
#error PRIu16 not defined
 ^
inttypes_h.pass.cpp:450:2: error: #error PRIu32 not defined
#error PRIu32 not defined
 ^
inttypes_h.pass.cpp:454:2: error: #error PRIu64 not defined
#error PRIu64 not defined
 ^
inttypes_h.pass.cpp:458:2: error: #error PRIuLEAST8 not defined
#error PRIuLEAST8 not defined
 ^
inttypes_h.pass.cpp:462:2: error: #error PRIuLEAST16 not defined
#error PRIuLEAST16 not defined
 ^
inttypes_h.pass.cpp:466:2: error: #error PRIuLEAST32 not defined
#error PRIuLEAST32 not defined
 ^
inttypes_h.pass.cpp:470:2: error: #error PRIuLEAST64 not defined
#error PRIuLEAST64 not defined
 ^
inttypes_h.pass.cpp:474:2: error: #error PRIuFAST8 not defined
#error PRIuFAST8 not defined
 ^
inttypes_h.pass.cpp:478:2: error: #error PRIuFAST16 not defined
#error PRIuFAST16 not defined
 ^
inttypes_h.pass.cpp:482:2: error: #error PRIuFAST32 not defined
#error PRIuFAST32 not defined
 ^
inttypes_h.pass.cpp:486:2: error: #error PRIuFAST64 not defined
#error PRIuFAST64 not defined
 ^
inttypes_h.pass.cpp:490:2: error: #error PRIuMAX not defined
#error PRIuMAX not defined
 ^
inttypes_h.pass.cpp:494:2: error: #error PRIuPTR not defined
#error PRIuPTR not defined
 ^
inttypes_h.pass.cpp:498:2: error: #error PRIx8 not defined
#error PRIx8 not defined
 ^
inttypes_h.pass.cpp:502:2: error: #error PRIx16 not defined
#error PRIx16 not defined
 ^
inttypes_h.pass.cpp:506:2: error: #error PRIx32 not defined
#error PRIx32 not defined
 ^
inttypes_h.pass.cpp:510:2: error: #error PRIx64 not defined
#error PRIx64 not defined
 ^
inttypes_h.pass.cpp:514:2: error: #error PRIxLEAST8 not defined
#error PRIxLEAST8 not defined
 ^
inttypes_h.pass.cpp:518:2: error: #error PRIxLEAST16 not defined
#error PRIxLEAST16 not defined
 ^
inttypes_h.pass.cpp:522:2: error: #error PRIxLEAST32 not defined
#error PRIxLEAST32 not defined
 ^
inttypes_h.pass.cpp:526:2: error: #error PRIxLEAST64 not defined
#error PRIxLEAST64 not defined
 ^
inttypes_h.pass.cpp:530:2: error: #error PRIxFAST8 not defined
#error PRIxFAST8 not defined
 ^
inttypes_h.pass.cpp:534:2: error: #error PRIxFAST16 not defined
#error PRIxFAST16 not defined
 ^
inttypes_h.pass.cpp:538:2: error: #error PRIxFAST32 not defined
#error PRIxFAST32 not defined
 ^
inttypes_h.pass.cpp:542:2: error: #error PRIxFAST64 not defined
#error PRIxFAST64 not defined
 ^
inttypes_h.pass.cpp:546:2: error: #error PRIxMAX not defined
#error PRIxMAX not defined
 ^
inttypes_h.pass.cpp:550:2: error: #error PRIxPTR not defined
#error PRIxPTR not defined
 ^
inttypes_h.pass.cpp:554:2: error: #error PRIX8 not defined
#error PRIX8 not defined
 ^
inttypes_h.pass.cpp:558:2: error: #error PRIX16 not defined
#error PRIX16 not defined
 ^
inttypes_h.pass.cpp:562:2: error: #error PRIX32 not defined
#error PRIX32 not defined
 ^
inttypes_h.pass.cpp:566:2: error: #error PRIX64 not defined
#error PRIX64 not defined
 ^
inttypes_h.pass.cpp:570:2: error: #error PRIXLEAST8 not defined
#error PRIXLEAST8 not defined
 ^
inttypes_h.pass.cpp:574:2: error: #error PRIXLEAST16 not defined
#error PRIXLEAST16 not defined
 ^
inttypes_h.pass.cpp:578:2: error: #error PRIXLEAST32 not defined
#error PRIXLEAST32 not defined
 ^
inttypes_h.pass.cpp:582:2: error: #error PRIXLEAST64 not defined
#error PRIXLEAST64 not defined
 ^
inttypes_h.pass.cpp:586:2: error: #error PRIXFAST8 not defined
#error PRIXFAST8 not defined
 ^
inttypes_h.pass.cpp:590:2: error: #error PRIXFAST16 not defined
#error PRIXFAST16 not defined
 ^
inttypes_h.pass.cpp:594:2: error: #error PRIXFAST32 not defined
#error PRIXFAST32 not defined
 ^
inttypes_h.pass.cpp:598:2: error: #error PRIXFAST64 not defined
#error PRIXFAST64 not defined
 ^
inttypes_h.pass.cpp:602:2: error: #error PRIXMAX not defined
#error PRIXMAX not defined
 ^
inttypes_h.pass.cpp:606:2: error: #error PRIXPTR not defined
#error PRIXPTR not defined
 ^
inttypes_h.pass.cpp:610:2: error: #error SCNd8 not defined
#error SCNd8 not defined
 ^
inttypes_h.pass.cpp:614:2: error: #error SCNd16 not defined
#error SCNd16 not defined
 ^
inttypes_h.pass.cpp:618:2: error: #error SCNd32 not defined
#error SCNd32 not defined
 ^
inttypes_h.pass.cpp:622:2: error: #error SCNd64 not defined
#error SCNd64 not defined
 ^
inttypes_h.pass.cpp:626:2: error: #error SCNdLEAST8 not defined
#error SCNdLEAST8 not defined
 ^
inttypes_h.pass.cpp:630:2: error: #error SCNdLEAST16 not defined
#error SCNdLEAST16 not defined
 ^
inttypes_h.pass.cpp:634:2: error: #error SCNdLEAST32 not defined
#error SCNdLEAST32 not defined
 ^
inttypes_h.pass.cpp:638:2: error: #error SCNdLEAST64 not defined
#error SCNdLEAST64 not defined
 ^
inttypes_h.pass.cpp:642:2: error: #error SCNdFAST8 not defined
#error SCNdFAST8 not defined
 ^
inttypes_h.pass.cpp:646:2: error: #error SCNdFAST16 not defined
#error SCNdFAST16 not defined
 ^
inttypes_h.pass.cpp:650:2: error: #error SCNdFAST32 not defined
#error SCNdFAST32 not defined
 ^
inttypes_h.pass.cpp:654:2: error: #error SCNdFAST64 not defined
#error SCNdFAST64 not defined
 ^
inttypes_h.pass.cpp:658:2: error: #error SCNdMAX not defined
#error SCNdMAX not defined
 ^
inttypes_h.pass.cpp:662:2: error: #error SCNdPTR not defined
#error SCNdPTR not defined
 ^
inttypes_h.pass.cpp:666:2: error: #error SCNi8 not defined
#error SCNi8 not defined
 ^
inttypes_h.pass.cpp:670:2: error: #error SCNi16 not defined
#error SCNi16 not defined
 ^
inttypes_h.pass.cpp:674:2: error: #error SCNi32 not defined
#error SCNi32 not defined
 ^
inttypes_h.pass.cpp:678:2: error: #error SCNi64 not defined
#error SCNi64 not defined
 ^
inttypes_h.pass.cpp:682:2: error: #error SCNiLEAST8 not defined
#error SCNiLEAST8 not defined
 ^
inttypes_h.pass.cpp:686:2: error: #error SCNiLEAST16 not defined
#error SCNiLEAST16 not defined
 ^
inttypes_h.pass.cpp:690:2: error: #error SCNiLEAST32 not defined
#error SCNiLEAST32 not defined
 ^
inttypes_h.pass.cpp:694:2: error: #error SCNiLEAST64 not defined
#error SCNiLEAST64 not defined
 ^
inttypes_h.pass.cpp:698:2: error: #error SCNiFAST8 not defined
#error SCNiFAST8 not defined
 ^
inttypes_h.pass.cpp:702:2: error: #error SCNiFAST16 not defined
#error SCNiFAST16 not defined
 ^
inttypes_h.pass.cpp:706:2: error: #error SCNiFAST32 not defined
#error SCNiFAST32 not defined
 ^
inttypes_h.pass.cpp:710:2: error: #error SCNiFAST64 not defined
#error SCNiFAST64 not defined
 ^
inttypes_h.pass.cpp:714:2: error: #error SCNiMAX not defined
#error SCNiMAX not defined
 ^
inttypes_h.pass.cpp:718:2: error: #error SCNiPTR not defined
#error SCNiPTR not defined
 ^
inttypes_h.pass.cpp:722:2: error: #error SCNo8 not defined
#error SCNo8 not defined
 ^
inttypes_h.pass.cpp:726:2: error: #error SCNo16 not defined
#error SCNo16 not defined
 ^
inttypes_h.pass.cpp:730:2: error: #error SCNo32 not defined
#error SCNo32 not defined
 ^
inttypes_h.pass.cpp:734:2: error: #error SCNo64 not defined
#error SCNo64 not defined
 ^
inttypes_h.pass.cpp:738:2: error: #error SCNoLEAST8 not defined
#error SCNoLEAST8 not defined
 ^
inttypes_h.pass.cpp:742:2: error: #error SCNoLEAST16 not defined
#error SCNoLEAST16 not defined
 ^
inttypes_h.pass.cpp:746:2: error: #error SCNoLEAST32 not defined
#error SCNoLEAST32 not defined
 ^
inttypes_h.pass.cpp:750:2: error: #error SCNoLEAST64 not defined
#error SCNoLEAST64 not defined
 ^
inttypes_h.pass.cpp:754:2: error: #error SCNoFAST8 not defined
#error SCNoFAST8 not defined
 ^
inttypes_h.pass.cpp:758:2: error: #error SCNoFAST16 not defined
#error SCNoFAST16 not defined
 ^
inttypes_h.pass.cpp:762:2: error: #error SCNoFAST32 not defined
#error SCNoFAST32 not defined
 ^
inttypes_h.pass.cpp:766:2: error: #error SCNoFAST64 not defined
#error SCNoFAST64 not defined
 ^
inttypes_h.pass.cpp:770:2: error: #error SCNoMAX not defined
#error SCNoMAX not defined
 ^
inttypes_h.pass.cpp:774:2: error: #error SCNoPTR not defined
#error SCNoPTR not defined
 ^
inttypes_h.pass.cpp:778:2: error: #error SCNu8 not defined
#error SCNu8 not defined
 ^
inttypes_h.pass.cpp:782:2: error: #error SCNu16 not defined
#error SCNu16 not defined
 ^
inttypes_h.pass.cpp:786:2: error: #error SCNu32 not defined
#error SCNu32 not defined
 ^
inttypes_h.pass.cpp:790:2: error: #error SCNu64 not defined
#error SCNu64 not defined
 ^
inttypes_h.pass.cpp:794:2: error: #error SCNuLEAST8 not defined
#error SCNuLEAST8 not defined
 ^
inttypes_h.pass.cpp:798:2: error: #error SCNuLEAST16 not defined
#error SCNuLEAST16 not defined
 ^
inttypes_h.pass.cpp:802:2: error: #error SCNuLEAST32 not defined
#error SCNuLEAST32 not defined
 ^
inttypes_h.pass.cpp:806:2: error: #error SCNuLEAST64 not defined
#error SCNuLEAST64 not defined
 ^
inttypes_h.pass.cpp:810:2: error: #error SCNuFAST8 not defined
#error SCNuFAST8 not defined
 ^
inttypes_h.pass.cpp:814:2: error: #error SCNuFAST16 not defined
#error SCNuFAST16 not defined
 ^
inttypes_h.pass.cpp:818:2: error: #error SCNuFAST32 not defined
#error SCNuFAST32 not defined
 ^
inttypes_h.pass.cpp:822:2: error: #error SCNuFAST64 not defined
#error SCNuFAST64 not defined
 ^
inttypes_h.pass.cpp:826:2: error: #error SCNuMAX not defined
#error SCNuMAX not defined
 ^
inttypes_h.pass.cpp:830:2: error: #error SCNuPTR not defined
#error SCNuPTR not defined
 ^
inttypes_h.pass.cpp:834:2: error: #error SCNx8 not defined
#error SCNx8 not defined
 ^
inttypes_h.pass.cpp:838:2: error: #error SCNx16 not defined
#error SCNx16 not defined
 ^
inttypes_h.pass.cpp:842:2: error: #error SCNx32 not defined
#error SCNx32 not defined
 ^
inttypes_h.pass.cpp:846:2: error: #error SCNx64 not defined
#error SCNx64 not defined
 ^
inttypes_h.pass.cpp:850:2: error: #error SCNxLEAST8 not defined
#error SCNxLEAST8 not defined
 ^
inttypes_h.pass.cpp:854:2: error: #error SCNxLEAST16 not defined
#error SCNxLEAST16 not defined
 ^
inttypes_h.pass.cpp:858:2: error: #error SCNxLEAST32 not defined
#error SCNxLEAST32 not defined
 ^
inttypes_h.pass.cpp:862:2: error: #error SCNxLEAST64 not defined
#error SCNxLEAST64 not defined
 ^
inttypes_h.pass.cpp:866:2: error: #error SCNxFAST8 not defined
#error SCNxFAST8 not defined
 ^
inttypes_h.pass.cpp:870:2: error: #error SCNxFAST16 not defined
#error SCNxFAST16 not defined
 ^
inttypes_h.pass.cpp:874:2: error: #error SCNxFAST32 not defined
#error SCNxFAST32 not defined
 ^
inttypes_h.pass.cpp:878:2: error: #error SCNxFAST64 not defined
#error SCNxFAST64 not defined
 ^
inttypes_h.pass.cpp:882:2: error: #error SCNxMAX not defined
#error SCNxMAX not defined
 ^
inttypes_h.pass.cpp:886:2: error: #error SCNxPTR not defined
#error SCNxPTR not defined
 ^
154 diagnostics generated.
inttypes_h.pass.cpp failed to compile
math_h.pass.cpp:545:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(nextafter(0,1) == 0x1p-1074);
    ^
math_h.pass.cpp:545:30: note: instantiated from:
    assert(nextafter(0,1) == 0x1p-1074);
                             ^
math_h.pass.cpp:553:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(nexttoward(0, 1) == 0x1p-1074);
    ^
math_h.pass.cpp:553:32: note: instantiated from:
    assert(nexttoward(0, 1) == 0x1p-1074);
                               ^
2 diagnostics generated.
stdio_h.pass.cpp:111:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:111:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:111:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:112:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:112:33: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:112:53: note: instantiated from:
    static_assert((std::is_same<decltype(fprintf(fp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:114:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:114:33: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:114:49: note: instantiated from:
    static_assert((std::is_same<decltype(printf("")), int>::value), "");
                                                ^~
stdio_h.pass.cpp:116:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:116:33: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:116:56: note: instantiated from:
    static_assert((std::is_same<decltype(snprintf(cp,0,"")), int>::value), "");
                                                       ^~
stdio_h.pass.cpp:117:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:117:33: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:117:53: note: instantiated from:
    static_assert((std::is_same<decltype(sprintf(cp,"")), int>::value), "");
                                                    ^~
stdio_h.pass.cpp:119:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:119:33: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:119:54: note: instantiated from:
    static_assert((std::is_same<decltype(vfprintf(fp,"",va)), int>::value), "");
                                                     ^~
stdio_h.pass.cpp:121:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:121:33: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:121:50: note: instantiated from:
    static_assert((std::is_same<decltype(vprintf("",va)), int>::value), "");
                                                 ^~
stdio_h.pass.cpp:123:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:123:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:123:57: note: instantiated from:
    static_assert((std::is_same<decltype(vsnprintf(cp,0,"",va)), int>::value), "");
                                                        ^~
stdio_h.pass.cpp:124:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:124:33: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
stdio_h.pass.cpp:124:54: note: instantiated from:
    static_assert((std::is_same<decltype(vsprintf(cp,"",va)), int>::value), "");
                                                     ^~
9 diagnostics generated.
uchar_h.pass.cpp:26:10: fatal error: 'uchar.h' file not found
#include <uchar.h>
         ^
1 diagnostic generated.
uchar_h.pass.cpp failed to compile
failed 2 tests in /test/depr/depr.c.headers
passed 24 tests in /test/depr/depr.c.headers
passed 5 tests in /test/depr/depr.ios.members
passed 1 tests in /test/depr/depr.lib.binders
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.bind.2nd
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.1st
passed 1 tests in /test/depr/depr.lib.binders/depr.lib.binder.2nd
passed 1 tests in /test/depr/depr.str.strstreams
passed 1 tests in /test/depr/depr.str.strstreams/depr.istrstream
./testit: line 96: 32105 Abort trap              ./a.out
ccp.pass.cpp failed at run time
./testit: line 96: 32113 Abort trap              ./a.out
ccp_size.pass.cpp failed at run time
./testit: line 96: 32120 Abort trap              ./a.out
cp.pass.cpp failed at run time
./testit: line 96: 32127 Abort trap              ./a.out
cp_size.pass.cpp failed at run time
failed 4 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.cons
./testit: line 96: 32138 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 32145 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.istrstream/depr.istrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.ostrstream
./testit: line 96: 32167 Abort trap              ./a.out
cp_size_mode.pass.cpp failed at run time
./testit: line 96: 32174 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.cons
./testit: line 96: 32185 Abort trap              ./a.out
freeze.pass.cpp failed at run time
./testit: line 96: 32192 Abort trap              ./a.out
pcount.pass.cpp failed at run time
./testit: line 96: 32199 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 32206 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 4 tests in /test/depr/depr.str.strstreams/depr.ostrstream/depr.ostrstream.members
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstream
./testit: line 96: 32228 Abort trap              ./a.out
cp_size_mode.pass.cpp failed at run time
./testit: line 96: 32236 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 2 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.cons
./testit: line 96: 32247 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 1 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.dest
./testit: line 96: 32258 Abort trap              ./a.out
freeze.pass.cpp failed at run time
./testit: line 96: 32265 Abort trap              ./a.out
pcount.pass.cpp failed at run time
./testit: line 96: 32272 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 3 tests in /test/depr/depr.str.strstreams/depr.strstream/depr.strstream.oper
passed 1 tests in /test/depr/depr.str.strstreams/depr.strstreambuf
passed 8 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.cons
passed 3 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.members
passed 6 tests in /test/depr/depr.str.strstreams/depr.strstreambuf/depr.strstreambuf.virtuals
passed 1 tests in /test/diagnostics
passed 1 tests in /test/diagnostics/assertions
passed 1 tests in /test/diagnostics/diagnostics.general
passed 1 tests in /test/diagnostics/errno
passed 1 tests in /test/diagnostics/std.exceptions
passed 1 tests in /test/diagnostics/std.exceptions/domain.error
passed 1 tests in /test/diagnostics/std.exceptions/invalid.argument
passed 1 tests in /test/diagnostics/std.exceptions/length.error
passed 1 tests in /test/diagnostics/std.exceptions/logic.error
passed 1 tests in /test/diagnostics/std.exceptions/out.of.range
passed 1 tests in /test/diagnostics/std.exceptions/overflow.error
passed 1 tests in /test/diagnostics/std.exceptions/range.error
passed 1 tests in /test/diagnostics/std.exceptions/runtime.error
passed 1 tests in /test/diagnostics/std.exceptions/underflow.error
passed 1 tests in /test/diagnostics/syserr
passed 1 tests in /test/diagnostics/syserr/syserr.compare
passed 1 tests in /test/diagnostics/syserr/syserr.errcat
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.derived
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.nonvirtuals
passed 2 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.objects
passed 1 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.overview
passed 3 tests in /test/diagnostics/syserr/syserr.errcat/syserr.errcat.virtuals
passed 1 tests in /test/diagnostics/syserr/syserr.errcode
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.modifiers
./testit: line 96: 32778 Abort trap              ./a.out
stream_inserter.pass.cpp failed at run time
failed 1 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.nonmembers
passed 2 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.nonmembers
passed 5 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcode/syserr.errcode.overview
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.constructors
passed 3 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.modifiers
passed 2 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.nonmembers
passed 4 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.observers
passed 1 tests in /test/diagnostics/syserr/syserr.errcondition/syserr.errcondition.overview
passed 1 tests in /test/diagnostics/syserr/syserr.syserr
passed 6 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.members
passed 1 tests in /test/diagnostics/syserr/syserr.syserr/syserr.syserr.overview
passed 1 tests in /test/input.output
passed 1 tests in /test/input.output/file.streams
cinttypes.pass.cpp:274:2: error: #error PRId8 not defined
#error PRId8 not defined
 ^
cinttypes.pass.cpp:278:2: error: #error PRId16 not defined
#error PRId16 not defined
 ^
cinttypes.pass.cpp:282:2: error: #error PRId32 not defined
#error PRId32 not defined
 ^
cinttypes.pass.cpp:286:2: error: #error PRId64 not defined
#error PRId64 not defined
 ^
cinttypes.pass.cpp:290:2: error: #error PRIdLEAST8 not defined
#error PRIdLEAST8 not defined
 ^
cinttypes.pass.cpp:294:2: error: #error PRIdLEAST16 not defined
#error PRIdLEAST16 not defined
 ^
cinttypes.pass.cpp:298:2: error: #error PRIdLEAST32 not defined
#error PRIdLEAST32 not defined
 ^
cinttypes.pass.cpp:302:2: error: #error PRIdLEAST64 not defined
#error PRIdLEAST64 not defined
 ^
cinttypes.pass.cpp:306:2: error: #error PRIdFAST8 not defined
#error PRIdFAST8 not defined
 ^
cinttypes.pass.cpp:310:2: error: #error PRIdFAST16 not defined
#error PRIdFAST16 not defined
 ^
cinttypes.pass.cpp:314:2: error: #error PRIdFAST32 not defined
#error PRIdFAST32 not defined
 ^
cinttypes.pass.cpp:318:2: error: #error PRIdFAST64 not defined
#error PRIdFAST64 not defined
 ^
cinttypes.pass.cpp:322:2: error: #error PRIdMAX not defined
#error PRIdMAX not defined
 ^
cinttypes.pass.cpp:326:2: error: #error PRIdPTR not defined
#error PRIdPTR not defined
 ^
cinttypes.pass.cpp:330:2: error: #error PRIi8 not defined
#error PRIi8 not defined
 ^
cinttypes.pass.cpp:334:2: error: #error PRIi16 not defined
#error PRIi16 not defined
 ^
cinttypes.pass.cpp:338:2: error: #error PRIi32 not defined
#error PRIi32 not defined
 ^
cinttypes.pass.cpp:342:2: error: #error PRIi64 not defined
#error PRIi64 not defined
 ^
cinttypes.pass.cpp:346:2: error: #error PRIiLEAST8 not defined
#error PRIiLEAST8 not defined
 ^
cinttypes.pass.cpp:350:2: error: #error PRIiLEAST16 not defined
#error PRIiLEAST16 not defined
 ^
cinttypes.pass.cpp:354:2: error: #error PRIiLEAST32 not defined
#error PRIiLEAST32 not defined
 ^
cinttypes.pass.cpp:358:2: error: #error PRIiLEAST64 not defined
#error PRIiLEAST64 not defined
 ^
cinttypes.pass.cpp:362:2: error: #error PRIiFAST8 not defined
#error PRIiFAST8 not defined
 ^
cinttypes.pass.cpp:366:2: error: #error PRIiFAST16 not defined
#error PRIiFAST16 not defined
 ^
cinttypes.pass.cpp:370:2: error: #error PRIiFAST32 not defined
#error PRIiFAST32 not defined
 ^
cinttypes.pass.cpp:374:2: error: #error PRIiFAST64 not defined
#error PRIiFAST64 not defined
 ^
cinttypes.pass.cpp:378:2: error: #error PRIiMAX not defined
#error PRIiMAX not defined
 ^
cinttypes.pass.cpp:382:2: error: #error PRIiPTR not defined
#error PRIiPTR not defined
 ^
cinttypes.pass.cpp:386:2: error: #error PRIo8 not defined
#error PRIo8 not defined
 ^
cinttypes.pass.cpp:390:2: error: #error PRIo16 not defined
#error PRIo16 not defined
 ^
cinttypes.pass.cpp:394:2: error: #error PRIo32 not defined
#error PRIo32 not defined
 ^
cinttypes.pass.cpp:398:2: error: #error PRIo64 not defined
#error PRIo64 not defined
 ^
cinttypes.pass.cpp:402:2: error: #error PRIoLEAST8 not defined
#error PRIoLEAST8 not defined
 ^
cinttypes.pass.cpp:406:2: error: #error PRIoLEAST16 not defined
#error PRIoLEAST16 not defined
 ^
cinttypes.pass.cpp:410:2: error: #error PRIoLEAST32 not defined
#error PRIoLEAST32 not defined
 ^
cinttypes.pass.cpp:414:2: error: #error PRIoLEAST64 not defined
#error PRIoLEAST64 not defined
 ^
cinttypes.pass.cpp:418:2: error: #error PRIoFAST8 not defined
#error PRIoFAST8 not defined
 ^
cinttypes.pass.cpp:422:2: error: #error PRIoFAST16 not defined
#error PRIoFAST16 not defined
 ^
cinttypes.pass.cpp:426:2: error: #error PRIoFAST32 not defined
#error PRIoFAST32 not defined
 ^
cinttypes.pass.cpp:430:2: error: #error PRIoFAST64 not defined
#error PRIoFAST64 not defined
 ^
cinttypes.pass.cpp:434:2: error: #error PRIoMAX not defined
#error PRIoMAX not defined
 ^
cinttypes.pass.cpp:438:2: error: #error PRIoPTR not defined
#error PRIoPTR not defined
 ^
cinttypes.pass.cpp:442:2: error: #error PRIu8 not defined
#error PRIu8 not defined
 ^
cinttypes.pass.cpp:446:2: error: #error PRIu16 not defined
#error PRIu16 not defined
 ^
cinttypes.pass.cpp:450:2: error: #error PRIu32 not defined
#error PRIu32 not defined
 ^
cinttypes.pass.cpp:454:2: error: #error PRIu64 not defined
#error PRIu64 not defined
 ^
cinttypes.pass.cpp:458:2: error: #error PRIuLEAST8 not defined
#error PRIuLEAST8 not defined
 ^
cinttypes.pass.cpp:462:2: error: #error PRIuLEAST16 not defined
#error PRIuLEAST16 not defined
 ^
cinttypes.pass.cpp:466:2: error: #error PRIuLEAST32 not defined
#error PRIuLEAST32 not defined
 ^
cinttypes.pass.cpp:470:2: error: #error PRIuLEAST64 not defined
#error PRIuLEAST64 not defined
 ^
cinttypes.pass.cpp:474:2: error: #error PRIuFAST8 not defined
#error PRIuFAST8 not defined
 ^
cinttypes.pass.cpp:478:2: error: #error PRIuFAST16 not defined
#error PRIuFAST16 not defined
 ^
cinttypes.pass.cpp:482:2: error: #error PRIuFAST32 not defined
#error PRIuFAST32 not defined
 ^
cinttypes.pass.cpp:486:2: error: #error PRIuFAST64 not defined
#error PRIuFAST64 not defined
 ^
cinttypes.pass.cpp:490:2: error: #error PRIuMAX not defined
#error PRIuMAX not defined
 ^
cinttypes.pass.cpp:494:2: error: #error PRIuPTR not defined
#error PRIuPTR not defined
 ^
cinttypes.pass.cpp:498:2: error: #error PRIx8 not defined
#error PRIx8 not defined
 ^
cinttypes.pass.cpp:502:2: error: #error PRIx16 not defined
#error PRIx16 not defined
 ^
cinttypes.pass.cpp:506:2: error: #error PRIx32 not defined
#error PRIx32 not defined
 ^
cinttypes.pass.cpp:510:2: error: #error PRIx64 not defined
#error PRIx64 not defined
 ^
cinttypes.pass.cpp:514:2: error: #error PRIxLEAST8 not defined
#error PRIxLEAST8 not defined
 ^
cinttypes.pass.cpp:518:2: error: #error PRIxLEAST16 not defined
#error PRIxLEAST16 not defined
 ^
cinttypes.pass.cpp:522:2: error: #error PRIxLEAST32 not defined
#error PRIxLEAST32 not defined
 ^
cinttypes.pass.cpp:526:2: error: #error PRIxLEAST64 not defined
#error PRIxLEAST64 not defined
 ^
cinttypes.pass.cpp:530:2: error: #error PRIxFAST8 not defined
#error PRIxFAST8 not defined
 ^
cinttypes.pass.cpp:534:2: error: #error PRIxFAST16 not defined
#error PRIxFAST16 not defined
 ^
cinttypes.pass.cpp:538:2: error: #error PRIxFAST32 not defined
#error PRIxFAST32 not defined
 ^
cinttypes.pass.cpp:542:2: error: #error PRIxFAST64 not defined
#error PRIxFAST64 not defined
 ^
cinttypes.pass.cpp:546:2: error: #error PRIxMAX not defined
#error PRIxMAX not defined
 ^
cinttypes.pass.cpp:550:2: error: #error PRIxPTR not defined
#error PRIxPTR not defined
 ^
cinttypes.pass.cpp:554:2: error: #error PRIX8 not defined
#error PRIX8 not defined
 ^
cinttypes.pass.cpp:558:2: error: #error PRIX16 not defined
#error PRIX16 not defined
 ^
cinttypes.pass.cpp:562:2: error: #error PRIX32 not defined
#error PRIX32 not defined
 ^
cinttypes.pass.cpp:566:2: error: #error PRIX64 not defined
#error PRIX64 not defined
 ^
cinttypes.pass.cpp:570:2: error: #error PRIXLEAST8 not defined
#error PRIXLEAST8 not defined
 ^
cinttypes.pass.cpp:574:2: error: #error PRIXLEAST16 not defined
#error PRIXLEAST16 not defined
 ^
cinttypes.pass.cpp:578:2: error: #error PRIXLEAST32 not defined
#error PRIXLEAST32 not defined
 ^
cinttypes.pass.cpp:582:2: error: #error PRIXLEAST64 not defined
#error PRIXLEAST64 not defined
 ^
cinttypes.pass.cpp:586:2: error: #error PRIXFAST8 not defined
#error PRIXFAST8 not defined
 ^
cinttypes.pass.cpp:590:2: error: #error PRIXFAST16 not defined
#error PRIXFAST16 not defined
 ^
cinttypes.pass.cpp:594:2: error: #error PRIXFAST32 not defined
#error PRIXFAST32 not defined
 ^
cinttypes.pass.cpp:598:2: error: #error PRIXFAST64 not defined
#error PRIXFAST64 not defined
 ^
cinttypes.pass.cpp:602:2: error: #error PRIXMAX not defined
#error PRIXMAX not defined
 ^
cinttypes.pass.cpp:606:2: error: #error PRIXPTR not defined
#error PRIXPTR not defined
 ^
cinttypes.pass.cpp:610:2: error: #error SCNd8 not defined
#error SCNd8 not defined
 ^
cinttypes.pass.cpp:614:2: error: #error SCNd16 not defined
#error SCNd16 not defined
 ^
cinttypes.pass.cpp:618:2: error: #error SCNd32 not defined
#error SCNd32 not defined
 ^
cinttypes.pass.cpp:622:2: error: #error SCNd64 not defined
#error SCNd64 not defined
 ^
cinttypes.pass.cpp:626:2: error: #error SCNdLEAST8 not defined
#error SCNdLEAST8 not defined
 ^
cinttypes.pass.cpp:630:2: error: #error SCNdLEAST16 not defined
#error SCNdLEAST16 not defined
 ^
cinttypes.pass.cpp:634:2: error: #error SCNdLEAST32 not defined
#error SCNdLEAST32 not defined
 ^
cinttypes.pass.cpp:638:2: error: #error SCNdLEAST64 not defined
#error SCNdLEAST64 not defined
 ^
cinttypes.pass.cpp:642:2: error: #error SCNdFAST8 not defined
#error SCNdFAST8 not defined
 ^
cinttypes.pass.cpp:646:2: error: #error SCNdFAST16 not defined
#error SCNdFAST16 not defined
 ^
cinttypes.pass.cpp:650:2: error: #error SCNdFAST32 not defined
#error SCNdFAST32 not defined
 ^
cinttypes.pass.cpp:654:2: error: #error SCNdFAST64 not defined
#error SCNdFAST64 not defined
 ^
cinttypes.pass.cpp:658:2: error: #error SCNdMAX not defined
#error SCNdMAX not defined
 ^
cinttypes.pass.cpp:662:2: error: #error SCNdPTR not defined
#error SCNdPTR not defined
 ^
cinttypes.pass.cpp:666:2: error: #error SCNi8 not defined
#error SCNi8 not defined
 ^
cinttypes.pass.cpp:670:2: error: #error SCNi16 not defined
#error SCNi16 not defined
 ^
cinttypes.pass.cpp:674:2: error: #error SCNi32 not defined
#error SCNi32 not defined
 ^
cinttypes.pass.cpp:678:2: error: #error SCNi64 not defined
#error SCNi64 not defined
 ^
cinttypes.pass.cpp:682:2: error: #error SCNiLEAST8 not defined
#error SCNiLEAST8 not defined
 ^
cinttypes.pass.cpp:686:2: error: #error SCNiLEAST16 not defined
#error SCNiLEAST16 not defined
 ^
cinttypes.pass.cpp:690:2: error: #error SCNiLEAST32 not defined
#error SCNiLEAST32 not defined
 ^
cinttypes.pass.cpp:694:2: error: #error SCNiLEAST64 not defined
#error SCNiLEAST64 not defined
 ^
cinttypes.pass.cpp:698:2: error: #error SCNiFAST8 not defined
#error SCNiFAST8 not defined
 ^
cinttypes.pass.cpp:702:2: error: #error SCNiFAST16 not defined
#error SCNiFAST16 not defined
 ^
cinttypes.pass.cpp:706:2: error: #error SCNiFAST32 not defined
#error SCNiFAST32 not defined
 ^
cinttypes.pass.cpp:710:2: error: #error SCNiFAST64 not defined
#error SCNiFAST64 not defined
 ^
cinttypes.pass.cpp:714:2: error: #error SCNiMAX not defined
#error SCNiMAX not defined
 ^
cinttypes.pass.cpp:718:2: error: #error SCNiPTR not defined
#error SCNiPTR not defined
 ^
cinttypes.pass.cpp:722:2: error: #error SCNo8 not defined
#error SCNo8 not defined
 ^
cinttypes.pass.cpp:726:2: error: #error SCNo16 not defined
#error SCNo16 not defined
 ^
cinttypes.pass.cpp:730:2: error: #error SCNo32 not defined
#error SCNo32 not defined
 ^
cinttypes.pass.cpp:734:2: error: #error SCNo64 not defined
#error SCNo64 not defined
 ^
cinttypes.pass.cpp:738:2: error: #error SCNoLEAST8 not defined
#error SCNoLEAST8 not defined
 ^
cinttypes.pass.cpp:742:2: error: #error SCNoLEAST16 not defined
#error SCNoLEAST16 not defined
 ^
cinttypes.pass.cpp:746:2: error: #error SCNoLEAST32 not defined
#error SCNoLEAST32 not defined
 ^
cinttypes.pass.cpp:750:2: error: #error SCNoLEAST64 not defined
#error SCNoLEAST64 not defined
 ^
cinttypes.pass.cpp:754:2: error: #error SCNoFAST8 not defined
#error SCNoFAST8 not defined
 ^
cinttypes.pass.cpp:758:2: error: #error SCNoFAST16 not defined
#error SCNoFAST16 not defined
 ^
cinttypes.pass.cpp:762:2: error: #error SCNoFAST32 not defined
#error SCNoFAST32 not defined
 ^
cinttypes.pass.cpp:766:2: error: #error SCNoFAST64 not defined
#error SCNoFAST64 not defined
 ^
cinttypes.pass.cpp:770:2: error: #error SCNoMAX not defined
#error SCNoMAX not defined
 ^
cinttypes.pass.cpp:774:2: error: #error SCNoPTR not defined
#error SCNoPTR not defined
 ^
cinttypes.pass.cpp:778:2: error: #error SCNu8 not defined
#error SCNu8 not defined
 ^
cinttypes.pass.cpp:782:2: error: #error SCNu16 not defined
#error SCNu16 not defined
 ^
cinttypes.pass.cpp:786:2: error: #error SCNu32 not defined
#error SCNu32 not defined
 ^
cinttypes.pass.cpp:790:2: error: #error SCNu64 not defined
#error SCNu64 not defined
 ^
cinttypes.pass.cpp:794:2: error: #error SCNuLEAST8 not defined
#error SCNuLEAST8 not defined
 ^
cinttypes.pass.cpp:798:2: error: #error SCNuLEAST16 not defined
#error SCNuLEAST16 not defined
 ^
cinttypes.pass.cpp:802:2: error: #error SCNuLEAST32 not defined
#error SCNuLEAST32 not defined
 ^
cinttypes.pass.cpp:806:2: error: #error SCNuLEAST64 not defined
#error SCNuLEAST64 not defined
 ^
cinttypes.pass.cpp:810:2: error: #error SCNuFAST8 not defined
#error SCNuFAST8 not defined
 ^
cinttypes.pass.cpp:814:2: error: #error SCNuFAST16 not defined
#error SCNuFAST16 not defined
 ^
cinttypes.pass.cpp:818:2: error: #error SCNuFAST32 not defined
#error SCNuFAST32 not defined
 ^
cinttypes.pass.cpp:822:2: error: #error SCNuFAST64 not defined
#error SCNuFAST64 not defined
 ^
cinttypes.pass.cpp:826:2: error: #error SCNuMAX not defined
#error SCNuMAX not defined
 ^
cinttypes.pass.cpp:830:2: error: #error SCNuPTR not defined
#error SCNuPTR not defined
 ^
cinttypes.pass.cpp:834:2: error: #error SCNx8 not defined
#error SCNx8 not defined
 ^
cinttypes.pass.cpp:838:2: error: #error SCNx16 not defined
#error SCNx16 not defined
 ^
cinttypes.pass.cpp:842:2: error: #error SCNx32 not defined
#error SCNx32 not defined
 ^
cinttypes.pass.cpp:846:2: error: #error SCNx64 not defined
#error SCNx64 not defined
 ^
cinttypes.pass.cpp:850:2: error: #error SCNxLEAST8 not defined
#error SCNxLEAST8 not defined
 ^
cinttypes.pass.cpp:854:2: error: #error SCNxLEAST16 not defined
#error SCNxLEAST16 not defined
 ^
cinttypes.pass.cpp:858:2: error: #error SCNxLEAST32 not defined
#error SCNxLEAST32 not defined
 ^
cinttypes.pass.cpp:862:2: error: #error SCNxLEAST64 not defined
#error SCNxLEAST64 not defined
 ^
cinttypes.pass.cpp:866:2: error: #error SCNxFAST8 not defined
#error SCNxFAST8 not defined
 ^
cinttypes.pass.cpp:870:2: error: #error SCNxFAST16 not defined
#error SCNxFAST16 not defined
 ^
cinttypes.pass.cpp:874:2: error: #error SCNxFAST32 not defined
#error SCNxFAST32 not defined
 ^
cinttypes.pass.cpp:878:2: error: #error SCNxFAST64 not defined
#error SCNxFAST64 not defined
 ^
cinttypes.pass.cpp:882:2: error: #error SCNxMAX not defined
#error SCNxMAX not defined
 ^
cinttypes.pass.cpp:886:2: error: #error SCNxPTR not defined
#error SCNxPTR not defined
 ^
154 diagnostics generated.
cinttypes.pass.cpp failed to compile
cstdio.pass.cpp:111:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:111:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:111:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:112:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:112:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:112:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::fprintf(fp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:114:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:114:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:114:54: note: instantiated from:
    static_assert((std::is_same<decltype(std::printf("")), int>::value), "");
                                                     ^~
cstdio.pass.cpp:116:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:116:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:116:61: note: instantiated from:
    static_assert((std::is_same<decltype(std::snprintf(cp,0,"")), int>::value), "");
                                                            ^~
cstdio.pass.cpp:117:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:117:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:117:58: note: instantiated from:
    static_assert((std::is_same<decltype(std::sprintf(cp,"")), int>::value), "");
                                                         ^~
cstdio.pass.cpp:119:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:119:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:119:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vfprintf(fp,"",va)), int>::value), "");
                                                          ^~
cstdio.pass.cpp:121:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:121:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:121:55: note: instantiated from:
    static_assert((std::is_same<decltype(std::vprintf("",va)), int>::value), "");
                                                      ^~
cstdio.pass.cpp:123:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:123:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:123:62: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsnprintf(cp,0,"",va)), int>::value), "");
                                                             ^~
cstdio.pass.cpp:124:5: warning: format string is empty [-Wformat-zero-length]
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:124:33: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
cstdio.pass.cpp:124:59: note: instantiated from:
    static_assert((std::is_same<decltype(std::vsprintf(cp,"",va)), int>::value), "");
                                                          ^~
9 diagnostics generated.
failed 1 tests in /test/input.output/file.streams/c.files
passed 1 tests in /test/input.output/file.streams/c.files
passed 1 tests in /test/input.output/file.streams/fstreams
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf
./testit: line 96: 33088 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 33102 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/filebuf.assign
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf.assign
./testit: line 96: 33114 Abort trap              ./a.out
default.pass.cpp failed at run time
failed 1 tests in /test/input.output/file.streams/fstreams/filebuf.cons
passed 1 tests in /test/input.output/file.streams/fstreams/filebuf.cons
./testit: line 96: 33133 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
failed 1 tests in /test/input.output/file.streams/fstreams/filebuf.members
./testit: line 96: 33144 Abort trap              ./a.out
overflow.pass.cpp failed at run time
./testit: line 96: 33151 Abort trap              ./a.out
pbackfail.pass.cpp failed at run time
./testit: line 96: 33158 Abort trap              ./a.out
seekoff.pass.cpp failed at run time
./testit: line 96: 33165 Abort trap              ./a.out
underflow.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/filebuf.virtuals
passed 1 tests in /test/input.output/file.streams/fstreams/fstream
./testit: line 96: 33187 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 33201 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/fstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/fstream.assign
./testit: line 96: 33213 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 33227 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 33234 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/fstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/fstream.cons
./testit: line 96: 33246 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 33253 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 33260 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 33267 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/fstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream
./testit: line 96: 33289 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 33303 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/ifstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream.assign
./testit: line 96: 33315 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 33329 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 33336 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/ifstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/ifstream.cons
./testit: line 96: 33348 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 33355 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 33362 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 33369 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/ifstream.members
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream
./testit: line 96: 33391 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 33405 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/file.streams/fstreams/ofstream.assign
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream.assign
./testit: line 96: 33417 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 33431 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 33438 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 3 tests in /test/input.output/file.streams/fstreams/ofstream.cons
passed 1 tests in /test/input.output/file.streams/fstreams/ofstream.cons
./testit: line 96: 33450 Abort trap              ./a.out
close.pass.cpp failed at run time
./testit: line 96: 33457 Abort trap              ./a.out
open_pointer.pass.cpp failed at run time
./testit: line 96: 33464 Abort trap              ./a.out
open_string.pass.cpp failed at run time
./testit: line 96: 33472 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/file.streams/fstreams/ofstream.members
passed 1 tests in /test/input.output/input.output.general
passed 1 tests in /test/input.output/iostream.format
./testit: line 96: 33505 Abort trap              ./a.out
get_money.pass.cpp failed at run time
./testit: line 96: 33512 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 33519 Abort trap              ./a.out
put_money.pass.cpp failed at run time
./testit: line 96: 33526 Abort trap              ./a.out
put_time.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostream.format/ext.manip
passed 1 tests in /test/input.output/iostream.format/input.streams
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass
./testit: line 96: 33559 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
Assertion failed: (Ty && "Invalid GetElementPtrInst indices for type!"), function checkType, file /Users/buildslave/zorg/buildbot/smooshlab/slave/build.clang-x86_64-darwin10-selfhost-rel/llvm.src/include/llvm/Instructions.h, line 276.
0  clang             0x0000000100c4b0d2
1  clang             0x0000000100c4b549
2  libSystem.B.dylib 0x00007fff83ea480a _sigtramp + 26
3  libSystem.B.dylib 0x0000001c00000000 _sigtramp + 2081798160
4  libSystem.B.dylib 0x00007fff83f1fef0 __pthread_markcancel + 0
5  clang             0x00000001005239d6
6  clang             0x0000000100145769
7  clang             0x000000010013994f
8  clang             0x0000000100139e18
9  clang             0x0000000100115989
10 clang             0x0000000100116918
11 clang             0x00000001001aa259
12 clang             0x000000010010cda2
13 clang             0x00000001001af263
14 clang             0x00000001001ad910
15 clang             0x00000001001ad734
16 clang             0x000000010002a2ba
17 clang             0x00000001001cc773
18 clang             0x000000010002df83
19 clang             0x00000001000192b7
20 clang             0x000000010001a12f
21 clang             0x0000000100017dec
Stack dump:
0.	Program arguments: /Users/hinnant/Downloads/clang-r100008-b1071/bin/clang -cc1 -triple x86_64-apple-darwin10.0.0 -S -disable-free -main-file-name nonmember_swap.pass.cpp -pic-level 1 -mdisable-fp-elim -munwind-tables -target-cpu core2 -nostdinc++ -resource-dir /Users/hinnant/Downloads/clang-r100008-b1071/lib/clang/1.5 -I../../../../../../include -fmessage-length 0 -stack-protector 1 -fblocks -fexceptions -fdiagnostics-show-option -o /var/folders/ax/axmvgG0xF8COmLBHN1a-Ok+++TQ/-Tmp-/cc-aIqU2h.s -x c++ nonmember_swap.pass.cpp 
1.	<eof> parser at end of file
2.	Per-file LLVM IR generation
3.	../../../../../../include/istream:1762:23: Generating code for declaration 'std::basic_istream<wchar_t, std::char_traits<wchar_t> >::basic_istream'
clang: error: compiler command failed due to signal 6 (use -v to see invocation)
nonmember_swap.pass.cpp failed to compile
failed 2 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.assign
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.assign
./testit: line 96: 33587 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/iostreamclass/iostream.dest
passed 1 tests in /test/input.output/iostream.format/input.streams/istream
./testit: line 96: 33621 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 33635 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostream.format/input.streams/istream/istream.assign
passed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.assign
./testit: line 96: 33654 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.cons
passed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream.cons
./testit: line 96: 33666 Abort trap              ./a.out
ctor.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream/istream::sentry
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted
./testit: line 96: 33688 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 33695 Abort trap              ./a.out
double.pass.cpp failed at run time
./testit: line 96: 33702 Abort trap              ./a.out
float.pass.cpp failed at run time
./testit: line 96: 33709 Abort trap              ./a.out
int.pass.cpp failed at run time
./testit: line 96: 33716 Abort trap              ./a.out
long.pass.cpp failed at run time
./testit: line 96: 33723 Abort trap              ./a.out
long_double.pass.cpp failed at run time
./testit: line 96: 33730 Abort trap              ./a.out
long_long.pass.cpp failed at run time
./testit: line 96: 33737 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 33744 Abort trap              ./a.out
short.pass.cpp failed at run time
./testit: line 96: 33751 Abort trap              ./a.out
unsigned_int.pass.cpp failed at run time
./testit: line 96: 33758 Abort trap              ./a.out
unsigned_long.pass.cpp failed at run time
./testit: line 96: 33765 Abort trap              ./a.out
unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 33772 Abort trap              ./a.out
unsigned_short.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.arithmetic
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream.formatted.reqmts
./testit: line 96: 33795 Abort trap              ./a.out
basic_ios.pass.cpp failed at run time
./testit: line 96: 33802 Abort trap              ./a.out
chart.pass.cpp failed at run time
./testit: line 96: 33809 Abort trap              ./a.out
ios_base.pass.cpp failed at run time
./testit: line 96: 33816 Abort trap              ./a.out
istream.pass.cpp failed at run time
./testit: line 96: 33823 Abort trap              ./a.out
signed_char.pass.cpp failed at run time
./testit: line 96: 33830 Abort trap              ./a.out
signed_char_pointer.pass.cpp failed at run time
./testit: line 96: 33837 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
./testit: line 96: 33844 Abort trap              ./a.out
unsigned_char.pass.cpp failed at run time
./testit: line 96: 33851 Abort trap              ./a.out
unsigned_char_pointer.pass.cpp failed at run time
./testit: line 96: 33859 Abort trap              ./a.out
wchar_t_pointer.pass.cpp failed at run time
failed 10 tests in /test/input.output/iostream.format/input.streams/istream.formatted/istream::extractors
./testit: line 96: 33870 Abort trap              ./a.out
ws.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/input.streams/istream.manip
passed 1 tests in /test/input.output/iostream.format/input.streams/istream.rvalue
./testit: line 96: 33892 Abort trap              ./a.out
get.pass.cpp failed at run time
./testit: line 96: 33899 Abort trap              ./a.out
get_chart.pass.cpp failed at run time
./testit: line 96: 33906 Abort trap              ./a.out
get_pointer_size.pass.cpp failed at run time
./testit: line 96: 33913 Abort trap              ./a.out
get_pointer_size_chart.pass.cpp failed at run time
./testit: line 96: 33920 Abort trap              ./a.out
get_streambuf.pass.cpp failed at run time
./testit: line 96: 33927 Abort trap              ./a.out
get_streambuf_chart.pass.cpp failed at run time
./testit: line 96: 33934 Abort trap              ./a.out
getline_pointer_size.pass.cpp failed at run time
./testit: line 96: 33941 Abort trap              ./a.out
getline_pointer_size_chart.pass.cpp failed at run time
./testit: line 96: 33948 Abort trap              ./a.out
ignore.pass.cpp failed at run time
./testit: line 96: 33955 Abort trap              ./a.out
peek.pass.cpp failed at run time
./testit: line 96: 33962 Abort trap              ./a.out
putback.pass.cpp failed at run time
./testit: line 96: 33969 Abort trap              ./a.out
read.pass.cpp failed at run time
./testit: line 96: 33976 Abort trap              ./a.out
readsome.pass.cpp failed at run time
./testit: line 96: 33983 Abort trap              ./a.out
seekg.pass.cpp failed at run time
./testit: line 96: 33990 Abort trap              ./a.out
seekg_off.pass.cpp failed at run time
./testit: line 96: 33997 Abort trap              ./a.out
sync.pass.cpp failed at run time
./testit: line 96: 34004 Abort trap              ./a.out
tellg.pass.cpp failed at run time
./testit: line 96: 34011 Abort trap              ./a.out
unget.pass.cpp failed at run time
failed 18 tests in /test/input.output/iostream.format/input.streams/istream.unformatted
passed 1 tests in /test/input.output/iostream.format/output.streams
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream
./testit: line 96: 34044 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 34058 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostream.format/output.streams/ostream.assign
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.assign
./testit: line 96: 34077 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostream.format/output.streams/ostream.cons
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.cons
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.formatted.reqmts
./testit: line 96: 34111 Abort trap              ./a.out
basic_ios.pass.cpp failed at run time
./testit: line 96: 34118 Abort trap              ./a.out
ios_base.pass.cpp failed at run time
./testit: line 96: 34125 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 34132 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters
./testit: line 96: 34143 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 34150 Abort trap              ./a.out
double.pass.cpp failed at run time
./testit: line 96: 34157 Abort trap              ./a.out
float.pass.cpp failed at run time
./testit: line 96: 34164 Abort trap              ./a.out
int.pass.cpp failed at run time
./testit: line 96: 34171 Abort trap              ./a.out
long.pass.cpp failed at run time
./testit: line 96: 34178 Abort trap              ./a.out
long_double.pass.cpp failed at run time
./testit: line 96: 34185 Abort trap              ./a.out
long_long.pass.cpp failed at run time
./testit: line 96: 34192 Abort trap              ./a.out
pointer.pass.cpp failed at run time
./testit: line 96: 34199 Abort trap              ./a.out
short.pass.cpp failed at run time
./testit: line 96: 34206 Abort trap              ./a.out
unsigned_int.pass.cpp failed at run time
./testit: line 96: 34213 Abort trap              ./a.out
unsigned_long.pass.cpp failed at run time
./testit: line 96: 34220 Abort trap              ./a.out
unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 34227 Abort trap              ./a.out
unsigned_short.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.arithmetic
./testit: line 96: 34238 Abort trap              ./a.out
CharT.pass.cpp failed at run time
./testit: line 96: 34245 Abort trap              ./a.out
CharT_pointer.pass.cpp failed at run time
./testit: line 96: 34252 Abort trap              ./a.out
char.pass.cpp failed at run time
./testit: line 96: 34259 Abort trap              ./a.out
char_pointer.pass.cpp failed at run time
./testit: line 96: 34266 Abort trap              ./a.out
char_to_wide.pass.cpp failed at run time
./testit: line 96: 34273 Abort trap              ./a.out
char_to_wide_pointer.pass.cpp failed at run time
./testit: line 96: 34280 Abort trap              ./a.out
signed_char.pass.cpp failed at run time
./testit: line 96: 34287 Abort trap              ./a.out
signed_char_pointer.pass.cpp failed at run time
./testit: line 96: 34294 Abort trap              ./a.out
unsigned_char.pass.cpp failed at run time
./testit: line 96: 34301 Abort trap              ./a.out
unsigned_char_pointer.pass.cpp failed at run time
failed 10 tests in /test/input.output/iostream.format/output.streams/ostream.formatted/ostream.inserters.character
./testit: line 96: 34312 Abort trap              ./a.out
endl.pass.cpp failed at run time
./testit: line 96: 34319 Abort trap              ./a.out
ends.pass.cpp failed at run time
./testit: line 96: 34327 Abort trap              ./a.out
flush.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.manip
passed 1 tests in /test/input.output/iostream.format/output.streams/ostream.rvalue
./testit: line 96: 34349 Abort trap              ./a.out
seekp.pass.cpp failed at run time
./testit: line 96: 34356 Abort trap              ./a.out
seekp2.pass.cpp failed at run time
./testit: line 96: 34365 Abort trap              ./a.out
tellp.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.seeks
./testit: line 96: 34376 Abort trap              ./a.out
flush.pass.cpp failed at run time
./testit: line 96: 34385 Abort trap              ./a.out
put.pass.cpp failed at run time
./testit: line 96: 34392 Abort trap              ./a.out
write.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostream.format/output.streams/ostream.unformatted
./testit: line 96: 34403 Abort trap              ./a.out
construct.pass.cpp failed at run time
./testit: line 96: 34410 Abort trap              ./a.out
destruct.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostream.format/output.streams/ostream::sentry
./testit: line 96: 34421 Abort trap              ./a.out
resetiosflags.pass.cpp failed at run time
./testit: line 96: 34428 Abort trap              ./a.out
setbase.pass.cpp failed at run time
./testit: line 96: 34435 Abort trap              ./a.out
setfill.pass.cpp failed at run time
./testit: line 96: 34443 Abort trap              ./a.out
setiosflags.pass.cpp failed at run time
./testit: line 96: 34450 Abort trap              ./a.out
setprecision.pass.cpp failed at run time
./testit: line 96: 34457 Abort trap              ./a.out
setw.pass.cpp failed at run time
failed 6 tests in /test/input.output/iostream.format/std.manip
passed 1 tests in /test/input.output/iostream.forward
passed 1 tests in /test/input.output/iostream.objects
passed 4 tests in /test/input.output/iostream.objects/narrow.stream.objects
passed 4 tests in /test/input.output/iostream.objects/wide.stream.objects
passed 1 tests in /test/input.output/iostreams.base
passed 1 tests in /test/input.output/iostreams.base/fpos
passed 1 tests in /test/input.output/iostreams.base/fpos/fpos.members
passed 7 tests in /test/input.output/iostreams.base/fpos/fpos.operations
passed 1 tests in /test/input.output/iostreams.base/ios
./testit: line 96: 34651 Abort trap              ./a.out
ctor_streambuf.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios/basic.ios.cons
./testit: line 96: 34662 Abort trap              ./a.out
copyfmt.pass.cpp failed at run time
./testit: line 96: 34669 Abort trap              ./a.out
fill.pass.cpp failed at run time
./testit: line 96: 34676 Abort trap              ./a.out
fill_char_type.pass.cpp failed at run time
./testit: line 96: 34683 Abort trap              ./a.out
imbue.pass.cpp failed at run time
./testit: line 96: 34690 Segmentation fault      ./a.out
move.pass.cpp failed at run time
./testit: line 96: 34697 Abort trap              ./a.out
narow.pass.cpp failed at run time
./testit: line 96: 34704 Abort trap              ./a.out
rdbuf.pass.cpp failed at run time
./testit: line 96: 34711 Abort trap              ./a.out
rdbuf_streambuf.pass.cpp failed at run time
./testit: line 96: 34718 Abort trap              ./a.out
set_rdbuf.pass.cpp failed at run time
./testit: line 96: 34725 Abort trap              ./a.out
swap.pass.cpp failed at run time
./testit: line 96: 34732 Abort trap              ./a.out
tie.pass.cpp failed at run time
./testit: line 96: 34739 Abort trap              ./a.out
tie_ostream.pass.cpp failed at run time
./testit: line 96: 34746 Abort trap              ./a.out
widen.pass.cpp failed at run time
failed 13 tests in /test/input.output/iostreams.base/ios/basic.ios.members
./testit: line 96: 34757 Abort trap              ./a.out
bad.pass.cpp failed at run time
./testit: line 96: 34764 Abort trap              ./a.out
bool.pass.cpp failed at run time
./testit: line 96: 34771 Abort trap              ./a.out
clear.pass.cpp failed at run time
./testit: line 96: 34778 Abort trap              ./a.out
eof.pass.cpp failed at run time
./testit: line 96: 34785 Abort trap              ./a.out
exceptions.pass.cpp failed at run time
./testit: line 96: 34792 Abort trap              ./a.out
exceptions_iostate.pass.cpp failed at run time
./testit: line 96: 34799 Abort trap              ./a.out
fail.pass.cpp failed at run time
./testit: line 96: 34807 Abort trap              ./a.out
good.pass.cpp failed at run time
./testit: line 96: 34814 Abort trap              ./a.out
not.pass.cpp failed at run time
./testit: line 96: 34821 Abort trap              ./a.out
rdstate.pass.cpp failed at run time
./testit: line 96: 34828 Abort trap              ./a.out
setstate.pass.cpp failed at run time
failed 11 tests in /test/input.output/iostreams.base/ios/iostate.flags
passed 1 tests in /test/input.output/iostreams.base/ios.base
./testit: line 96: 34850 Abort trap              ./a.out
flags.pass.cpp failed at run time
./testit: line 96: 34857 Abort trap              ./a.out
flags_fmtflags.pass.cpp failed at run time
./testit: line 96: 34864 Abort trap              ./a.out
precision.pass.cpp failed at run time
./testit: line 96: 34871 Abort trap              ./a.out
precision_streamsize.pass.cpp failed at run time
./testit: line 96: 34878 Abort trap              ./a.out
setf_fmtflags.pass.cpp failed at run time
./testit: line 96: 34885 Abort trap              ./a.out
setf_fmtflags_mask.pass.cpp failed at run time
./testit: line 96: 34892 Abort trap              ./a.out
unsetf_mask.pass.cpp failed at run time
./testit: line 96: 34899 Abort trap              ./a.out
width.pass.cpp failed at run time
./testit: line 96: 34906 Abort trap              ./a.out
width_streamsize.pass.cpp failed at run time
failed 9 tests in /test/input.output/iostreams.base/ios.base/fmtflags.state
./testit: line 96: 34917 Abort trap              ./a.out
register_callback.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.callback
./testit: line 96: 34928 Abort trap              ./a.out
dtor.pass.cpp failed at run time
failed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.cons
./testit: line 96: 34939 Abort trap              ./a.out
getloc.pass.cpp failed at run time
./testit: line 96: 34946 Abort trap              ./a.out
imbue.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostreams.base/ios.base/ios.base.locales
./testit: line 96: 34957 Abort trap              ./a.out
iword.pass.cpp failed at run time
./testit: line 96: 34964 Abort trap              ./a.out
pword.pass.cpp failed at run time
failed 2 tests in /test/input.output/iostreams.base/ios.base/ios.base.storage
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.base.storage
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.members.static
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::Init
passed 2 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::failure
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::fmtflags
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::iostate
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::openmode
passed 1 tests in /test/input.output/iostreams.base/ios.base/ios.types/ios::seekdir
passed 1 tests in /test/input.output/iostreams.base/std.ios.manip
./testit: line 96: 35089 Abort trap              ./a.out
internal.pass.cpp failed at run time
./testit: line 96: 35096 Abort trap              ./a.out
left.pass.cpp failed at run time
./testit: line 96: 35103 Abort trap              ./a.out
right.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostreams.base/std.ios.manip/adjustfield.manip
./testit: line 96: 35114 Abort trap              ./a.out
dec.pass.cpp failed at run time
./testit: line 96: 35121 Abort trap              ./a.out
hex.pass.cpp failed at run time
./testit: line 96: 35128 Abort trap              ./a.out
oct.pass.cpp failed at run time
failed 3 tests in /test/input.output/iostreams.base/std.ios.manip/basefield.manip
passed 3 tests in /test/input.output/iostreams.base/std.ios.manip/error.reporting
./testit: line 96: 35164 Abort trap              ./a.out
defaultfloat.pass.cpp failed at run time
./testit: line 96: 35171 Abort trap              ./a.out
fixed.pass.cpp failed at run time
./testit: line 96: 35178 Abort trap              ./a.out
hexfloat.pass.cpp failed at run time
./testit: line 96: 35185 Abort trap              ./a.out
scientific.pass.cpp failed at run time
failed 4 tests in /test/input.output/iostreams.base/std.ios.manip/floatfield.manip
./testit: line 96: 35196 Abort trap              ./a.out
boolalpha.pass.cpp failed at run time
./testit: line 96: 35203 Abort trap              ./a.out
noboolalpha.pass.cpp failed at run time
./testit: line 96: 35210 Abort trap              ./a.out
noshowbase.pass.cpp failed at run time
./testit: line 96: 35217 Abort trap              ./a.out
noshowpoint.pass.cpp failed at run time
./testit: line 96: 35224 Abort trap              ./a.out
noshowpos.pass.cpp failed at run time
./testit: line 96: 35231 Abort trap              ./a.out
noskipws.pass.cpp failed at run time
./testit: line 96: 35238 Abort trap              ./a.out
nounitbuf.pass.cpp failed at run time
./testit: line 96: 35245 Abort trap              ./a.out
nouppercase.pass.cpp failed at run time
./testit: line 96: 35252 Abort trap              ./a.out
showbase.pass.cpp failed at run time
./testit: line 96: 35259 Abort trap              ./a.out
showpoint.pass.cpp failed at run time
./testit: line 96: 35267 Abort trap              ./a.out
showpos.pass.cpp failed at run time
./testit: line 96: 35274 Abort trap              ./a.out
skipws.pass.cpp failed at run time
./testit: line 96: 35281 Abort trap              ./a.out
unitbuf.pass.cpp failed at run time
./testit: line 96: 35288 Abort trap              ./a.out
uppercase.pass.cpp failed at run time
failed 14 tests in /test/input.output/iostreams.base/std.ios.manip/fmtflags.manip
passed 2 tests in /test/input.output/iostreams.base/stream.types
passed 1 tests in /test/input.output/iostreams.requirements
passed 1 tests in /test/input.output/iostreams.requirements/iostream.limits.imbue
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.limits.pos
passed 1 tests in /test/input.output/iostreams.requirements/iostreams.threadsafety
passed 1 tests in /test/input.output/stream.buffers
passed 1 tests in /test/input.output/stream.buffers/streambuf
default.fail.cpp should not compile
failed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.cons
passed 3 tests in /test/input.output/stream.buffers/streambuf/streambuf.cons
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.buffer
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.locales
passed 5 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.get
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.members/streambuf.pub.put
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.assign
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.get.area
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.protected/streambuf.put.area
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.buffer
passed 4 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.get
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.locales
passed 1 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.pback
passed 2 tests in /test/input.output/stream.buffers/streambuf/streambuf.virtuals/streambuf.virt.put
passed 1 tests in /test/input.output/stream.buffers/streambuf.reqts
passed 1 tests in /test/input.output/string.streams
passed 1 tests in /test/input.output/string.streams/istringstream
./testit: line 96: 35735 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 35749 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/istringstream/istringstream.assign
passed 1 tests in /test/input.output/string.streams/istringstream/istringstream.assign
./testit: line 96: 35761 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 35775 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/istringstream/istringstream.cons
passed 1 tests in /test/input.output/string.streams/istringstream/istringstream.cons
./testit: line 96: 35787 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/istringstream/istringstream.members
passed 1 tests in /test/input.output/string.streams/ostringstream
./testit: line 96: 35809 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 35823 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/ostringstream/ostringstream.assign
passed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.assign
./testit: line 96: 35835 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 35849 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/ostringstream/ostringstream.cons
passed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.cons
./testit: line 96: 35862 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/ostringstream/ostringstream.members
passed 1 tests in /test/input.output/string.streams/stringbuf
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.assign
passed 3 tests in /test/input.output/string.streams/stringbuf/stringbuf.cons
passed 1 tests in /test/input.output/string.streams/stringbuf/stringbuf.members
passed 6 tests in /test/input.output/string.streams/stringbuf/stringbuf.virtuals
passed 1 tests in /test/input.output/string.streams/stringstream
./testit: line 96: 36002 Abort trap              ./a.out
default.pass.cpp failed at run time
./testit: line 96: 36016 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/stringstream.cons
passed 1 tests in /test/input.output/string.streams/stringstream.cons
./testit: line 96: 36028 Abort trap              ./a.out
member_swap.pass.cpp failed at run time
./testit: line 96: 36042 Abort trap              ./a.out
nonmember_swap.pass.cpp failed at run time
failed 2 tests in /test/input.output/string.streams/stringstream.cons/stringstream.assign
passed 1 tests in /test/input.output/string.streams/stringstream.cons/stringstream.assign
./testit: line 96: 36054 Abort trap              ./a.out
str.pass.cpp failed at run time
failed 1 tests in /test/input.output/string.streams/stringstream.members
passed 1 tests in /test/iterators
passed 1 tests in /test/iterators/iterator.primitives
passed 1 tests in /test/iterators/iterator.primitives/iterator.basic
passed 4 tests in /test/iterators/iterator.primitives/iterator.operations
passed 4 tests in /test/iterators/iterator.primitives/iterator.traits
passed 5 tests in /test/iterators/iterator.primitives/std.iterator.tags
passed 1 tests in /test/iterators/iterator.requirements
passed 1 tests in /test/iterators/iterator.requirements/bidirectional.iterators
passed 1 tests in /test/iterators/iterator.requirements/forward.iterators
passed 1 tests in /test/iterators/iterator.requirements/input.iterators
passed 1 tests in /test/iterators/iterator.requirements/output.iterators
passed 1 tests in /test/iterators/iterator.requirements/random.access.iterators
passed 1 tests in /test/iterators/iterator.synopsis
passed 1 tests in /test/iterators/iterators.general
passed 1 tests in /test/iterators/predef.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iter.ops/back.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/back.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iter.ops/front.inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/front.insert.iterator
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.cons
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op++
passed 2 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op=
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/insert.iter.op_astrk
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iter.ops/inserter
passed 1 tests in /test/iterators/predef.iterators/insert.iterators/insert.iterator
passed 1 tests in /test/iterators/predef.iterators/move.iterators
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops
passed 3 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.nonmember
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.+=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.-=
passed 6 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.comp
passed 5 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.const
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.conv
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.decr
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.incr
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.index
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.ref
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/move.iterators/move.iter.ops/move.iter.op=
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iter.requirements
passed 1 tests in /test/iterators/predef.iterators/move.iterators/move.iterator
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops
passed 5 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.cons
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.conv
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op!=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op++
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op+=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op--
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op-=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op.star
passed 2 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.op==
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opdiff
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opgt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opindex
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.oplt=
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opref
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.ops/reverse.iter.opsum
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iter.requirements
passed 1 tests in /test/iterators/predef.iterators/reverse.iterators/reverse.iterator
passed 1 tests in /test/iterators/stream.iterators
passed 1 tests in /test/iterators/stream.iterators/istream.iterator
./testit: line 96: 37196 Abort trap              ./a.out
copy.pass.cpp failed at run time
./testit: line 96: 37210 Abort trap              ./a.out
istream.pass.cpp failed at run time
failed 2 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.cons
passed 1 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.cons
./testit: line 96: 37222 Abort trap              ./a.out
arrow.pass.cpp failed at run time
./testit: line 96: 37229 Abort trap              ./a.out
dereference.pass.cpp failed at run time
./testit: line 96: 37236 Abort trap              ./a.out
equal.pass.cpp failed at run time
./testit: line 96: 37243 Abort trap              ./a.out
post_increment.pass.cpp failed at run time
./testit: line 96: 37251 Abort trap              ./a.out
pre_increment.pass.cpp failed at run time
failed 5 tests in /test/iterators/stream.iterators/istream.iterator/istream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator
./testit: line 96: 37280 Abort trap              ./a.out
istream.pass.cpp failed at run time
./testit: line 96: 37287 Abort trap              ./a.out
proxy.pass.cpp failed at run time
./testit: line 96: 37295 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator.cons
passed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator.cons
./testit: line 96: 37307 Abort trap              ./a.out
equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::equal
./testit: line 96: 37318 Abort trap              ./a.out
not_equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op!=
./testit: line 96: 37329 Abort trap              ./a.out
dereference.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op++
./testit: line 96: 37340 Abort trap              ./a.out
equal.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op==
./testit: line 96: 37351 Abort trap              ./a.out
arrow.pass.cpp failed at run time
./testit: line 96: 37358 Abort trap              ./a.out
post_increment.pass.cpp failed at run time
./testit: line 96: 37365 Abort trap              ./a.out
pre_increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::op_astrk
./testit: line 96: 37376 Abort trap              ./a.out
proxy.pass.cpp failed at run time
failed 1 tests in /test/iterators/stream.iterators/istreambuf.iterator/istreambuf.iterator::proxy
passed 6 tests in /test/iterators/stream.iterators/iterator.range
passed 1 tests in /test/iterators/stream.iterators/ostream.iterator
./testit: line 96: 37444 Abort trap              ./a.out
copy.pass.cpp failed at run time
./testit: line 96: 37451 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 37458 Abort trap              ./a.out
ostream_delem.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.cons.des
./testit: line 96: 37469 Abort trap              ./a.out
assign_t.pass.cpp failed at run time
./testit: line 96: 37476 Abort trap              ./a.out
dereference.pass.cpp failed at run time
./testit: line 96: 37483 Abort trap              ./a.out
increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostream.iterator/ostream.iterator.ops
passed 1 tests in /test/iterators/stream.iterators/ostreambuf.iterator
./testit: line 96: 37505 Abort trap              ./a.out
ostream.pass.cpp failed at run time
./testit: line 96: 37512 Abort trap              ./a.out
streambuf.pass.cpp failed at run time
failed 2 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.cons
./testit: line 96: 37523 Abort trap              ./a.out
assign_c.pass.cpp failed at run time
./testit: line 96: 37530 Abort trap              ./a.out
deref.pass.cpp failed at run time
./testit: line 96: 37544 Abort trap              ./a.out
increment.pass.cpp failed at run time
failed 3 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.ops
passed 1 tests in /test/iterators/stream.iterators/ostreambuf.iterator/ostreambuf.iter.ops
passed 1 tests in /test/language.support
passed 1 tests in /test/language.support/cstdint
passed 1 tests in /test/language.support/cstdint/cstdint.syn
passed 1 tests in /test/language.support/cstdint/stdinth
passed 1 tests in /test/language.support/support.dynamic
passed 1 tests in /test/language.support/support.dynamic/alloc.errors
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/bad.alloc
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.badlength
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/new.handler
passed 1 tests in /test/language.support/support.dynamic/alloc.errors/set.new.handler
passed 1 tests in /test/language.support/support.dynamic/new.delete
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.array
passed 1 tests in /test/language.support/support.dynamic/new.delete/new.delete.dataraces
passed 2 tests in /test/language.support/support.dynamic/new.delete/new.delete.placement
passed 4 tests in /test/language.support/support.dynamic/new.delete/new.delete.single
passed 1 tests in /test/language.support/support.exception
not implemented:  /test/language.support/support.exception/except.nested
passed 1 tests in /test/language.support/support.exception/exception
passed 1 tests in /test/language.support/support.exception/exception.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/set.terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate
passed 1 tests in /test/language.support/support.exception/exception.terminate/terminate.handler
passed 1 tests in /test/language.support/support.exception/exception.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/bad.exception
passed 1 tests in /test/language.support/support.exception/exception.unexpected/set.unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected
passed 1 tests in /test/language.support/support.exception/exception.unexpected/unexpected.handler
Assertion failed: (A::constructed == 0), function main, file current_exception.pass.cpp, line 59.
./testit: line 96: 37894 Abort trap              ./a.out
current_exception.pass.cpp failed at run time
Assertion failed: (A::constructed == 0), function main, file make_exception_ptr.pass.cpp, line 61.
./testit: line 96: 37908 Abort trap              ./a.out
make_exception_ptr.pass.cpp failed at run time
Assertion failed: (A::constructed == 0), function main, file rethrow_exception.pass.cpp, line 69.
./testit: line 96: 37915 Abort trap              ./a.out
rethrow_exception.pass.cpp failed at run time
failed 3 tests in /test/language.support/support.exception/propagation
passed 1 tests in /test/language.support/support.exception/propagation
passed 1 tests in /test/language.support/support.exception/uncaught
not implemented:  /test/language.support/support.general
passed 1 tests in /test/language.support/support.initlist
passed 1 tests in /test/language.support/support.initlist/support.initlist.access
passed 1 tests in /test/language.support/support.initlist/support.initlist.cons
not implemented:  /test/language.support/support.initlist/support.initlist.range
passed 1 tests in /test/language.support/support.limits
passed 2 tests in /test/language.support/support.limits/c.limits
passed 1 tests in /test/language.support/support.limits/limits
passed 1 tests in /test/language.support/support.limits/limits/denorm.style
passed 1 tests in /test/language.support/support.limits/limits/numeric.limits
passed 31 tests in /test/language.support/support.limits/limits/numeric.limits.members
passed 1 tests in /test/language.support/support.limits/limits/numeric.special
passed 1 tests in /test/language.support/support.limits/limits/round.style
passed 1 tests in /test/language.support/support.rtti
passed 1 tests in /test/language.support/support.rtti/bad.cast
passed 1 tests in /test/language.support/support.rtti/bad.typeid
passed 2 tests in /test/language.support/support.rtti/type.info
passed 6 tests in /test/language.support/support.runtime
quick_exit.pass.cpp:33:10: error: no member named 'at_quick_exit' in namespace 'std'
    std::at_quick_exit(f);
    ~~~~~^
quick_exit.pass.cpp:34:5: error: use of undeclared identifier 'quick_exit'
    quick_exit(0);
    ^
2 diagnostics generated.
quick_exit.pass.cpp failed to compile
failed 1 tests in /test/language.support/support.start.term
passed 6 tests in /test/language.support/support.types
passed 1 tests in /test/localization
passed 1 tests in /test/localization/c.locales
./testit: line 96: 38454 Abort trap              ./a.out
__scan_keyword.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories
passed 1 tests in /test/localization/locale.categories/category.collate
Assertion failed: (std::has_facet<std::collate<char> >(l)), function main, file types.pass.cpp, line 44.
./testit: line 96: 38483 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.collate/locale.collate
passed 1 tests in /test/localization/locale.categories/category.collate/locale.collate
./testit: line 96: 38495 Abort trap              ./a.out
compare.pass.cpp failed at run time
./testit: line 96: 38502 Abort trap              ./a.out
hash.pass.cpp failed at run time
./testit: line 96: 38509 Abort trap              ./a.out
transform.pass.cpp failed at run time
failed 3 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.members
passed 1 tests in /test/localization/locale.categories/category.collate/locale.collate/locale.collate.virtuals
passed 4 tests in /test/localization/locale.categories/category.collate/locale.collate.byname
passed 1 tests in /test/localization/locale.categories/category.ctype
Assertion failed: (std::has_facet<std::ctype<char> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 38574 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.dtor
./testit: line 96: 38604 Abort trap              ./a.out
is_1.pass.cpp failed at run time
./testit: line 96: 38611 Abort trap              ./a.out
is_many.pass.cpp failed at run time
./testit: line 96: 38618 Abort trap              ./a.out
narrow_1.pass.cpp failed at run time
./testit: line 96: 38625 Abort trap              ./a.out
narrow_many.pass.cpp failed at run time
./testit: line 96: 38632 Abort trap              ./a.out
scan_is.pass.cpp failed at run time
./testit: line 96: 38639 Abort trap              ./a.out
scan_not.pass.cpp failed at run time
./testit: line 96: 38653 Abort trap              ./a.out
tolower_1.pass.cpp failed at run time
./testit: line 96: 38660 Abort trap              ./a.out
tolower_many.pass.cpp failed at run time
./testit: line 96: 38667 Abort trap              ./a.out
toupper_1.pass.cpp failed at run time
./testit: line 96: 38674 Abort trap              ./a.out
toupper_many.pass.cpp failed at run time
./testit: line 96: 38681 Abort trap              ./a.out
widen_1.pass.cpp failed at run time
./testit: line 96: 38688 Abort trap              ./a.out
widen_many.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.members
passed 2 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.members
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.statics
passed 1 tests in /test/localization/locale.categories/category.ctype/facet.ctype.special/facet.ctype.char.virtuals
Assertion failed: (std::has_facet<F>(l)), function main, file types_char.pass.cpp, line 51.
./testit: line 96: 38757 Abort trap              ./a.out
types_char.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_char16_t.pass.cpp, line 52.
./testit: line 96: 38764 Abort trap              ./a.out
types_char16_t.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_char32_t.pass.cpp, line 52.
./testit: line 96: 38771 Abort trap              ./a.out
types_char32_t.pass.cpp failed at run time
Assertion failed: (std::has_facet<F>(l)), function main, file types_wchar_t.pass.cpp, line 51.
./testit: line 96: 38778 Abort trap              ./a.out
types_wchar_t.pass.cpp failed at run time
failed 4 tests in /test/localization/locale.categories/category.ctype/locale.codecvt
passed 5 tests in /test/localization/locale.categories/category.ctype/locale.codecvt
./testit: line 96: 38790 Abort trap              ./a.out
char16_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 38797 Abort trap              ./a.out
char16_t_encoding.pass.cpp failed at run time
./testit: line 96: 38804 Abort trap              ./a.out
char16_t_in.pass.cpp failed at run time
./testit: line 96: 38811 Abort trap              ./a.out
char16_t_length.pass.cpp failed at run time
./testit: line 96: 38819 Abort trap              ./a.out
char16_t_max_length.pass.cpp failed at run time
./testit: line 96: 38826 Abort trap              ./a.out
char16_t_out.pass.cpp failed at run time
./testit: line 96: 38833 Abort trap              ./a.out
char16_t_unshift.pass.cpp failed at run time
./testit: line 96: 38840 Abort trap              ./a.out
char32_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 38847 Abort trap              ./a.out
char32_t_encoding.pass.cpp failed at run time
./testit: line 96: 38854 Abort trap              ./a.out
char32_t_in.pass.cpp failed at run time
./testit: line 96: 38861 Abort trap              ./a.out
char32_t_length.pass.cpp failed at run time
./testit: line 96: 38868 Abort trap              ./a.out
char32_t_max_length.pass.cpp failed at run time
./testit: line 96: 38875 Abort trap              ./a.out
char32_t_out.pass.cpp failed at run time
./testit: line 96: 38882 Abort trap              ./a.out
char32_t_unshift.pass.cpp failed at run time
./testit: line 96: 38889 Abort trap              ./a.out
char_always_noconv.pass.cpp failed at run time
./testit: line 96: 38896 Abort trap              ./a.out
char_encoding.pass.cpp failed at run time
./testit: line 96: 38903 Abort trap              ./a.out
char_in.pass.cpp failed at run time
./testit: line 96: 38910 Abort trap              ./a.out
char_length.pass.cpp failed at run time
./testit: line 96: 38917 Abort trap              ./a.out
char_max_length.pass.cpp failed at run time
./testit: line 96: 38924 Abort trap              ./a.out
char_out.pass.cpp failed at run time
./testit: line 96: 38931 Abort trap              ./a.out
char_unshift.pass.cpp failed at run time
./testit: line 96: 38938 Abort trap              ./a.out
utf_sanity_check.pass.cpp failed at run time
./testit: line 96: 38945 Abort trap              ./a.out
wchar_t_always_noconv.pass.cpp failed at run time
./testit: line 96: 38952 Abort trap              ./a.out
wchar_t_encoding.pass.cpp failed at run time
./testit: line 96: 38959 Abort trap              ./a.out
wchar_t_in.pass.cpp failed at run time
./testit: line 96: 38966 Abort trap              ./a.out
wchar_t_length.pass.cpp failed at run time
./testit: line 96: 38973 Abort trap              ./a.out
wchar_t_max_length.pass.cpp failed at run time
./testit: line 96: 38980 Abort trap              ./a.out
wchar_t_out.pass.cpp failed at run time
./testit: line 96: 38987 Abort trap              ./a.out
wchar_t_unshift.pass.cpp failed at run time
failed 29 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.codecvt/locale.codecvt.virtuals
passed 4 tests in /test/localization/locale.categories/category.ctype/locale.codecvt.byname
Assertion failed: (std::has_facet<std::ctype<wchar_t> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 39048 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype
./testit: line 96: 39060 Abort trap              ./a.out
is_1.pass.cpp failed at run time
./testit: line 96: 39067 Abort trap              ./a.out
is_many.pass.cpp failed at run time
./testit: line 96: 39074 Abort trap              ./a.out
narrow_1.pass.cpp failed at run time
./testit: line 96: 39081 Abort trap              ./a.out
narrow_many.pass.cpp failed at run time
./testit: line 96: 39088 Abort trap              ./a.out
scan_is.pass.cpp failed at run time
./testit: line 96: 39095 Abort trap              ./a.out
scan_not.pass.cpp failed at run time
./testit: line 96: 39102 Abort trap              ./a.out
tolower_1.pass.cpp failed at run time
./testit: line 96: 39109 Abort trap              ./a.out
tolower_many.pass.cpp failed at run time
./testit: line 96: 39116 Abort trap              ./a.out
toupper_1.pass.cpp failed at run time
./testit: line 96: 39123 Abort trap              ./a.out
toupper_many.pass.cpp failed at run time
./testit: line 96: 39130 Abort trap              ./a.out
widen_1.pass.cpp failed at run time
./testit: line 96: 39137 Abort trap              ./a.out
widen_many.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.members
passed 1 tests in /test/localization/locale.categories/category.ctype/locale.ctype/locale.ctype.virtuals
passed 13 tests in /test/localization/locale.categories/category.ctype/locale.ctype.byname
passed 1 tests in /test/localization/locale.categories/category.messages
passed 3 tests in /test/localization/locale.categories/category.messages/locale.messages
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.members
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages/locale.messages.virtuals
passed 1 tests in /test/localization/locale.categories/category.messages/locale.messages.byname
passed 1 tests in /test/localization/locale.categories/category.monetary
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.get
./testit: line 96: 39352 Abort trap              ./a.out
get_long_double_en_US.pass.cpp failed at run time
./testit: line 96: 39359 Abort trap              ./a.out
get_long_double_fr_FR.pass.cpp failed at run time
./testit: line 96: 39366 Abort trap              ./a.out
get_long_double_ru_RU.pass.cpp failed at run time
./testit: line 96: 39373 Abort trap              ./a.out
get_long_double_zh_CN.pass.cpp failed at run time
./testit: line 96: 39380 Abort trap              ./a.out
get_string_en_US.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.get/locale.money.get.virtuals
passed 2 tests in /test/localization/locale.categories/category.monetary/locale.money.put
./testit: line 96: 39420 Abort trap              ./a.out
put_long_double_en_US.pass.cpp failed at run time
./testit: line 96: 39427 Abort trap              ./a.out
put_long_double_fr_FR.pass.cpp failed at run time
./testit: line 96: 39434 Abort trap              ./a.out
put_long_double_ru_RU.pass.cpp failed at run time
./testit: line 96: 39441 Abort trap              ./a.out
put_long_double_zh_CN.pass.cpp failed at run time
./testit: line 96: 39448 Abort trap              ./a.out
put_string_en_US.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.money.put/locale.money.put.virtuals
passed 3 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.members
passed 1 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct/locale.moneypunct.virtuals
passed 9 tests in /test/localization/locale.categories/category.monetary/locale.moneypunct.byname
passed 1 tests in /test/localization/locale.categories/category.numeric
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.nm.put
./testit: line 96: 39670 Abort trap              ./a.out
put_bool.pass.cpp failed at run time
./testit: line 96: 39679 Abort trap              ./a.out
put_double.pass.cpp failed at run time
./testit: line 96: 39686 Abort trap              ./a.out
put_long.pass.cpp failed at run time
./testit: line 96: 39693 Abort trap              ./a.out
put_long_double.pass.cpp failed at run time
./testit: line 96: 39700 Abort trap              ./a.out
put_long_long.pass.cpp failed at run time
./testit: line 96: 39707 Abort trap              ./a.out
put_pointer.pass.cpp failed at run time
./testit: line 96: 39714 Abort trap              ./a.out
put_unsigned_long.pass.cpp failed at run time
./testit: line 96: 39721 Abort trap              ./a.out
put_unsigned_long_long.pass.cpp failed at run time
failed 8 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.nm.put/facet.num.put.virtuals
passed 2 tests in /test/localization/locale.categories/category.numeric/locale.num.get
./testit: line 96: 39761 Abort trap              ./a.out
get_bool.pass.cpp failed at run time
get_double.pass.cpp:122:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_double.pass.cpp:122:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 diagnostic generated.
./testit: line 96: 39768 Abort trap              ./a.out
get_double.pass.cpp failed at run time
get_float.pass.cpp:110:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_float.pass.cpp:110:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 diagnostic generated.
./testit: line 96: 39775 Abort trap              ./a.out
get_float.pass.cpp failed at run time
./testit: line 96: 39782 Abort trap              ./a.out
get_long.pass.cpp failed at run time
get_long_double.pass.cpp:110:9: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
        assert(v == 0x125p-1);
        ^
get_long_double.pass.cpp:110:21: note: instantiated from:
        assert(v == 0x125p-1);
                    ^
1 diagnostic generated.
./testit: line 96: 39789 Abort trap              ./a.out
get_long_double.pass.cpp failed at run time
./testit: line 96: 39796 Abort trap              ./a.out
get_long_long.pass.cpp failed at run time
./testit: line 96: 39803 Abort trap              ./a.out
get_pointer.pass.cpp failed at run time
./testit: line 96: 39810 Abort trap              ./a.out
get_unsigned_int.pass.cpp failed at run time
./testit: line 96: 39817 Abort trap              ./a.out
get_unsigned_long.pass.cpp failed at run time
./testit: line 96: 39824 Abort trap              ./a.out
get_unsigned_long_long.pass.cpp failed at run time
./testit: line 96: 39831 Abort trap              ./a.out
get_unsigned_short.pass.cpp failed at run time
failed 11 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.members
passed 1 tests in /test/localization/locale.categories/category.numeric/locale.num.get/facet.num.get.virtuals
passed 1 tests in /test/localization/locale.categories/category.time
passed 3 tests in /test/localization/locale.categories/category.time/locale.time.get
./testit: line 96: 39896 Abort trap              ./a.out
get_date.pass.cpp failed at run time
./testit: line 96: 39903 Abort trap              ./a.out
get_date_wide.pass.cpp failed at run time
./testit: line 96: 39910 Abort trap              ./a.out
get_many.pass.cpp failed at run time
./testit: line 96: 39917 Abort trap              ./a.out
get_monthname.pass.cpp failed at run time
./testit: line 96: 39924 Abort trap              ./a.out
get_monthname_wide.pass.cpp failed at run time
./testit: line 96: 39931 Abort trap              ./a.out
get_one.pass.cpp failed at run time
./testit: line 96: 39938 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 39945 Abort trap              ./a.out
get_time_wide.pass.cpp failed at run time
./testit: line 96: 39952 Abort trap              ./a.out
get_weekday.pass.cpp failed at run time
./testit: line 96: 39959 Abort trap              ./a.out
get_weekday_wide.pass.cpp failed at run time
./testit: line 96: 39966 Abort trap              ./a.out
get_year.pass.cpp failed at run time
failed 11 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.get/locale.time.get.virtuals
./testit: line 96: 40003 Abort trap              ./a.out
get_date.pass.cpp failed at run time
./testit: line 96: 40010 Abort trap              ./a.out
get_date_wide.pass.cpp failed at run time
./testit: line 96: 40017 Abort trap              ./a.out
get_monthname.pass.cpp failed at run time
./testit: line 96: 40024 Abort trap              ./a.out
get_monthname_wide.pass.cpp failed at run time
./testit: line 96: 40031 Abort trap              ./a.out
get_one.pass.cpp failed at run time
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
                          "\x434\x435\x43A\x430\x431\x440\x44F"
                          ^
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:112:27: warning: hex escape sequence out of range [-pedantic]
get_one_wide.pass.cpp:114:27: warning: hex escape sequence out of range [-pedantic]
                          "\x433"
                          ^
get_one_wide.pass.cpp:160:35: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                  ^
get_one_wide.pass.cpp:160:47: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                              ^
get_one_wide.pass.cpp:160:59: warning: hex escape sequence out of range [-pedantic]
        const wchar_t in[] = L"23""\x65F6""55""\x5206""59""\x79D2";
                                                          ^
11 diagnostics generated.
./testit: line 96: 40038 Abort trap              ./a.out
get_one_wide.pass.cpp failed at run time
./testit: line 96: 40045 Abort trap              ./a.out
get_time.pass.cpp failed at run time
./testit: line 96: 40052 Abort trap              ./a.out
get_time_wide.pass.cpp failed at run time
./testit: line 96: 40059 Abort trap              ./a.out
get_weekday.pass.cpp failed at run time
./testit: line 96: 40066 Abort trap              ./a.out
get_weekday_wide.pass.cpp failed at run time
./testit: line 96: 40073 Abort trap              ./a.out
get_year.pass.cpp failed at run time
./testit: line 96: 40080 Abort trap              ./a.out
get_year_wide.pass.cpp failed at run time
failed 12 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.get.byname
passed 2 tests in /test/localization/locale.categories/category.time/locale.time.put
./testit: line 96: 40110 Abort trap              ./a.out
put1.pass.cpp failed at run time
./testit: line 96: 40117 Abort trap              ./a.out
put2.pass.cpp failed at run time
failed 2 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.members
passed 1 tests in /test/localization/locale.categories/category.time/locale.time.put/locale.time.put.virtuals
./testit: line 96: 40139 Abort trap              ./a.out
put1.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/category.time/locale.time.put.byname
passed 1 tests in /test/localization/locale.categories/facet.numpunct
Assertion failed: (std::has_facet<std::numpunct<char> >(l)), function main, file types.pass.cpp, line 43.
./testit: line 96: 40168 Abort trap              ./a.out
types.pass.cpp failed at run time
failed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct
passed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct
./testit: line 96: 40180 Abort trap              ./a.out
decimal_point.pass.cpp failed at run time
./testit: line 96: 40187 Abort trap              ./a.out
falsename.pass.cpp failed at run time
./testit: line 96: 40194 Abort trap              ./a.out
grouping.pass.cpp failed at run time
./testit: line 96: 40201 Abort trap              ./a.out
thousands_sep.pass.cpp failed at run time
./testit: line 96: 40208 Abort trap              ./a.out
truename.pass.cpp failed at run time
failed 5 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.members
passed 1 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct/facet.numpunct.virtuals
passed 3 tests in /test/localization/locale.categories/facet.numpunct/locale.numpunct.byname
passed 1 tests in /test/localization/locale.categories/facets.examples
not implemented:  /test/localization/locale.stdcvt
passed 1 tests in /test/localization/locale.syn
passed 1 tests in /test/localization/locales
passed 1 tests in /test/localization/locales/locale
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file assign.pass.cpp, line 60.
./testit: line 96: 40302 Abort trap              ./a.out
assign.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file char_pointer.pass.cpp, line 60.
./testit: line 96: 40310 Abort trap              ./a.out
char_pointer.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file copy.pass.cpp, line 60.
./testit: line 96: 40317 Abort trap              ./a.out
copy.pass.cpp failed at run time
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file default.pass.cpp, line 48.
./testit: line 96: 40324 Abort trap              ./a.out
default.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_char_pointer_cat.pass.cpp, line 60.
./testit: line 96: 40331 Abort trap              ./a.out
locale_char_pointer_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_facetptr.pass.cpp, line 60.
./testit: line 96: 40338 Abort trap              ./a.out
locale_facetptr.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_locale_cat.pass.cpp, line 60.
./testit: line 96: 40345 Abort trap              ./a.out
locale_locale_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file locale_string_cat.pass.cpp, line 60.
./testit: line 96: 40352 Abort trap              ./a.out
locale_string_cat.pass.cpp failed at run time
Assertion failed: ((std::has_facet<std::money_get<char> >(loc))), function check, file string.pass.cpp, line 60.
./testit: line 96: 40359 Abort trap              ./a.out
string.pass.cpp failed at run time
failed 9 tests in /test/localization/locales/locale/locale.cons
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file combine.pass.cpp, line 48.
./testit: line 96: 40370 Abort trap              ./a.out
combine.pass.cpp failed at run time
failed 1 tests in /test/localization/locales/locale/locale.members
passed 1 tests in /test/localization/locales/locale/locale.members
./testit: line 96: 40389 Abort trap              ./a.out
compare.pass.cpp failed at run time
./testit: line 96: 40396 Abort trap              ./a.out
eq.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale/locale.operators
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file classic.pass.cpp, line 33.
./testit: line 96: 40407 Abort trap              ./a.out
classic.pass.cpp failed at run time
Assertion failed: (std::has_facet<std::collate<char> >(loc)), function check, file global.pass.cpp, line 33.
./testit: line 96: 40414 Abort trap              ./a.out
global.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale/locale.statics
passed 1 tests in /test/localization/locales/locale/locale.types
passed 1 tests in /test/localization/locales/locale/locale.types/locale.category
passed 1 tests in /test/localization/locales/locale/locale.types/locale.facet
passed 1 tests in /test/localization/locales/locale/locale.types/locale.id
passed 1 tests in /test/localization/locales/locale.convenience
./testit: line 96: 40481 Abort trap              ./a.out
isalnum.pass.cpp failed at run time
./testit: line 96: 40488 Abort trap              ./a.out
isalpha.pass.cpp failed at run time
./testit: line 96: 40495 Abort trap              ./a.out
iscntrl.pass.cpp failed at run time
./testit: line 96: 40502 Abort trap              ./a.out
isdigit.pass.cpp failed at run time
./testit: line 96: 40509 Abort trap              ./a.out
isgraph.pass.cpp failed at run time
./testit: line 96: 40516 Abort trap              ./a.out
islower.pass.cpp failed at run time
./testit: line 96: 40523 Abort trap              ./a.out
isprint.pass.cpp failed at run time
./testit: line 96: 40530 Abort trap              ./a.out
ispunct.pass.cpp failed at run time
./testit: line 96: 40537 Abort trap              ./a.out
isspace.pass.cpp failed at run time
./testit: line 96: 40545 Abort trap              ./a.out
isupper.pass.cpp failed at run time
./testit: line 96: 40552 Abort trap              ./a.out
isxdigit.pass.cpp failed at run time
failed 11 tests in /test/localization/locales/locale.convenience/classification
passed 1 tests in /test/localization/locales/locale.convenience/conversions
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.buffer
./testit: line 96: 40577 Abort trap              ./a.out
tolower.pass.cpp failed at run time
./testit: line 96: 40584 Abort trap              ./a.out
toupper.pass.cpp failed at run time
failed 2 tests in /test/localization/locales/locale.convenience/conversions/conversions.character
not implemented:  /test/localization/locales/locale.convenience/conversions/conversions.string
Assertion failed: (std::has_facet<std::ctype<char> >(loc)), function main, file has_facet.pass.cpp, line 42.
./testit: line 96: 40598 Abort trap              ./a.out
has_facet.pass.cpp failed at run time
failed 1 tests in /test/localization/locales/locale.global.templates
passed 1 tests in /test/localization/locales/locale.global.templates
passed 1 tests in /test/localization/localization.general
passed 1 tests in /test/numerics
cmath.pass.cpp:1106:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(std::nextafter(0,1) == 0x1p-1074);
    ^
cmath.pass.cpp:1106:35: note: instantiated from:
    assert(std::nextafter(0,1) == 0x1p-1074);
                                  ^
cmath.pass.cpp:1124:5: warning: hexadecimal floating constants are a C99 feature that is incompatible with C++0x [-pedantic]
    assert(std::nexttoward(0, 1) == 0x1p-1074);
    ^
cmath.pass.cpp:1124:37: note: instantiated from:
    assert(std::nexttoward(0, 1) == 0x1p-1074);
                                    ^
2 diagnostics generated.
tgmath_h.pass.cpp:26:2: error: #error <tgmath.h> is not implemented
#error <tgmath.h> is not implemented
 ^
1 diagnostic generated.
tgmath_h.pass.cpp failed to compile
failed 1 tests in /test/numerics/c.math
passed 2 tests in /test/numerics/c.math
passed 1 tests in /test/numerics/cfenv
passed 1 tests in /test/numerics/cfenv/cfenv.syn
passed 1 tests in /test/numerics/cfenv/fenv
passed 1 tests in /test/numerics/complex.number
passed 1 tests in /test/numerics/complex.number/ccmplx
passed 7 tests in /test/numerics/complex.number/cmplx.over
passed 1 tests in /test/numerics/complex.number/cmplxh
passed 1 tests in /test/numerics/complex.number/complex
passed 10 tests in /test/numerics/complex.number/complex.member.ops
passed 2 tests in /test/numerics/complex.number/complex.members
stream_input.pass.cpp:30:2: error: #error operator>>(basic_istream<charT, traits>& is, complex<T>& x) not implemented.
#error operator>>(basic_istream<charT, traits>& is, complex<T>& x) not implemented.
 ^
1 diagnostic generated.
stream_input.pass.cpp failed to compile
stream_output.pass.cpp:30:2: error: #error operator<<(basic_ostream<charT, traits>& o, const complex<T>& x) not implemented.
#error operator<<(basic_ostream<charT, traits>& o, const complex<T>& x) not implemented.
 ^
1 diagnostic generated.
stream_output.pass.cpp failed to compile
failed 2 tests in /test/numerics/complex.number/complex.ops
passed 20 tests in /test/numerics/complex.number/complex.ops
passed 12 tests in /test/numerics/complex.number/complex.special
passed 1 tests in /test/numerics/complex.number/complex.synopsis
passed 19 tests in /test/numerics/complex.number/complex.transcendentals
passed 8 tests in /test/numerics/complex.number/complex.value.ops
passed 1 tests in /test/numerics/numarray
passed 1 tests in /test/numerics/numarray/class.gslice
passed 1 tests in /test/numerics/numarray/class.gslice/gslice.access
passed 2 tests in /test/numerics/numarray/class.gslice/gslice.cons
passed 1 tests in /test/numerics/numarray/class.slice
passed 2 tests in /test/numerics/numarray/class.slice/cons.slice
passed 1 tests in /test/numerics/numarray/class.slice/slice.access
passed 2 tests in /test/numerics/numarray/template.gslice.array
passed 2 tests in /test/numerics/numarray/template.gslice.array/gslice.array.assign
passed 10 tests in /test/numerics/numarray/template.gslice.array/gslice.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.gslice.array/gslice.array.fill
passed 2 tests in /test/numerics/numarray/template.indirect.array
passed 2 tests in /test/numerics/numarray/template.indirect.array/indirect.array.assign
passed 10 tests in /test/numerics/numarray/template.indirect.array/indirect.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.indirect.array/indirect.array.fill
passed 2 tests in /test/numerics/numarray/template.mask.array
passed 2 tests in /test/numerics/numarray/template.mask.array/mask.array.assign
passed 10 tests in /test/numerics/numarray/template.mask.array/mask.array.comp.assign
passed 1 tests in /test/numerics/numarray/template.mask.array/mask.array.fill
passed 2 tests in /test/numerics/numarray/template.slice.array
passed 2 tests in /test/numerics/numarray/template.slice.array/slice.arr.assign
passed 10 tests in /test/numerics/numarray/template.slice.array/slice.arr.comp.assign
passed 1 tests in /test/numerics/numarray/template.slice.array/slice.arr.fill
passed 1 tests in /test/numerics/numarray/template.valarray
passed 2 tests in /test/numerics/numarray/template.valarray/valarray.access
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.assign
passed 20 tests in /test/numerics/numarray/template.valarray/valarray.cassign
passed 11 tests in /test/numerics/numarray/template.valarray/valarray.cons
passed 10 tests in /test/numerics/numarray/template.valarray/valarray.members
passed 8 tests in /test/numerics/numarray/template.valarray/valarray.sub
passed 4 tests in /test/numerics/numarray/template.valarray/valarray.unary
passed 1 tests in /test/numerics/numarray/valarray.nonmembers
passed 30 tests in /test/numerics/numarray/valarray.nonmembers/valarray.binary
passed 24 tests in /test/numerics/numarray/valarray.nonmembers/valarray.comparison
passed 1 tests in /test/numerics/numarray/valarray.nonmembers/valarray.special
./testit: line 96: 42768 Abort trap              ./a.out
acos_valarray.pass.cpp failed at run time
./testit: line 96: 42776 Abort trap              ./a.out
asin_valarray.pass.cpp failed at run time
./testit: line 96: 42783 Abort trap              ./a.out
atan2_valarray_valarray.pass.cpp failed at run time
./testit: line 96: 42790 Abort trap              ./a.out
atan2_valarray_value.pass.cpp failed at run time
./testit: line 96: 42797 Abort trap              ./a.out
atan2_value_valarray.pass.cpp failed at run time
./testit: line 96: 42804 Abort trap              ./a.out
atan_valarray.pass.cpp failed at run time
./testit: line 96: 42812 Abort trap              ./a.out
cos_valarray.pass.cpp failed at run time
./testit: line 96: 42819 Abort trap              ./a.out
cosh_valarray.pass.cpp failed at run time
./testit: line 96: 42826 Abort trap              ./a.out
exp_valarray.pass.cpp failed at run time
./testit: line 96: 42833 Abort trap              ./a.out
log10_valarray.pass.cpp failed at run time
./testit: line 96: 42840 Abort trap              ./a.out
log_valarray.pass.cpp failed at run time
./testit: line 96: 42847 Abort trap              ./a.out
pow_valarray_valarray.pass.cpp failed at run time
./testit: line 96: 42854 Abort trap              ./a.out
pow_valarray_value.pass.cpp failed at run time
./testit: line 96: 42861 Abort trap              ./a.out
pow_value_valarray.pass.cpp failed at run time
./testit: line 96: 42868 Abort trap              ./a.out
sin_valarray.pass.cpp failed at run time
./testit: line 96: 42875 Abort trap              ./a.out
sinh_valarray.pass.cpp failed at run time
./testit: line 96: 42882 Abort trap              ./a.out
sqrt_valarray.pass.cpp failed at run time
./testit: line 96: 42889 Abort trap              ./a.out
tan_valarray.pass.cpp failed at run time
./testit: line 96: 42896 Abort trap              ./a.out
tanh_valarray.pass.cpp failed at run time
failed 19 tests in /test/numerics/numarray/valarray.nonmembers/valarray.transcend
passed 1 tests in /test/numerics/numarray/valarray.nonmembers/valarray.transcend
passed 4 tests in /test/numerics/numarray/valarray.range
passed 1 tests in /test/numerics/numarray/valarray.syn
passed 1 tests in /test/numerics/numeric.ops
passed 2 tests in /test/numerics/numeric.ops/accumulate
passed 2 tests in /test/numerics/numeric.ops/adjacent.difference
passed 2 tests in /test/numerics/numeric.ops/inner.product
not implemented:  /test/numerics/numeric.ops/numeric.iota
passed 2 tests in /test/numerics/numeric.ops/partial.sum
passed 1 tests in /test/numerics/numeric.requirements
not implemented:  /test/numerics/numerics.general
not implemented:  /test/numerics/rand
not implemented:  /test/numerics/rand/rand.adapt
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.disc
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.ibits
not implemented:  /test/numerics/rand/rand.adapt/rand.adapt.shuf
not implemented:  /test/numerics/rand/rand.concept
not implemented:  /test/numerics/rand/rand.concept/rand.concept.adapt
not implemented:  /test/numerics/rand/rand.concept/rand.concept.distr
not implemented:  /test/numerics/rand/rand.concept/rand.concept.eng
not implemented:  /test/numerics/rand/rand.concept/rand.concept.seedseq
not implemented:  /test/numerics/rand/rand.concept/rand.concept.urng
not implemented:  /test/numerics/rand/rand.device
not implemented:  /test/numerics/rand/rand.dis
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bernoulli
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.bin
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.geo
not implemented:  /test/numerics/rand/rand.dis/rand.dist.bern/rand.dist.bern.negbin
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.cauchy
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.chisq
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.f
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.lognormal
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.normal
not implemented:  /test/numerics/rand/rand.dis/rand.dist.norm/rand.dist.norm.t
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.exp
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.extreme
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.gamma
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.poisson
not implemented:  /test/numerics/rand/rand.dis/rand.dist.pois/rand.dist.pois.weibull
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.discrete
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.genpdf
not implemented:  /test/numerics/rand/rand.dis/rand.dist.samp/rand.dist.samp.pconst
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.int
not implemented:  /test/numerics/rand/rand.dis/rand.dist.uni/rand.dist.uni.real
not implemented:  /test/numerics/rand/rand.eng
not implemented:  /test/numerics/rand/rand.eng/rand.eng.lcong
not implemented:  /test/numerics/rand/rand.eng/rand.eng.mers
not implemented:  /test/numerics/rand/rand.eng/rand.eng.sub
not implemented:  /test/numerics/rand/rand.predef
not implemented:  /test/numerics/rand/rand.synopsis
not implemented:  /test/numerics/rand/rand.util
not implemented:  /test/numerics/rand/rand.util/rand.util.canonical
not implemented:  /test/numerics/rand/rand.util/rand.util.seedseq
not implemented:  /test/re
not implemented:  /test/re/re.alg
not implemented:  /test/re/re.alg/re.alg.match
not implemented:  /test/re/re.alg/re.alg.replace
not implemented:  /test/re/re.alg/re.alg.search
not implemented:  /test/re/re.alg/re.except
not implemented:  /test/re/re.badexp
not implemented:  /test/re/re.const
not implemented:  /test/re/re.const/re.err
not implemented:  /test/re/re.const/re.matchflag
not implemented:  /test/re/re.const/re.synopt
not implemented:  /test/re/re.def
not implemented:  /test/re/re.def/defns.regex.collating.element
not implemented:  /test/re/re.def/defns.regex.finite.state.machine
not implemented:  /test/re/re.def/defns.regex.format.specifier
not implemented:  /test/re/re.def/defns.regex.matched
not implemented:  /test/re/re.def/defns.regex.primary.equivalence.class
not implemented:  /test/re/re.def/defns.regex.regular.expression
not implemented:  /test/re/re.def/defns.regex.subexpression
not implemented:  /test/re/re.general
not implemented:  /test/re/re.grammar
not implemented:  /test/re/re.iter
not implemented:  /test/re/re.iter/re.regiter
not implemented:  /test/re/re.iter/re.regiter/re.regiter.cnstr
not implemented:  /test/re/re.iter/re.regiter/re.regiter.comp
not implemented:  /test/re/re.iter/re.regiter/re.regiter.deref
not implemented:  /test/re/re.iter/re.regiter/re.regiter.incr
not implemented:  /test/re/re.iter/re.tokiter
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.cnstr
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.comp
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.deref
not implemented:  /test/re/re.iter/re.tokiter/re.tokiter.incr
not implemented:  /test/re/re.regex
not implemented:  /test/re/re.regex/re.regex.assign
not implemented:  /test/re/re.regex/re.regex.const
not implemented:  /test/re/re.regex/re.regex.construct
not implemented:  /test/re/re.regex/re.regex.locale
not implemented:  /test/re/re.regex/re.regex.nonmemb
not implemented:  /test/re/re.regex/re.regex.nonmemb/re.regex.nmswap
not implemented:  /test/re/re.regex/re.regex.operations
not implemented:  /test/re/re.regex/re.regex.swap
not implemented:  /test/re/re.req
not implemented:  /test/re/re.results
not implemented:  /test/re/re.results/re.results.acc
not implemented:  /test/re/re.results/re.results.all
not implemented:  /test/re/re.results/re.results.const
not implemented:  /test/re/re.results/re.results.form
not implemented:  /test/re/re.results/re.results.nonmember
not implemented:  /test/re/re.results/re.results.size
not implemented:  /test/re/re.results/re.results.swap
not implemented:  /test/re/re.submatch
not implemented:  /test/re/re.submatch/re.submatch.members
not implemented:  /test/re/re.submatch/re.submatch.op
not implemented:  /test/re/re.syn
not implemented:  /test/re/re.traits
passed 1 tests in /test/strings
passed 1 tests in /test/strings/basic.string
passed 4 tests in /test/strings/basic.string/string.access
passed 10 tests in /test/strings/basic.string/string.capacity
passed 16 tests in /test/strings/basic.string/string.cons
passed 8 tests in /test/strings/basic.string/string.iterators
passed 1 tests in /test/strings/basic.string/string.modifiers
passed 8 tests in /test/strings/basic.string/string.modifiers/string::append
passed 8 tests in /test/strings/basic.string/string.modifiers/string::assign
passed 1 tests in /test/strings/basic.string/string.modifiers/string::copy
passed 4 tests in /test/strings/basic.string/string.modifiers/string::erase
passed 9 tests in /test/strings/basic.string/string.modifiers/string::insert
passed 4 tests in /test/strings/basic.string/string.modifiers/string::op+=
passed 11 tests in /test/strings/basic.string/string.modifiers/string::replace
passed 1 tests in /test/strings/basic.string/string.modifiers/string::swap
passed 1 tests in /test/strings/basic.string/string.nonmembers
./testit: line 96: 44038 Abort trap              ./a.out
get_line.pass.cpp failed at run time
./testit: line 96: 44046 Abort trap              ./a.out
get_line_delim.pass.cpp failed at run time
./testit: line 96: 44067 Abort trap              ./a.out
stream_extract.pass.cpp failed at run time
./testit: line 96: 44075 Abort trap              ./a.out
stream_insert.pass.cpp failed at run time
failed 4 tests in /test/strings/basic.string/string.nonmembers/string.io
passed 2 tests in /test/strings/basic.string/string.nonmembers/string.io
passed 1 tests in /test/strings/basic.string/string.nonmembers/string.special
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::op!=
passed 5 tests in /test/strings/basic.string/string.nonmembers/string::op+
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::operator==
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::opgt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::opgt=
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::oplt
passed 3 tests in /test/strings/basic.string/string.nonmembers/string::oplt=
passed 1 tests in /test/strings/basic.string/string.ops
passed 3 tests in /test/strings/basic.string/string.ops/string.accessors
passed 6 tests in /test/strings/basic.string/string.ops/string::compare
passed 4 tests in /test/strings/basic.string/string.ops/string::find
passed 4 tests in /test/strings/basic.string/string.ops/string::find.first.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.first.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.last.not.of
passed 4 tests in /test/strings/basic.string/string.ops/string::find.last.of
passed 4 tests in /test/strings/basic.string/string.ops/string::rfind
passed 1 tests in /test/strings/basic.string/string.ops/string::substr
passed 1 tests in /test/strings/basic.string/string.require
cuchar.pass.cpp:26:10: fatal error: 'cuchar' file not found
#include <cuchar>
         ^
1 diagnostic generated.
cuchar.pass.cpp failed to compile
failed 1 tests in /test/strings/c.strings
passed 4 tests in /test/strings/c.strings
passed 1 tests in /test/strings/char.traits
passed 1 tests in /test/strings/char.traits/char.traits.require
passed 1 tests in /test/strings/char.traits/char.traits.specializations
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char16_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.char32_t
passed 15 tests in /test/strings/char.traits/char.traits.specializations/char.traits.specializations.wchar.t
passed 1 tests in /test/strings/char.traits/char.traits.typedefs
passed 1 tests in /test/strings/string.classes
not implemented:  /test/strings/string.conversions
not implemented:  /test/strings/strings.general
passed 1 tests in /test/thread
passed 1 tests in /test/thread/futures
not implemented:  /test/thread/futures/futures.async
not implemented:  /test/thread/futures/futures.atomic_future
not implemented:  /test/thread/futures/futures.errors
not implemented:  /test/thread/futures/futures.future_error
passed 3 tests in /test/thread/futures/futures.overview
not implemented:  /test/thread/futures/futures.promise
not implemented:  /test/thread/futures/futures.shared_future
not implemented:  /test/thread/futures/futures.state
not implemented:  /test/thread/futures/futures.tas
not implemented:  /test/thread/futures/futures.unique_future
passed 1 tests in /test/thread/thread.condition
./testit: line 96: 45221 Killed                  ./a.out
destructor.pass.cpp failed at run time
failed 1 tests in /test/thread/thread.condition/thread.condition.condvar
passed 12 tests in /test/thread/thread.condition/thread.condition.condvar
passed 12 tests in /test/thread/thread.condition/thread.condition.condvarany
passed 1 tests in /test/thread/thread.general
passed 1 tests in /test/thread/thread.mutex
passed 1 tests in /test/thread/thread.mutex/thread.lock
passed 6 tests in /test/thread/thread.mutex/thread.lock/thread.lock.guard
passed 1 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique
passed 11 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.cons
passed 5 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.locking
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.mod
passed 3 tests in /test/thread/thread.mutex/thread.lock/thread.lock.unique/thread.lock.unique.obs
passed 2 tests in /test/thread/thread.mutex/thread.lock.algorithm
passed 1 tests in /test/thread/thread.mutex/thread.mutex.requirements
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.class
passed 6 tests in /test/thread/thread.mutex/thread.mutex.requirements/thread.mutex.recursive
passed 1 tests in /test/thread/thread.mutex/thread.once
passed 1 tests in /test/thread/thread.mutex/thread.once/thread.once.callonce
passed 3 tests in /test/thread/thread.mutex/thread.once/thread.once.onceflag
passed 1 tests in /test/thread/thread.mutex/thread.timedmutex.requirements
passed 7 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.class
passed 7 tests in /test/thread/thread.mutex/thread.timedmutex.requirements/thread.timedmutex.recursive
passed 1 tests in /test/thread/thread.req
passed 1 tests in /test/thread/thread.req/thread.req.exception
passed 1 tests in /test/thread/thread.req/thread.req.native
passed 1 tests in /test/thread/thread.req/thread.req.paramname
passed 1 tests in /test/thread/thread.req/thread.req.timing
passed 1 tests in /test/thread/thread.threads
passed 1 tests in /test/thread/thread.threads/thread.thread.class
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.algorithm
passed 2 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.assign
passed 4 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.constr
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.destr
./testit: line 96: 46079 Abort trap              ./a.out
stream.pass.cpp failed at run time
failed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.id
passed 5 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.id
passed 6 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.member
passed 1 tests in /test/thread/thread.threads/thread.thread.class/thread.thread.static
passed 4 tests in /test/thread/thread.threads/thread.thread.this
passed 1 tests in /test/utilities
passed 1 tests in /test/utilities/date.time
passed 1 tests in /test/utilities/function.objects
passed 6 tests in /test/utilities/function.objects/arithmetic.operations
passed 1 tests in /test/utilities/function.objects/base
passed 1 tests in /test/utilities/function.objects/bind
passed 1 tests in /test/utilities/function.objects/bind/func.bind
invoke_int_0.pass.cpp:58:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:59:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:60:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:61:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()), 5);
               ~~~~~^
invoke_int_0.pass.cpp:63:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:64:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(&f), 1);
         ~~~~~^
invoke_int_0.pass.cpp:65:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<int>(A_int_0()), 4);
         ~~~~~^
invoke_int_0.pass.cpp:66:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<int>(A_int_0()), 5);
               ~~~~~^
8 diagnostics generated.
invoke_int_0.pass.cpp failed to compile
invoke_lvalue.pass.cpp:64:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:70:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:78:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:85:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:93:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(i);
    ~~~~~^
invoke_lvalue.pass.cpp:100:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, i)();
    ~~~~~^
invoke_lvalue.pass.cpp:108:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:112:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:119:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:123:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:131:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(a);
    ~~~~~^
invoke_lvalue.pass.cpp:135:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(ap);
    ~~~~~^
invoke_lvalue.pass.cpp:142:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, a)();
    ~~~~~^
invoke_lvalue.pass.cpp:146:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, ap)();
    ~~~~~^
invoke_lvalue.pass.cpp:179:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:179:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(i) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:180:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, i)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:180:17: note: instantiated from:
    assert(std::bind(f_int_1, i)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:186:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(i) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:186:17: note: instantiated from:
    assert(std::bind(fp, _1)(i) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:187:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, i)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:187:17: note: instantiated from:
    assert(std::bind(fp, i)() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:192:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(i) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:192:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(i) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:193:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), i)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:193:17: note: instantiated from:
    assert(std::bind(A_int_1(), i)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:198:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(a) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:198:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(a) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:199:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, a)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:199:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, a)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:201:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(ap) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:201:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(ap) == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:202:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, ap)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:202:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, ap)() == 3);
           ~~~~~^
invoke_lvalue.pass.cpp:207:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:207:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:208:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:208:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:210:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(ap) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:210:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(ap) == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:211:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, ap)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:211:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, ap)() == 4);
           ~~~~~^
invoke_lvalue.pass.cpp:216:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:216:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:217:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, a)() == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:217:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, a)() == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:219:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:219:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_lvalue.pass.cpp:220:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(a) = 6;
    ~~~~~^
invoke_lvalue.pass.cpp:221:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:221:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
           ~~~~~^
invoke_lvalue.pass.cpp:222:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(ap) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:222:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(ap) == 6);
           ~~~~~^
invoke_lvalue.pass.cpp:223:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(ap) = 7;
    ~~~~~^
invoke_lvalue.pass.cpp:224:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(ap) == 7);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_lvalue.pass.cpp:224:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(ap) == 7);
           ~~~~~^
invoke_lvalue.pass.cpp:255:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, _1, _2)(i, j);
    ~~~~~^
invoke_lvalue.pass.cpp:258:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, i, _1)(j);
    ~~~~~^
invoke_lvalue.pass.cpp:261:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, i, j)();
    ~~~~~^
invoke_lvalue.pass.cpp:268:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _1, _2)(A_void_2(), j);
    ~~~~~^
invoke_lvalue.pass.cpp:271:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _2, _1)(j, A_void_2());
    ~~~~~^
41 diagnostics generated.
invoke_lvalue.pass.cpp failed to compile
invoke_rvalue.pass.cpp:63:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, _1)(2);
    ~~~~~^
invoke_rvalue.pass.cpp:68:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_1, 2)();
    ~~~~~^
invoke_rvalue.pass.cpp:75:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(3);
    ~~~~~^
invoke_rvalue.pass.cpp:81:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, 3)();
    ~~~~~^
invoke_rvalue.pass.cpp:88:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, _1)(4);
    ~~~~~^
invoke_rvalue.pass.cpp:94:10: error: no member named 'bind' in namespace 'std'
    std::bind(a0, 4)();
    ~~~~~^
invoke_rvalue.pass.cpp:101:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:105:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:111:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:115:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:122:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(A_void_1());
    ~~~~~^
invoke_rvalue.pass.cpp:126:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, _1)(&a);
    ~~~~~^
invoke_rvalue.pass.cpp:132:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, A_void_1())();
    ~~~~~^
invoke_rvalue.pass.cpp:136:10: error: no member named 'bind' in namespace 'std'
    std::bind(fp, &a)();
    ~~~~~^
invoke_rvalue.pass.cpp:168:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, _1)(2) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:168:17: note: instantiated from:
    assert(std::bind(f_int_1, _1)(2) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:169:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(f_int_1, 2)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:169:17: note: instantiated from:
    assert(std::bind(f_int_1, 2)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:174:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, _1)(3) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:174:17: note: instantiated from:
    assert(std::bind(fp, _1)(3) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:175:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(fp, 3)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:175:17: note: instantiated from:
    assert(std::bind(fp, 3)() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:179:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), _1)(4) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:179:17: note: instantiated from:
    assert(std::bind(A_int_1(), _1)(4) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:180:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(A_int_1(), 4)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:180:17: note: instantiated from:
    assert(std::bind(A_int_1(), 4)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:184:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(A_int_1()) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:184:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(A_int_1()) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:185:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, A_int_1())() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:185:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, A_int_1())() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:187:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, _1)(&a) == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:187:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, _1)(&a) == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:188:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem1, &a)() == 3);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:188:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem1, &a)() == 3);
           ~~~~~^
invoke_rvalue.pass.cpp:192:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:192:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(A_int_1()) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:193:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:193:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, A_int_1())() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:195:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, _1)(&a) == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:195:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, _1)(&a) == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:196:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::mem2, &a)() == 4);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:196:17: note: instantiated from:
    assert(std::bind(&A_int_1::mem2, &a)() == 4);
           ~~~~~^
invoke_rvalue.pass.cpp:200:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(A_int_1()) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:200:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(A_int_1()) == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:201:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, A_int_1())() == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:201:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, A_int_1())() == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:203:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:203:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 5);
           ~~~~~^
invoke_rvalue.pass.cpp:204:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(a) = 6;
    ~~~~~^
invoke_rvalue.pass.cpp:205:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:205:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(a) == 6);
           ~~~~~^
invoke_rvalue.pass.cpp:206:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(&a) == 6);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:206:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(&a) == 6);
           ~~~~~^
invoke_rvalue.pass.cpp:207:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_int_1::data_, _1)(&a) = 7;
    ~~~~~^
invoke_rvalue.pass.cpp:208:5: error: no member named 'bind' in namespace 'std'
    assert(std::bind(&A_int_1::data_, _1)(&a) == 7);
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
invoke_rvalue.pass.cpp:208:17: note: instantiated from:
    assert(std::bind(&A_int_1::data_, _1)(&a) == 7);
           ~~~~~^
invoke_rvalue.pass.cpp:237:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, _1, _2)(2, 3);
    ~~~~~^
invoke_rvalue.pass.cpp:240:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, 2, _1)(3);
    ~~~~~^
invoke_rvalue.pass.cpp:243:10: error: no member named 'bind' in namespace 'std'
    std::bind(f_void_2, 2, 3)();
    ~~~~~^
invoke_rvalue.pass.cpp:249:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _1, _2)(A_void_2(), 3);
    ~~~~~^
invoke_rvalue.pass.cpp:252:10: error: no member named 'bind' in namespace 'std'
    std::bind(&A_void_2::mem1, _2, _1)(3, A_void_2());
    ~~~~~^
41 diagnostics generated.
invoke_rvalue.pass.cpp failed to compile
invoke_void_0.pass.cpp:64:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(f));
         ~~~~~^
invoke_void_0.pass.cpp:65:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(&f));
         ~~~~~^
invoke_void_0.pass.cpp:66:15: error: no member named 'bind' in namespace 'std'
    test(std::bind(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:67:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind(A_int_0()));
               ~~~~~^
invoke_void_0.pass.cpp:69:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(f));
         ~~~~~^
invoke_void_0.pass.cpp:70:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(&f));
         ~~~~~^
invoke_void_0.pass.cpp:71:15: error: no member named 'bind' in namespace 'std'
    test(std::bind<void>(A_int_0()));
         ~~~~~^
invoke_void_0.pass.cpp:72:21: error: no member named 'bind' in namespace 'std'
    test_const(std::bind<void>(A_int_0()));
               ~~~~~^
8 diagnostics generated.
invoke_void_0.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/bind/func.bind/func.bind.bind
is_bind_expression.pass.cpp:41:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C()));
               ~~~~~^
is_bind_expression.pass.cpp:42:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind(C(), std::placeholders::_2));
               ~~~~~^
is_bind_expression.pass.cpp:43:21: error: no member named 'bind' in namespace 'std'
    test<true>(std::bind<int>(C()));
               ~~~~~^
3 diagnostics generated.
is_bind_expression.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isbind
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.isplace
passed 1 tests in /test/utilities/function.objects/bind/func.bind/func.bind.place
passed 3 tests in /test/utilities/function.objects/bitwise.operations
passed 6 tests in /test/utilities/function.objects/comparisons
passed 1 tests in /test/utilities/function.objects/func.def
member_function.pass.cpp:57:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:57:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function.pass.cpp:78:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
member_function.pass.cpp:69:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function.pass.cpp:69:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function.pass.cpp:79:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:72:11: note: candidate function [with $0 = A, $1 = int, $2 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
8 diagnostics generated.
member_function.pass.cpp failed to compile
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:123:12: error: functional-style cast from 'char (A::*)() const' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:131:12: error: functional-style cast from 'char (A::*)(int) const' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:139:12: error: functional-style cast from 'char (A::*)(int, double) const' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
member_function_const.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:72:11: note: candidate function [with $0 = A, $1 = int, $2 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
14 diagnostics generated.
member_function_const.pass.cpp failed to compile
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:187:12: error: functional-style cast from 'char (A::*)() const volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:195:12: error: functional-style cast from 'char (A::*)(int) const volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_const_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_const_volatile.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:203:12: error: functional-style cast from 'char (A::*)(int, double) const volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
member_function_const_volatile.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_const_volatile.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_const_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_const_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:72:11: note: candidate function [with $0 = A, $1 = int, $2 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
14 diagnostics generated.
member_function_const_volatile.pass.cpp failed to compile
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:155:12: error: functional-style cast from 'char (A::*)() volatile' to '__mem_fn<char (A::*)()>' is not allowed
    return __mem_fn<_R (_T::*)()>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:83:11: note: in instantiation of function template specialization 'std::mem_fn<char, A>' requested here
    test0(std::mem_fn(&A::test0));
          ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:163:12: error: functional-style cast from 'char (A::*)(int) volatile' to '__mem_fn<char (A::*)(int)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:84:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int>' requested here
    test1(std::mem_fn(&A::test1));
          ^
member_function_volatile.pass.cpp:59:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int)>'
    assert(f(a, 1) == 'b');
    ^~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:59:12: note: instantiated from:
    assert(f(a, 1) == 'b');
           ^
member_function_volatile.pass.cpp:84:5: note: in instantiation of function template specialization 'test1<std::__mem_fn<char (A::*)(int)> >' requested here
    test1(std::mem_fn(&A::test1));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:65:11: note: candidate function [with $0 = A, $1 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 2 were provided
       operator() ()
       ^
../../../../include/__functional_03:171:12: error: functional-style cast from 'char (A::*)(int, double) volatile' to '__mem_fn<char (A::*)(int, double)>' is not allowed
    return __mem_fn<_R (_T::*)(_A0, _A1)>(__pm);
           ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:85:11: note: in instantiation of function template specialization 'std::mem_fn<char, A, int, double>' requested here
    test2(std::mem_fn(&A::test2));
          ^
member_function_volatile.pass.cpp:73:5: error: no matching function for call to object of type 'std::__mem_fn<char (A::*)(int, double)>'
    assert(f(a, 1, 2) == 'c');
    ^~~~~~~~~~~~~~~~~~~~~~~~~
member_function_volatile.pass.cpp:73:12: note: instantiated from:
    assert(f(a, 1, 2) == 'c');
           ^
member_function_volatile.pass.cpp:85:5: note: in instantiation of function template specialization 'test2<std::__mem_fn<char (A::*)(int, double)> >' requested here
    test2(std::mem_fn(&A::test2));
    ^
In file included from member_function_volatile.pass.cpp:29:
In file included from ../../../../include/functional:915:
../../../../include/__functional_03:72:11: note: candidate function [with $0 = A, $1 = int, $2 = int] not viable: no known conversion from 'int' to 'int &' for 2nd argument
          operator() (_A0& __a0, _A1& __a1, _A2& __a2)
          ^
../../../../include/__functional_03:51:8: note: candidate function not viable: requires 0 arguments, but 3 were provided
       operator() ()
       ^
14 diagnostics generated.
member_function_volatile.pass.cpp failed to compile
failed 4 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.memfn
passed 2 tests in /test/utilities/function.objects/func.require
passed 1 tests in /test/utilities/function.objects/func.ret
passed 1 tests in /test/utilities/function.objects/func.wrap
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.badcall/func.wrap.badcall.const
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.alg
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.cap
passed 7 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.con
passed 4 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.inv
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.mod
passed 1 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.nullptr
passed 2 tests in /test/utilities/function.objects/func.wrap/func.wrap.func/func.wrap.func.targ
passed 4 tests in /test/utilities/function.objects/function.pointer.adaptors
passed 3 tests in /test/utilities/function.objects/logical.operations
passed 16 tests in /test/utilities/function.objects/member.pointer.adaptors
passed 4 tests in /test/utilities/function.objects/negators
passed 4 tests in /test/utilities/function.objects/refwrap
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.access
passed 1 tests in /test/utilities/function.objects/refwrap/refwrap.assign
type_ctor.fail.cpp should not compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.const
passed 2 tests in /test/utilities/function.objects/refwrap/refwrap.const
ref_1.fail.cpp should not compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
passed 4 tests in /test/utilities/function.objects/refwrap/refwrap.helpers
invoke_int_0.pass.cpp:68:5: error: invalid operands to binary expression ('__ref_return0<type>::type' (aka 'void') and 'int')
    assert(r1() == 4);
    ^~~~~~~~~~~~~~~~~
invoke_int_0.pass.cpp:68:17: note: instantiated from:
    assert(r1() == 4);
           ~~~~ ^  ~
1 diagnostic generated.
invoke_int_0.pass.cpp failed to compile
failed 1 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 3 tests in /test/utilities/function.objects/refwrap/refwrap.invoke
passed 8 tests in /test/utilities/function.objects/unord.hash
passed 1 tests in /test/utilities/memory
passed 1 tests in /test/utilities/memory/allocator.adaptor
passed 5 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.cnstr
passed 9 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.members
passed 4 tests in /test/utilities/memory/allocator.adaptor/allocator.adaptor.types
passed 1 tests in /test/utilities/memory/allocator.tag
passed 3 tests in /test/utilities/memory/allocator.traits
passed 7 tests in /test/utilities/memory/allocator.traits/allocator.traits.members
passed 10 tests in /test/utilities/memory/allocator.traits/allocator.traits.types
passed 1 tests in /test/utilities/memory/allocator.uses
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.construction
passed 1 tests in /test/utilities/memory/allocator.uses/allocator.uses.trait
passed 1 tests in /test/utilities/memory/c.malloc
passed 2 tests in /test/utilities/memory/default.allocator
passed 1 tests in /test/utilities/memory/default.allocator/allocator.globals
passed 4 tests in /test/utilities/memory/default.allocator/allocator.members
passed 5 tests in /test/utilities/memory/pointer.traits
passed 1 tests in /test/utilities/memory/pointer.traits/pointer.traits.functions
passed 3 tests in /test/utilities/memory/pointer.traits/pointer.traits.types
passed 1 tests in /test/utilities/memory/ptr.align
passed 1 tests in /test/utilities/memory/specialized.algorithms
passed 1 tests in /test/utilities/memory/specialized.algorithms/specialized.addressof
passed 2 tests in /test/utilities/memory/specialized.algorithms/uninitialized.copy
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill
passed 1 tests in /test/utilities/memory/specialized.algorithms/uninitialized.fill.n
passed 1 tests in /test/utilities/memory/storage.iterator
passed 1 tests in /test/utilities/memory/temporary.buffer
passed 1 tests in /test/utilities/memory/unique.ptr
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.dltr/unique.ptr.dltr.dflt1
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-JTW9Zx.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
move01.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
passed 17 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime
default01.fail.cpp should not compile
pointer01.fail.cpp should not compile
pointer_deleter04.fail.cpp should not compile
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-jOKZDG.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
move01.pass.cpp failed to compile
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-bx1cDJ.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
pointer_deleter01.pass.cpp failed to compile
failed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
passed 37 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.ctor
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-LLuEFf.o
      _main in cc-LLuEFf.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 3 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.runtime/unique.ptr.runtime.observers
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single
move_convert13.fail.cpp should not compile
Assertion failed: (s2.get() == p), function main, file move01.pass.cpp, line 57.
./testit: line 96: 48090 Abort trap              ./a.out
move01.pass.cpp failed at run time
In file included from move_convert01.pass.cpp:30:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1207:12: error: non-const lvalue reference to type 'std::default_delete<A>' cannot bind to a value of unrelated type 'std::default_delete<B>'
    return t;
           ^
In file included from move_convert01.pass.cpp:30:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<std::default_delete<A>, std::default_delete<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert01.pass.cpp:30:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert01.pass.cpp:61:8: note: in instantiation of function template specialization 'std::unique_ptr<A, std::default_delete<A> >::operator=<B, std::default_delete<B> >' requested here
    s2 = std::move(s);
       ^
3 diagnostics generated.
move_convert01.pass.cpp failed to compile
In file included from move_convert02.pass.cpp:30:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1219:14: error: functional-style cast from 'Deleter<B>' to '__rv<Deleter<A> >' is not allowed
    return T(__rv<T>(t));
             ^~~~~~~~
In file included from move_convert02.pass.cpp:30:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<Deleter<A>, Deleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert02.pass.cpp:30:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert02.pass.cpp:63:8: note: in instantiation of function template specialization 'std::unique_ptr<A, Deleter<A> >::operator=<B, Deleter<B> >' requested here
    s2 = std::move(s);
       ^
3 diagnostics generated.
move_convert02.pass.cpp failed to compile
In file included from move_convert03.pass.cpp:32:
In file included from ../../../../../../include/memory:209:
../../../../../../include/type_traits:1207:12: error: non-const lvalue reference to type 'CDeleter<A>' cannot bind to a value of unrelated type 'CDeleter<B>'
    return t;
           ^
In file included from move_convert03.pass.cpp:32:
../../../../../../include/memory:2198:27: note: in instantiation of function template specialization 'std::forward<CDeleter<A> &, CDeleter<B> >' requested here
        __ptr_.second() = _STD::forward<deleter_type>(__u.get_deleter());
                          ^
In file included from move_convert03.pass.cpp:32:
In file included from ../../../../../../include/memory:208:
../../../../../../include/__yuga_config:117:14: note: instantiated from:
#define _STD std
             ^
move_convert03.pass.cpp:66:8: note: in instantiation of function template specialization 'std::unique_ptr<A, CDeleter<A> &>::operator=<B, CDeleter<B> &>' requested here
    s2 = std::move(s);
       ^
3 diagnostics generated.
move_convert03.pass.cpp failed to compile
failed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
passed 12 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.asgn
default01.fail.cpp should not compile
pointer01.fail.cpp should not compile
pointer_deleter04.fail.cpp should not compile
move_convert01.pass.cpp:63:24: error: no matching constructor for initialization of 'std::unique_ptr<A>'
    std::unique_ptr<A> s2(std::move(s));
                       ^  ~~~~~~~~~~~~
In file included from move_convert01.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
9 diagnostics generated.
move_convert01.pass.cpp failed to compile
move_convert02.pass.cpp:65:37: error: no matching constructor for initialization of 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2(std::move(s));
                                    ^  ~~~~~~~~~~~~
In file included from move_convert02.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
9 diagnostics generated.
move_convert02.pass.cpp failed to compile
move_convert03.pass.cpp:81:38: error: no matching constructor for initialization of 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2(std::move(s));
                                     ^  ~~~~~~~~~~~~
In file included from move_convert03.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'pointer' (aka 'A *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
9 diagnostics generated.
move_convert03.pass.cpp failed to compile
move_convert04.pass.cpp:63:24: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A>'
    std::unique_ptr<A> s2 = std::move(s);
                       ^    ~~~~~~~~~~~~
In file included from move_convert04.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::unique_ptr<A, std::default_delete<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = std::default_delete<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'unique_ptr<B, std::default_delete<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, default_delete<B> >, __rv<unique_ptr<B, default_delete<B> > > >::value, unique_ptr<B, default_delete<B> > >::type' (aka 'std::unique_ptr<B, std::default_delete<B> >') to '__rv<std::unique_ptr<A, std::default_delete<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
8 diagnostics generated.
move_convert04.pass.cpp failed to compile
move_convert05.pass.cpp:65:37: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> >'
    std::unique_ptr<A, Deleter<A> > s2 = std::move(s);
                                    ^    ~~~~~~~~~~~~
In file included from move_convert05.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::unique_ptr<A, Deleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = Deleter<B>] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'unique_ptr<B, Deleter<B> > &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, Deleter<B> >, __rv<unique_ptr<B, Deleter<B> > > >::value, unique_ptr<B, Deleter<B> > >::type' (aka 'std::unique_ptr<B, Deleter<B> >') to '__rv<std::unique_ptr<A, Deleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
8 diagnostics generated.
move_convert05.pass.cpp failed to compile
move_convert06.pass.cpp:81:38: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &>'
    std::unique_ptr<A, CDeleter<A>&> s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert06.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::unique_ptr<A, CDeleter<A> &> &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<A> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'unique_ptr<B, CDeleter<A> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<A> &>, __rv<unique_ptr<B, CDeleter<A> &> > >::value, unique_ptr<B, CDeleter<A> &> >::type' (aka 'std::unique_ptr<B, CDeleter<A> &>') to '__rv<std::unique_ptr<A, CDeleter<A> &> >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
8 diagnostics generated.
move_convert06.pass.cpp failed to compile
move_convert07.pass.cpp:66:38: error: no viable conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> >'
    std::unique_ptr<A, CDeleter<A> > s2 = std::move(s);
                                     ^    ~~~~~~~~~~~~
In file included from move_convert07.pass.cpp:30:
../../../../../../include/memory:2080:5: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::unique_ptr<A, CDeleter<A> > &' for 1st argument
    unique_ptr(unique_ptr&);
    ^
../../../../../../include/memory:2082:9: note: candidate constructor [with $0 = B, $1 = CDeleter<B> &] not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'unique_ptr<B, CDeleter<B> &> &' for 1st argument
        unique_ptr(unique_ptr<_Up, _Ep>&);
        ^
../../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'enable_if<is_convertible<unique_ptr<B, CDeleter<B> &>, __rv<unique_ptr<B, CDeleter<B> &> > >::value, unique_ptr<B, CDeleter<B> &> >::type' (aka 'std::unique_ptr<B, CDeleter<B> &>') to '__rv<std::unique_ptr<A, CDeleter<A> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../../include/memory:2186:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator __rv<unique_ptr>()
                            ^
../../../../../../include/memory:2230:29: note: candidate function
    _YUGA_INLINE_VISIBILITY operator int __nat::*() const {return __ptr_.first() ? &__nat::__for_bool_ : 0;}
                            ^
8 diagnostics generated.
move_convert07.pass.cpp failed to compile
failed 10 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 38 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.ctor
passed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.dtor
passed 5 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.modifiers
passed 6 tests in /test/utilities/memory/unique.ptr/unique.ptr.single/unique.ptr.single.observers
Undefined symbols:
  "__ZNSt10unique_ptrIA_1A7DeleterIS1_EEC1IPS0_EET_RKS3_NSt9enable_ifIXsrSt14is_convertibleIS7_S6_E5valueENS4_5__natEE4typeE", referenced from:
      _main in cc-313c4M.o
      _main in cc-313c4M.o
ld: symbol(s) not found
clang: error: linker command failed with exit code 1 (use -v to see invocation)
swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 2 tests in /test/utilities/memory/unique.ptr/unique.ptr.special
passed 3 tests in /test/utilities/memory/util.dynamic.safety
passed 1 tests in /test/utilities/memory/util.smartptr
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.enab
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.getdeleter
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_Y_rv.pass.cpp, line 67.
./testit: line 96: 48532 Abort trap              ./a.out
shared_ptr_Y_rv.pass.cpp failed at run time
Assertion failed: (pB.use_count() == 1), function main, file shared_ptr_rv.pass.cpp, line 67.
./testit: line 96: 48539 Abort trap              ./a.out
shared_ptr_rv.pass.cpp failed at run time
failed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 4 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.assign
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cast
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.cmp
Assertion failed: (A::count == 1), function main, file unique_ptr.pass.cpp, line 94.
./testit: line 96: 48727 Abort trap              ./a.out
unique_ptr.pass.cpp failed at run time
failed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 19 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.const
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.create
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.dest
./testit: line 96: 48776 Abort trap              ./a.out
io.pass.cpp failed at run time
failed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.io
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.mod
passed 6 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.shared/util.smartptr.shared.spec
not implemented:  /test/utilities/memory/util.smartptr/util.smartptr.shared.atomic
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.ownerless
passed 3 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.assign
passed 4 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.const
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.dest
passed 2 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.mod
passed 5 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.obs
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weak/util.smartptr.weak.spec
passed 1 tests in /test/utilities/memory/util.smartptr/util.smartptr.weakptr
passed 1 tests in /test/utilities/meta
passed 1 tests in /test/utilities/meta/meta.hel
is_convertible.pass.cpp:111:5: warning: qualifier on function type 'Function' (aka 'void ()') has unspecified behavior
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_convertible.pass.cpp:111:52: note: instantiated from:
    static_assert(( std::is_convertible<Function&, const Function&>::value), "");
                                                   ^~~~~~~~~~~~~~
is_convertible.pass.cpp:289:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert((!std::is_convertible<char, char&>::value), "");
    ^
In file included from is_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
3 diagnostics generated.
is_convertible.pass.cpp failed to compile
is_explicitly_convertible.pass.cpp:36:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:36:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:36:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:36:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:37:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:37:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:37:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:37:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:38:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:38:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:38:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:38:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:39:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:39:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:39:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:39:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const void, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:41:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:41:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:41:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:41:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:42:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:42:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:42:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:42:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:44:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:44:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:44:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:44:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:45:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:45:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:45:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:45:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:47:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:47:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:47:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:47:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:48:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:48:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:48:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:48:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:49:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:49:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:49:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:49:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:50:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:50:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:50:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:50:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:52:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:52:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:52:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:52:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:53:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:53:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:53:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:53:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:54:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:54:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:54:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:54:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:55:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:55:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:55:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:55:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:57:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:57:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:57:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:57:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:58:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:58:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:58:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:58:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:59:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:59:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:59:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:59:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:60:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:60:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:60:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:60:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:62:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:62:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:62:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:62:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:63:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:63:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:63:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:63:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:64:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:64:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:64:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:64:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:65:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:65:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:65:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:65:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:67:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:67:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:67:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:67:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:68:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:68:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:68:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:68:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:69:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:69:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:69:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:69:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:70:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:70:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:70:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:70:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:72:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:72:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:72:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:72:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:73:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:73:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:73:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:73:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:74:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:74:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:74:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:74:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:75:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:75:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:75:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:75:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const void, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:78:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:78:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:78:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:78:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:79:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:79:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:79:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:79:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:81:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:81:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:81:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:81:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:83:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:83:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:83:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:83:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:84:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:84:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:84:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:84:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:86:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:86:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:86:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:86:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:87:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:87:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:87:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:87:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:89:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:89:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:89:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:89:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:90:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:90:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:90:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:90:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:92:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:92:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:92:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:92:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:93:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:93:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:93:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:93:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:95:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:95:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:95:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:95:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:96:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:96:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:96:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:96:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:98:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:98:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:98:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:98:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:99:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:99:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:99:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:99:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:101:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:101:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:101:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:101:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:102:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:102:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:102:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:102:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:105:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:105:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:105:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:105:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:106:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:106:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:106:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:106:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:108:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:108:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:108:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:108:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:110:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:110:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:110:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:110:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:111:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:111:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:111:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:111:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, const Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:113:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:113:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:113:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:113:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:114:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:114:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:114:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:114:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:116:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:116:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:116:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:116:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:117:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:117:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:117:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:117:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:119:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:119:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:119:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:119:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:120:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:120:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:120:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:120:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:122:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:122:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:122:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:122:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:123:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:123:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:123:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:123:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:125:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:125:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:125:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:125:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:126:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:126:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:126:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:126:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:128:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:128:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:128:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:128:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:129:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:129:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:129:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:129:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:132:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:132:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:132:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:132:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:133:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:133:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:133:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:133:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:134:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:134:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:134:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:134:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:135:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:135:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:135:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:135:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:137:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:137:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:137:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:137:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:138:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:138:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:138:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:138:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:140:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:140:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:140:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:140:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:141:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:141:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:141:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:141:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:143:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:143:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:143:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:143:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:144:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:144:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:144:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:144:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:145:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:145:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:145:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:145:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*const, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:146:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:146:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:146:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:146:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Function*const, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:148:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:148:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:148:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:148:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:149:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:149:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:149:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:149:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:150:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:150:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:150:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:150:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:151:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:151:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:151:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:151:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:153:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:153:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:153:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:153:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:154:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:154:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:154:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:154:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:155:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:155:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:155:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:155:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:156:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:156:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:156:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:156:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:158:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:158:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:158:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:158:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:159:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:159:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:159:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:159:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:160:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:160:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:160:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:160:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:161:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:161:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:161:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:161:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:163:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:163:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:163:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:163:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:164:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:164:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:164:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:164:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:165:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:165:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:165:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:165:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:166:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:166:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:166:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:166:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:168:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:168:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:168:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:168:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:169:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:169:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:169:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:169:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:170:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:170:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:170:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:170:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:171:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:171:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:171:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:171:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Function*const, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:174:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:174:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:174:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:174:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:175:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:175:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:175:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:175:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:176:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:176:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:176:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:176:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:177:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:177:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:177:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:177:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:179:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:179:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:179:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:179:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:180:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:180:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:180:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:180:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:182:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:182:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:182:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:182:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:183:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:183:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:183:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:183:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:185:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:185:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:185:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:185:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:186:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:186:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:186:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:186:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:187:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:187:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:187:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:187:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:188:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:188:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:188:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:188:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:190:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:190:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:190:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:190:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:191:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:191:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:191:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:191:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:192:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:192:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:192:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:192:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:193:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:193:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:193:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:193:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:195:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:195:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:195:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:195:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:196:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:196:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:196:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:196:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:197:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:197:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:197:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:197:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:198:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:198:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:198:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:198:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:200:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:200:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:200:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:200:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:201:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:201:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:201:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:201:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:202:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:202:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:202:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:202:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:203:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:203:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:203:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:203:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:205:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:205:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:205:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:205:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:206:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:206:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:206:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:206:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:207:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:207:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:207:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:207:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:208:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:208:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:208:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:208:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:210:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:210:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:210:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:210:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:211:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:211:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:211:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:211:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:212:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:212:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:212:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:212:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:213:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:213:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:213:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:213:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:216:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:216:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:216:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:216:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:217:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:217:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:217:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:217:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:218:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:218:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:218:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:218:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:219:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:219:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:219:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:219:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:221:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:221:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:221:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:221:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:222:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:222:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:222:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:222:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:224:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:224:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:224:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:224:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:225:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:225:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:225:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:225:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:227:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:227:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:227:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:227:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:228:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:228:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:228:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:228:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:229:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:229:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:229:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:229:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:230:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:230:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:230:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:230:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:232:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:232:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:232:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:232:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:233:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:233:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:233:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:233:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:234:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:234:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:234:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:234:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:235:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:235:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:235:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:235:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:237:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:237:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:237:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:237:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:238:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:238:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:238:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:238:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:239:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:239:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:239:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:239:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:240:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:240:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:240:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:240:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:242:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:242:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:242:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:242:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:243:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:243:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:243:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:243:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:244:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:244:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:244:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:244:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:245:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:245:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:245:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:245:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:247:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:247:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:247:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:247:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:248:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:248:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:248:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:248:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:249:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:249:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:249:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:249:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:250:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:250:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:250:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:250:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:252:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:252:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:252:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:252:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:253:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:253:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:253:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:253:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:254:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:254:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:254:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:254:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const Array&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:255:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:255:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:255:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:255:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const Array&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:258:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:258:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:258:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:258:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:259:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:259:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:259:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:259:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:260:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:260:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:260:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:260:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:261:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:261:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:261:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:261:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:263:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:263:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:263:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:263:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:264:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:264:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:264:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:264:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:266:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:266:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:266:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:266:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:267:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:267:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:267:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:267:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:269:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:269:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:269:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:269:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:270:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:270:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:270:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:270:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:271:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:271:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:271:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:271:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:272:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:272:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:272:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:272:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:274:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:274:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:274:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:274:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:275:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:275:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:275:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:275:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:276:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:276:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:276:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:276:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:277:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:277:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:277:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:277:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:279:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:279:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:279:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:279:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:280:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:280:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:280:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:280:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:281:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:281:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:281:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:281:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:282:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:282:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:282:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:282:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:284:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:284:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:284:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:284:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:285:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:285:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:285:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:285:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:286:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:286:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:286:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:286:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:287:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:287:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:287:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:287:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:289:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:289:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:289:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:289:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:290:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:290:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:290:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:290:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:291:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:291:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:291:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:291:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:292:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:292:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:292:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:292:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:294:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:294:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:294:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:294:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:295:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:295:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:295:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:295:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:296:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:296:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:296:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:296:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:297:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:297:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:297:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:297:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:300:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:300:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:300:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:300:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:301:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:301:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:301:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:301:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:302:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:302:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:302:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:302:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:303:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:303:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:303:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:303:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:305:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:305:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:305:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:305:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:306:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:306:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:306:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:306:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:308:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:308:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:308:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:308:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:309:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:309:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:309:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:309:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:311:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:311:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:311:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:311:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:312:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:312:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:312:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:312:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:313:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:313:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:313:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:313:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:314:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:314:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:314:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:314:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:316:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:316:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:316:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:316:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:317:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:317:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:317:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:317:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:318:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:318:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:318:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:318:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:319:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:319:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:319:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:319:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:321:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:321:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:321:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:321:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:322:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:322:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:322:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:322:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:323:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:323:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:323:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:323:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:324:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:324:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:324:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:324:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:326:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:326:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:326:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:326:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:327:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:327:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:327:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:327:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:328:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:328:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:328:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:328:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:329:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:329:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:329:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:329:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:331:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:331:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:331:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:331:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:332:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:332:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:332:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:332:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:333:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:333:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:333:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:333:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:334:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:334:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:334:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:334:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char&, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:336:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:336:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:336:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:336:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:337:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:337:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:337:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:337:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:338:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:338:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:338:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:338:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:339:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:339:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:339:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:339:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char&, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:342:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:342:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:342:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:342:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:343:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:343:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:343:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:343:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:344:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:344:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:344:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:344:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:345:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:345:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:345:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:345:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const void>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:347:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:347:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:347:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:347:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:348:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:348:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:348:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:348:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:350:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:350:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:350:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:350:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:351:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:351:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:351:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:351:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:353:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:353:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:353:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:353:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:354:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:354:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:354:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:354:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Function* const>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:355:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:355:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:355:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:355:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:356:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:356:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:356:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:356:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Function*const >::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:358:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:358:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:358:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:358:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:359:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:359:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:359:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:359:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:360:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:360:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:360:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:360:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:361:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:361:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:361:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:361:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const Array>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:363:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:363:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:363:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:363:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:364:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:364:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:364:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:364:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:365:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:365:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:365:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:365:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:366:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:366:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:366:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:366:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const Array&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:368:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:368:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:368:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:368:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:369:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:369:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:369:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:369:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:370:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:370:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:370:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:370:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:371:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:371:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:371:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:371:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const char>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:373:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:373:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:373:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:373:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:374:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:374:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:374:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:374:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:375:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:375:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:375:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:375:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:376:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:376:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:376:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:376:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, const char&>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:378:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:378:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:378:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:378:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:379:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:379:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:379:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:379:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:380:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:380:26: note: instantiated from:
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:380:5: error: type name requires a specifier or qualifier
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:380:5: error: C++ requires a type specifier for all declarations
    static_assert((!std::is_explicitly_convertible<const char*, char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:381:5: error: no member named 'is_explicitly_convertible' in namespace 'std'
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_explicitly_convertible.pass.cpp:381:26: note: instantiated from:
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
                    ~~~~~^
is_explicitly_convertible.pass.cpp:381:5: error: type name requires a specifier or qualifier
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_explicitly_convertible.pass.cpp:381:5: error: C++ requires a type specifier for all declarations
    static_assert(( std::is_explicitly_convertible<const char*, const char*>::value), "");
    ^
In file included from is_explicitly_convertible.pass.cpp:28:
In file included from ../../../../include/type_traits:140:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
774 diagnostics generated.
is_explicitly_convertible.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.rel
passed 2 tests in /test/utilities/meta/meta.rel
passed 1 tests in /test/utilities/meta/meta.rqmts
passed 1 tests in /test/utilities/meta/meta.trans
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.arr
passed 6 tests in /test/utilities/meta/meta.trans/meta.trans.cv
aligned_storage.pass.cpp:39:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 12, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:49:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:50:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:54:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:55:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:59:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:60:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:64:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:65:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:69:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:70:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 64, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:74:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:75:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:84:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:89:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 2, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:90:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:94:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:99:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:100:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:104:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 4, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:105:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 8, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:109:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:114:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:115:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == (sizeof(long) == 4 ? 12 : 16), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:119:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:120:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:124:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:129:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == 16, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:130:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == 32, "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:134:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(std::alignment_of<T1>::value == (sizeof(long) == 4 ? 4 : 8), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
aligned_storage.pass.cpp:135:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(sizeof(T1) == (sizeof(long) == 4 ? 12 : 16), "");
    ^
In file included from aligned_storage.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
66 diagnostics generated.
aligned_storage.pass.cpp failed to compile
underlying_type.pass.cpp:32:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:32:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^
underlying_type.pass.cpp:32:60: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
                                                           ^
underlying_type.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^
underlying_type.pass.cpp:32:60: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
                                                           ^
underlying_type.pass.cpp:32:5: error: expected ')'
underlying_type.pass.cpp:32:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^
underlying_type.pass.cpp:32:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
                  ^
underlying_type.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<int>::type, int>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:33:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:33:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^
underlying_type.pass.cpp:33:61: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
                                                            ^
underlying_type.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^
underlying_type.pass.cpp:33:61: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
                                                            ^
underlying_type.pass.cpp:33:5: error: expected ')'
underlying_type.pass.cpp:33:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^
underlying_type.pass.cpp:33:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
                  ^
underlying_type.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<char>::type, char>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:35:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:35:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:35:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^
underlying_type.pass.cpp:35:69: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
                                                                    ^
underlying_type.pass.cpp:35:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^
underlying_type.pass.cpp:35:69: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
                                                                    ^
underlying_type.pass.cpp:35:5: error: expected ')'
underlying_type.pass.cpp:35:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^
underlying_type.pass.cpp:35:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
                  ^
underlying_type.pass.cpp:35:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:35:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<double, char>::type, double>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:36:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:36:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:36:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^
underlying_type.pass.cpp:36:68: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
                                                                   ^
underlying_type.pass.cpp:36:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^
underlying_type.pass.cpp:36:68: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
                                                                   ^
underlying_type.pass.cpp:36:5: error: expected ')'
underlying_type.pass.cpp:36:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^
underlying_type.pass.cpp:36:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
                  ^
underlying_type.pass.cpp:36:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:36:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<short, char>::type, int>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:38:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:38:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:38:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^
underlying_type.pass.cpp:38:80: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
                                                                               ^
underlying_type.pass.cpp:38:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^
underlying_type.pass.cpp:38:80: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
                                                                               ^
underlying_type.pass.cpp:38:5: error: expected ')'
underlying_type.pass.cpp:38:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^
underlying_type.pass.cpp:38:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
                  ^
underlying_type.pass.cpp:38:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:38:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<double, char, long long>::type, double>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:39:5: error: no member named 'underlying_type' in namespace 'std'
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
underlying_type.pass.cpp:39:38: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
                                ~~~~~^
underlying_type.pass.cpp:39:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^
underlying_type.pass.cpp:39:82: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
                                                                                 ^
underlying_type.pass.cpp:39:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^
underlying_type.pass.cpp:39:82: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
                                                                                 ^
underlying_type.pass.cpp:39:5: error: expected ')'
underlying_type.pass.cpp:39:5: note: to match this '('
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^
underlying_type.pass.cpp:39:19: note: instantiated from:
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
                  ^
underlying_type.pass.cpp:39:5: error: type name requires a specifier or qualifier
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
underlying_type.pass.cpp:39:5: error: C++ requires a type specifier for all declarations
    static_assert((std::is_same<std::underlying_type<unsigned, char, long long>::type, long long>::value), "");
    ^
In file included from underlying_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
42 diagnostics generated.
underlying_type.pass.cpp failed to compile
failed 2 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 5 tests in /test/utilities/meta/meta.trans/meta.trans.other
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.ptr
passed 3 tests in /test/utilities/meta/meta.trans/meta.trans.ref
passed 2 tests in /test/utilities/meta/meta.trans/meta.trans.sign
passed 1 tests in /test/utilities/meta/meta.type.synop
passed 1 tests in /test/utilities/meta/meta.unary
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:51:5: note: in instantiation of function template specialization 'test_union_imp<Union>' requested here
    test_union_imp<T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:52:5: note: in instantiation of function template specialization 'test_union_imp<Union const>' requested here
    test_union_imp<const T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:53:5: note: in instantiation of function template specialization 'test_union_imp<Union volatile>' requested here
    test_union_imp<volatile T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_union<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
union.pass.cpp:54:5: note: in instantiation of function template specialization 'test_union_imp<Union const volatile>' requested here
    test_union_imp<const volatile T>();
    ^
union.pass.cpp:65:5: note: in instantiation of function template specialization 'test_union<Union>' requested here
    test_union<Union>();
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
union.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::is_class<T>::value, "");
    ^
In file included from union.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
24 diagnostics generated.
union.pass.cpp failed to compile
failed 1 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 12 tests in /test/utilities/meta/meta.unary/meta.unary.cat
passed 13 tests in /test/utilities/meta/meta.unary/meta.unary.comp
has_nothrow_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_assign.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Union>' requested here
    test_has_nothrow_assign<Union>();
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_assign.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Abstract>' requested here
    test_has_nothrow_assign<Abstract>();
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_assign.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<Empty>' requested here
    test_has_nothrow_assign<Empty>();
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_assign.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<NotEmpty>' requested here
    test_has_nothrow_assign<NotEmpty>();
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_assign.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_assign<bit_zero>' requested here
    test_has_nothrow_assign<bit_zero>();
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_assign<volatile T>::value, "");
    ^
In file included from has_nothrow_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
25 diagnostics generated.
has_nothrow_assign.pass.cpp failed to compile
has_nothrow_copy_constructor.pass.cpp:42:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:78:5: note: in instantiation of function template specialization 'test_has_not_nothrow_copy_constructor<int &>' requested here
    test_has_not_nothrow_copy_constructor<int&>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Union>' requested here
    test_has_nothrow_copy_constructor<Union>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Abstract>' requested here
    test_has_nothrow_copy_constructor<Abstract>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<Empty>' requested here
    test_has_nothrow_copy_constructor<Empty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<NotEmpty>' requested here
    test_has_nothrow_copy_constructor<NotEmpty>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_copy_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_copy_constructor<bit_zero>' requested here
    test_has_nothrow_copy_constructor<bit_zero>();
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
54 diagnostics generated.
has_nothrow_copy_constructor.pass.cpp failed to compile
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Union>' requested here
    test_has_nothrow_default_constructor<Union>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Abstract>' requested here
    test_has_nothrow_default_constructor<Abstract>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<Empty>' requested here
    test_has_nothrow_default_constructor<Empty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<NotEmpty>' requested here
    test_has_nothrow_default_constructor<NotEmpty>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_nothrow_default_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_nothrow_default_constructor<bit_zero>' requested here
    test_has_nothrow_default_constructor<bit_zero>();
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_nothrow_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_nothrow_default_constructor<const volatile T>::value, "");
    ^
In file included from has_nothrow_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
45 diagnostics generated.
has_nothrow_default_constructor.pass.cpp failed to compile
has_trivial_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_assign.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Union>' requested here
    test_has_trivial_assign<Union>();
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<volatile T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_assign.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Abstract>' requested here
    test_has_trivial_assign<Abstract>();
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<volatile T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_assign.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_assign<Empty>' requested here
    test_has_trivial_assign<Empty>();
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<volatile T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_assign.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_assign<NotEmpty>' requested here
    test_has_trivial_assign<NotEmpty>();
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<volatile T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_assign.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_assign<bit_zero>' requested here
    test_has_trivial_assign<bit_zero>();
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_assign.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_assign<volatile T>::value, "");
    ^
In file included from has_trivial_assign.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
25 diagnostics generated.
has_trivial_assign.pass.cpp failed to compile
has_trivial_copy_constructor.pass.cpp:42:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:78:5: note: in instantiation of function template specialization 'test_has_not_trivial_copy_constructor<int &>' requested here
    test_has_not_trivial_copy_constructor<int&>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:43:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:44:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:45:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert(!std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Union>' requested here
    test_has_trivial_copy_constructor<Union>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Abstract>' requested here
    test_has_trivial_copy_constructor<Abstract>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<Empty>' requested here
    test_has_trivial_copy_constructor<Empty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<NotEmpty>' requested here
    test_has_trivial_copy_constructor<NotEmpty>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_copy_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_copy_constructor<bit_zero>' requested here
    test_has_trivial_copy_constructor<bit_zero>();
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_copy_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_copy_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_copy_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
54 diagnostics generated.
has_trivial_copy_constructor.pass.cpp failed to compile
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:80:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Union>' requested here
    test_has_trivial_default_constructor<Union>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:81:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Abstract>' requested here
    test_has_trivial_default_constructor<Abstract>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<Empty>' requested here
    test_has_trivial_default_constructor<Empty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<NotEmpty>' requested here
    test_has_trivial_default_constructor<NotEmpty>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_default_constructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_default_constructor<bit_zero>' requested here
    test_has_trivial_default_constructor<bit_zero>();
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_default_constructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_default_constructor<const volatile T>::value, "");
    ^
In file included from has_trivial_default_constructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
45 diagnostics generated.
has_trivial_default_constructor.pass.cpp failed to compile
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:82:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Union>' requested here
    test_has_trivial_destructor<Union>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:83:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<Empty>' requested here
    test_has_trivial_destructor<Empty>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_trivial_destructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_trivial_destructor<bit_zero>' requested here
    test_has_trivial_destructor<bit_zero>();
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_trivial_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_trivial_destructor<const volatile T>::value, "");
    ^
In file included from has_trivial_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
27 diagnostics generated.
has_trivial_destructor.pass.cpp failed to compile
has_virtual_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:89:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<Abstract>' requested here
    test_has_virtual_destructor<Abstract>();
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:33:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
has_virtual_destructor.pass.cpp:90:5: note: in instantiation of function template specialization 'test_has_virtual_destructor<NotEmpty>' requested here
    test_has_virtual_destructor<NotEmpty>();
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:35:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
has_virtual_destructor.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::has_virtual_destructor<const volatile T>::value, "");
    ^
In file included from has_virtual_destructor.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
18 diagnostics generated.
has_virtual_destructor.pass.cpp failed to compile
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:676:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:687:54: note: in instantiation of template class 'std::__is_empty1<Union>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:691:40: note: in instantiation of template class 'std::__yuga_empty<Union, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:42:5: note: in instantiation of template class 'std::is_empty<Union>' requested here
    static_assert(!std::is_empty<T>::value, "");
    ^
is_empty.pass.cpp:42:20: note: instantiated from:
    static_assert(!std::is_empty<T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:676:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:687:54: note: in instantiation of template class 'std::__is_empty1<Union const>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:691:40: note: in instantiation of template class 'std::__yuga_empty<Union const, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:43:5: note: in instantiation of template class 'std::is_empty<Union const>' requested here
    static_assert(!std::is_empty<const T>::value, "");
    ^
is_empty.pass.cpp:43:20: note: instantiated from:
    static_assert(!std::is_empty<const T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:676:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:687:54: note: in instantiation of template class 'std::__is_empty1<Union volatile>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:691:40: note: in instantiation of template class 'std::__yuga_empty<Union volatile, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:44:5: note: in instantiation of template class 'std::is_empty<Union volatile>' requested here
    static_assert(!std::is_empty<volatile T>::value, "");
    ^
is_empty.pass.cpp:44:20: note: instantiated from:
    static_assert(!std::is_empty<volatile T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
In file included from is_empty.pass.cpp:28:
../../../../../include/type_traits:676:7: error: unions cannot be base classes
    : public _Tp
      ^~~~~~~~~~
../../../../../include/type_traits:687:54: note: in instantiation of template class 'std::__is_empty1<Union const volatile>' requested here
struct __yuga_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};
                                                     ^
../../../../../include/type_traits:691:40: note: in instantiation of template class 'std::__yuga_empty<Union const volatile, 1>' requested here
template <class _Tp> struct is_empty : public __yuga_empty<_Tp> {};
                                       ^
is_empty.pass.cpp:45:5: note: in instantiation of template class 'std::is_empty<Union const volatile>' requested here
    static_assert(!std::is_empty<const volatile T>::value, "");
    ^
is_empty.pass.cpp:45:20: note: instantiated from:
    static_assert(!std::is_empty<const volatile T>::value, "");
                   ^
is_empty.pass.cpp:74:5: note: in instantiation of function template specialization 'test_is_not_empty<Union>' requested here
    test_is_not_empty<Union>();
    ^
20 diagnostics generated.
is_empty.pass.cpp failed to compile
is_literal_type.pass.cpp:32:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_literal_type<int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:33:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert( std::is_literal_type<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:33:25: note: instantiated from:
    static_assert( std::is_literal_type<const int>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_literal_type<const int>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:34:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_literal_type<int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:35:5: error: no member named 'is_literal_type' in namespace 'std'
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_literal_type.pass.cpp:35:25: note: instantiated from:
    static_assert(!std::is_literal_type<volatile int&>::value, "");
                   ~~~~~^
is_literal_type.pass.cpp:35:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_literal_type.pass.cpp:35:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_literal_type<volatile int&>::value, "");
    ^
In file included from is_literal_type.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
12 diagnostics generated.
is_literal_type.pass.cpp failed to compile
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:60:5: note: in instantiation of function template specialization 'test_is_pod<int>' requested here
    test_is_pod<int>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:61:5: note: in instantiation of function template specialization 'test_is_pod<double>' requested here
    test_is_pod<double>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:62:5: note: in instantiation of function template specialization 'test_is_pod<int *>' requested here
    test_is_pod<int*>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:63:5: note: in instantiation of function template specialization 'test_is_pod<int const *>' requested here
    test_is_pod<const int*>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:34:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
is_pod.pass.cpp:64:5: note: in instantiation of function template specialization 'test_is_pod<char [3]>' requested here
    test_is_pod<char[3]>();
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
is_pod.pass.cpp:36:5: error: implicit instantiation of undefined template '__static_assert_test<0>'
    static_assert( std::is_pod<const volatile T>::value, "");
    ^
In file included from is_pod.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:35: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                  ^
../../../../../include/__yuga_config:138:24: note: template is declared here
template <bool> struct __static_assert_test;
                       ^
25 diagnostics generated.
is_pod.pass.cpp failed to compile
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:695:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:700:38: note: in instantiation of template class 'std::__is_polymorphic1<Union>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:704:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:42:5: note: in instantiation of template class 'std::is_polymorphic<Union>' requested here
    static_assert(!std::is_polymorphic<T>::value, "");
    ^
is_polymorphic.pass.cpp:42:20: note: instantiated from:
    static_assert(!std::is_polymorphic<T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:695:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:700:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:704:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union const, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:43:5: note: in instantiation of template class 'std::is_polymorphic<Union const>' requested here
    static_assert(!std::is_polymorphic<const T>::value, "");
    ^
is_polymorphic.pass.cpp:43:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:695:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:700:38: note: in instantiation of template class 'std::__is_polymorphic1<Union volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:704:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:44:5: note: in instantiation of template class 'std::is_polymorphic<Union volatile>' requested here
    static_assert(!std::is_polymorphic<volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:44:20: note: instantiated from:
    static_assert(!std::is_polymorphic<volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
In file included from is_polymorphic.pass.cpp:28:
../../../../../include/type_traits:695:49: error: unions cannot be base classes
template <class _Tp> struct __is_polymorphic1 : public _Tp {};
                                                ^~~~~~~~~~
../../../../../include/type_traits:700:38: note: in instantiation of template class 'std::__is_polymorphic1<Union const volatile>' requested here
    : public integral_constant<bool, sizeof(__is_polymorphic1<_Tp>) == sizeof(__is_polymorphic2<_Tp>)> {};
                                     ^
../../../../../include/type_traits:704:46: note: in instantiation of template class 'std::__yuga_polymorphic<Union const volatile, 1>' requested here
template <class _Tp> struct is_polymorphic : public __yuga_polymorphic<_Tp> {};
                                             ^
is_polymorphic.pass.cpp:45:5: note: in instantiation of template class 'std::is_polymorphic<Union const volatile>' requested here
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
    ^
is_polymorphic.pass.cpp:45:20: note: instantiated from:
    static_assert(!std::is_polymorphic<const volatile T>::value, "");
                   ^
is_polymorphic.pass.cpp:79:5: note: in instantiation of function template specialization 'test_is_not_polymorphic<Union>' requested here
    test_is_not_polymorphic<Union>();
    ^
20 diagnostics generated.
is_polymorphic.pass.cpp failed to compile
is_standard_layout.pass.cpp:32:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert( std::is_standard_layout<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_standard_layout<int>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_standard_layout<int>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:33:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:33:25: note: instantiated from:
    static_assert(!std::is_standard_layout<int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:34:5: error: no member named 'is_standard_layout' in namespace 'std'
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_standard_layout.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
                   ~~~~~^
is_standard_layout.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_standard_layout.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_standard_layout<volatile int&>::value, "");
    ^
In file included from is_standard_layout.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 diagnostics generated.
is_standard_layout.pass.cpp failed to compile
is_trivial.pass.cpp:32:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert( std::is_trivial<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:32:25: note: instantiated from:
    static_assert( std::is_trivial<int>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:32:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:32:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivial<int>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:33:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:33:25: note: instantiated from:
    static_assert(!std::is_trivial<int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:33:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:33:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:34:5: error: no member named 'is_trivial' in namespace 'std'
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivial.pass.cpp:34:25: note: instantiated from:
    static_assert(!std::is_trivial<volatile int&>::value, "");
                   ~~~~~^
is_trivial.pass.cpp:34:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivial.pass.cpp:34:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivial<volatile int&>::value, "");
    ^
In file included from is_trivial.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
9 diagnostics generated.
is_trivial.pass.cpp failed to compile
is_trivialially_copyable.pass.cpp:44:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:44:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:44:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:44:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:45:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:45:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const int>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:45:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:45:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const int>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:46:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:46:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<int&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:46:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:46:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<int&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:47:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:47:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:47:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:47:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:48:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:48:25: note: instantiated from:
    static_assert( std::is_trivially_copyable<const A>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:48:5: error: type name requires a specifier or qualifier
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:48:5: error: C++ requires a type specifier for all declarations
    static_assert( std::is_trivially_copyable<const A>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:49:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:49:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:49:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:49:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<const A&>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:50:5: error: no member named 'is_trivially_copyable' in namespace 'std'
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
is_trivialially_copyable.pass.cpp:50:25: note: instantiated from:
    static_assert(!std::is_trivially_copyable<B>::value, "");
                   ~~~~~^
is_trivialially_copyable.pass.cpp:50:5: error: type name requires a specifier or qualifier
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
is_trivialially_copyable.pass.cpp:50:5: error: C++ requires a type specifier for all declarations
    static_assert(!std::is_trivially_copyable<B>::value, "");
    ^
In file included from is_trivialially_copyable.pass.cpp:28:
In file included from ../../../../../include/type_traits:140:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
21 diagnostics generated.
is_trivialially_copyable.pass.cpp failed to compile
failed 15 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 10 tests in /test/utilities/meta/meta.unary/meta.unary.prop
passed 1 tests in /test/utilities/ratio
passed 8 tests in /test/utilities/ratio/ratio.arithmetic
passed 6 tests in /test/utilities/ratio/ratio.comparison
passed 4 tests in /test/utilities/ratio/ratio.ratio
passed 1 tests in /test/utilities/ratio/ratio.si
passed 1 tests in /test/utilities/template.bitset
passed 4 tests in /test/utilities/template.bitset/bitset.cons
passed 26 tests in /test/utilities/template.bitset/bitset.members
./testit: line 96: 49978 Abort trap              ./a.out
stream_in.pass.cpp failed at run time
./testit: line 96: 49985 Abort trap              ./a.out
stream_out.pass.cpp failed at run time
failed 2 tests in /test/utilities/template.bitset/bitset.operators
passed 3 tests in /test/utilities/template.bitset/bitset.operators
passed 6 tests in /test/utilities/time
passed 1 tests in /test/utilities/time/time.clock
passed 2 tests in /test/utilities/time/time.clock/time.clock.hires
passed 2 tests in /test/utilities/time/time.clock/time.clock.monotonic
passed 5 tests in /test/utilities/time/time.clock/time.clock.system
passed 1 tests in /test/utilities/time/time.clock.req
passed 5 tests in /test/utilities/time/time.duration
passed 12 tests in /test/utilities/time/time.duration/time.duration.arithmetic
passed 2 tests in /test/utilities/time/time.duration/time.duration.cast
passed 2 tests in /test/utilities/time/time.duration/time.duration.comparisons
passed 11 tests in /test/utilities/time/time.duration/time.duration.cons
passed 11 tests in /test/utilities/time/time.duration/time.duration.nonmember
passed 1 tests in /test/utilities/time/time.duration/time.duration.observer
passed 3 tests in /test/utilities/time/time.duration/time.duration.special
passed 2 tests in /test/utilities/time/time.point
passed 2 tests in /test/utilities/time/time.point/time.point.arithmetic
passed 2 tests in /test/utilities/time/time.point/time.point.cast
passed 4 tests in /test/utilities/time/time.point/time.point.comparisons
passed 5 tests in /test/utilities/time/time.point/time.point.cons
passed 3 tests in /test/utilities/time/time.point/time.point.nonmember
passed 1 tests in /test/utilities/time/time.point/time.point.observer
passed 2 tests in /test/utilities/time/time.point/time.point.special
passed 1 tests in /test/utilities/time/time.traits
passed 3 tests in /test/utilities/time/time.traits/time.traits.duration_values
passed 1 tests in /test/utilities/time/time.traits/time.traits.is_fp
passed 2 tests in /test/utilities/time/time.traits/time.traits.specializations
passed 1 tests in /test/utilities/tuple
passed 1 tests in /test/utilities/tuple/tuple.general
empty_member.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, A> T;
                ~~~~~^
empty_member.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int, A> T;
                          ^
empty_member.pass.cpp:40:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:40:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int> T;
                ~~~~~^
empty_member.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<A, int> T;
                          ^
empty_member.pass.cpp:44:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:44:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, int, B> T;
                ~~~~~^
empty_member.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<A, int, B> T;
                          ^
empty_member.pass.cpp:48:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:48:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:48:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:48:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<A, B, int> T;
                ~~~~~^
empty_member.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<A, B, int> T;
                          ^
empty_member.pass.cpp:52:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:52:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:52:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:52:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, A, B> T;
                ~~~~~^
empty_member.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, A, B> T;
                          ^
empty_member.pass.cpp:56:9: error: use of undeclared identifier 'T'
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
empty_member.pass.cpp:56:31: note: instantiated from:
        static_assert((sizeof(T) == sizeof(int)), "");
                              ^
empty_member.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
empty_member.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((sizeof(T) == sizeof(int)), "");
        ^
In file included from empty_member.pass.cpp:30:
In file included from ../../../../include/tuple:133:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
25 diagnostics generated.
empty_member.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple
const_pair.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:41:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
const_pair.pass.cpp:42:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
const_pair.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:44:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
6 diagnostics generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:53:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:54:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:55:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:61:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:63:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_copy.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_copy.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_copy.pass.cpp:70:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_copy.pass.cpp:71:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_copy.pass.cpp:72:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:73:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:74:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:75:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_copy.pass.cpp:80:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_copy.pass.cpp:80:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_copy.pass.cpp:81:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_copy.pass.cpp:81:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_copy.pass.cpp:82:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d2);
        ^
convert_copy.pass.cpp:83:9: error: use of undeclared identifier 'T1'
        T1 t1(1.5, 'b', d);
        ^
convert_copy.pass.cpp:84:9: error: use of undeclared identifier 't1'
        t1 = t0;
        ^
convert_copy.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:85:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:86:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:87:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
37 diagnostics generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:56:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:57:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:58:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:64:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:65:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:66:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:68:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_move.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_move.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_move.pass.cpp:73:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_move.pass.cpp:74:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:75:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:76:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:77:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:77:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:78:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_move.pass.cpp:83:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_move.pass.cpp:83:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_move.pass.cpp:84:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_move.pass.cpp:84:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_move.pass.cpp:85:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d2);
        ^
convert_move.pass.cpp:86:9: error: use of undeclared identifier 'T1'
        T1 t1(1.5, 'b', d);
        ^
convert_move.pass.cpp:87:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:88:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:89:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:90:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:90:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
convert_move.pass.cpp:93:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                ~~~~~^
convert_move.pass.cpp:93:27: error: expected unqualified-id
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                          ^
convert_move.pass.cpp:94:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                ~~~~~^
convert_move.pass.cpp:94:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                          ^
convert_move.pass.cpp:95:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', std::unique_ptr<D>(new D(3)));
        ^
convert_move.pass.cpp:96:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
convert_move.pass.cpp:97:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
convert_move.pass.cpp:98:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:98:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:99:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:99:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:100:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:100:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
47 diagnostics generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:40:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:46:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:51:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:52:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:53:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:55:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int, char, std::string> T;
                          ^
copy.pass.cpp:59:9: error: use of undeclared identifier 'T'
        T t0(2, 'a', "some text");
        ^
copy.pass.cpp:60:9: error: use of undeclared identifier 'T'
        T t;
        ^
copy.pass.cpp:61:9: error: use of undeclared identifier 't'
        t = t0;
        ^
copy.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:62:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:63:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:63:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "some text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:64:21: note: instantiated from:
        assert(std::get<2>(t) == "some text");
               ~~~~~^
26 diagnostics generated.
copy.pass.cpp failed to compile
move.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:41:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:47:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:52:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:54:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:55:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:56:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:60:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
move.pass.cpp:61:9: error: use of undeclared identifier 'T'
        T t;
        ^
move.pass.cpp:62:9: error: use of undeclared identifier 't'
        t = std::move(t0);
        ^
move.pass.cpp:63:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:63:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:65:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
26 diagnostics generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:55:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:58:9: error: use of undeclared identifier 'T1'
        T1 t1;
        ^
move_pair.pass.cpp:59:9: error: use of undeclared identifier 't1'
        t1 = std::move(t0);
        ^
move_pair.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:60:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:61:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:57:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
16 diagnostics generated.
move_pair.pass.cpp failed to compile
failed 6 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.assign
UTypes.pass.cpp:39:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:40:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:40:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:43:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t(MoveOnly(0), MoveOnly(1));
        ~~~~~^
UTypes.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:44:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:45:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:48:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:53:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
UTypes.pass.cpp:57:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0),
        ~~~~~^
UTypes.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
UTypes.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(MoveOnly(0));
        ~~~~~^
UTypes.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
UTypes.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == MoveOnly());
               ~~~~~^
UTypes.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
UTypes.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
17 diagnostics generated.
UTypes.pass.cpp failed to compile
In file included from alloc.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:45:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc.pass.cpp:49:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly> t(std::allocator_arg, A1<int>());
        ~~~~~^
alloc.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:54:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_first> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:60:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_last> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:62:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_last());
               ~~~~~^
alloc.pass.cpp:66:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first> t(std::allocator_arg, A1<int>(5));
        ~~~~~^
alloc.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:69:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:74:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:76:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:78:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:80:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last());
               ~~~~~^
alloc.pass.cpp:85:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<DefaultOnly, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:87:21: note: instantiated from:
        assert(std::get<0>(t) == DefaultOnly());
               ~~~~~^
alloc.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:89:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first());
               ~~~~~^
alloc.pass.cpp:91:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc.pass.cpp:91:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last());
               ~~~~~^
62 diagnostics generated.
alloc.pass.cpp failed to compile
In file included from alloc_UTypes.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_UTypes.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_UTypes.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly> t(std::allocator_arg, A1<int>(), MoveOnly(0));
        ~~~~~^
alloc_UTypes.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(),
        ~~~~~^
alloc_UTypes.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:49:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:52:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:55:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:56:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:57:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
alloc_UTypes.pass.cpp:62:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_UTypes.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_UTypes.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:68:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
alloc_UTypes.pass.cpp:72:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:74:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:75:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_UTypes.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:76:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
alloc_UTypes.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, MoveOnly> t(std::allocator_arg, A1<int>(), 
        ~~~~~^
alloc_UTypes.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:81:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_UTypes.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:82:21: note: instantiated from:
        assert(std::get<1>(t) == MoveOnly());
               ~~~~~^
alloc_UTypes.pass.cpp:83:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == MoveOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_UTypes.pass.cpp:83:21: note: instantiated from:
        assert(std::get<2>(t) == MoveOnly());
               ~~~~~^
63 diagnostics generated.
alloc_UTypes.pass.cpp failed to compile
In file included from alloc_const_Types.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_Types.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_const_Types.pass.cpp:41:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(std::allocator_arg, A1<int>(), 3);
        ~~~~~^
alloc_const_Types.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
alloc_const_Types.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_first> t(std::allocator_arg, A1<int>(5), alloc_first(3));
        ~~~~~^
alloc_const_Types.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_first(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_first(3));
               ~~~~~^
alloc_const_Types.pass.cpp:52:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<alloc_last> t(std::allocator_arg, A1<int>(5), alloc_last(3));
        ~~~~~^
alloc_const_Types.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t) == alloc_last(3));
               ~~~~~^
alloc_const_Types.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first> t(std::allocator_arg, A1<int>(5),
        ~~~~~^
alloc_const_Types.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 10);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:60:21: note: instantiated from:
        assert(std::get<0>(t) == 10);
               ~~~~~^
alloc_const_Types.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(15));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:62:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(15));
               ~~~~~^
alloc_const_Types.pass.cpp:67:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_const_Types.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:70:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_const_Types.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:72:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_const_Types.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:74:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
alloc_const_Types.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, alloc_first, alloc_last> t(std::allocator_arg,
        ~~~~~^
alloc_const_Types.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:82:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_const_Types.pass.cpp:84:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == alloc_first(2));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:84:21: note: instantiated from:
        assert(std::get<1>(t) == alloc_first(2));
               ~~~~~^
alloc_const_Types.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == alloc_last(3));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_Types.pass.cpp:86:21: note: instantiated from:
        assert(std::get<2>(t) == alloc_last(3));
               ~~~~~^
59 diagnostics generated.
alloc_const_Types.pass.cpp failed to compile
In file included from alloc_const_pair.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_const_pair.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_const_pair.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
alloc_const_pair.pass.cpp:45:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:47:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_const_pair.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, double> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, double> T1;
                          ^
alloc_const_pair.pass.cpp:54:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:57:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_const_pair.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T1;
                ~~~~~^
alloc_const_pair.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T1;
                          ^
alloc_const_pair.pass.cpp:65:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_const_pair.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:68:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_const_pair.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_const_pair.pass.cpp:69:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
57 diagnostics generated.
alloc_const_pair.pass.cpp failed to compile
In file included from alloc_convert_copy.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_copy.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_convert_copy.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
alloc_convert_copy.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
alloc_convert_copy.pass.cpp:43:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
alloc_convert_copy.pass.cpp:44:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(), t0);
        ^
alloc_convert_copy.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<int> T0;
                          ^
alloc_convert_copy.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T1;
                          ^
alloc_convert_copy.pass.cpp:50:9: error: use of undeclared identifier 'T0'
        T0 t0(2);
        ^
alloc_convert_copy.pass.cpp:52:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<int, int> T0;
                          ^
alloc_convert_copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T1;
                          ^
alloc_convert_copy.pass.cpp:59:9: error: use of undeclared identifier 'T0'
        T0 t0(2, 3);
        ^
alloc_convert_copy.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t1) == 3);
               ~~~~~^
alloc_convert_copy.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, int, int> T0;
                ~~~~~^
alloc_convert_copy.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<double, int, int> T0;
                          ^
alloc_convert_copy.pass.cpp:70:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, alloc_first, alloc_last> T1;
                ~~~~~^
alloc_convert_copy.pass.cpp:70:27: error: expected unqualified-id
        typedef std::tuple<int, alloc_first, alloc_last> T1;
                          ^
alloc_convert_copy.pass.cpp:71:9: error: use of undeclared identifier 'T0'
        T0 t0(1.5, 2, 3);
        ^
alloc_convert_copy.pass.cpp:74:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_convert_copy.pass.cpp:77:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:77:21: note: instantiated from:
        assert(std::get<0>(t1) == 1);
               ~~~~~^
alloc_convert_copy.pass.cpp:78:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:78:21: note: instantiated from:
        assert(std::get<1>(t1) == 2);
               ~~~~~^
alloc_convert_copy.pass.cpp:79:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_copy.pass.cpp:79:21: note: instantiated from:
        assert(std::get<2>(t1) == 3);
               ~~~~~^
73 diagnostics generated.
alloc_convert_copy.pass.cpp failed to compile
In file included from alloc_convert_move.pass.cpp:37:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_convert_move.pass.cpp:38:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_convert_move.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int> T0;
                          ^
alloc_convert_move.pass.cpp:59:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:59:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T1;
                          ^
alloc_convert_move.pass.cpp:60:9: error: use of undeclared identifier 'T0'
        T0 t0(2);
        ^
alloc_convert_move.pass.cpp:62:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:67:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:67:27: error: expected unqualified-id
        typedef std::tuple<std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:69:9: error: use of undeclared identifier 'T0'
        T0 t0(std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:70:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:71:21: note: instantiated from:
        assert(std::get<0>(t1)->id_ == 3);
               ~~~~~^
alloc_convert_move.pass.cpp:74:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:74:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:75:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:75:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:76:9: error: use of undeclared identifier 'T0'
        T0 t0(2, std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:78:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
alloc_convert_move.pass.cpp:84:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<D>> T0;
                ~~~~~^
alloc_convert_move.pass.cpp:84:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<D>> T0;
                          ^
alloc_convert_move.pass.cpp:85:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last, alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_convert_move.pass.cpp:85:27: error: expected unqualified-id
        typedef std::tuple<alloc_last, alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_convert_move.pass.cpp:86:9: error: use of undeclared identifier 'T0'
        T0 t0(1, 2, std::unique_ptr<D>(new D(3)));
        ^
alloc_convert_move.pass.cpp:89:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_convert_move.pass.cpp:92:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:92:21: note: instantiated from:
        assert(std::get<0>(t1) == 1);
               ~~~~~^
alloc_convert_move.pass.cpp:93:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:93:21: note: instantiated from:
        assert(std::get<1>(t1) == 2);
               ~~~~~^
alloc_convert_move.pass.cpp:94:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_convert_move.pass.cpp:94:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
73 diagnostics generated.
alloc_convert_move.pass.cpp failed to compile
In file included from alloc_copy.pass.cpp:35:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_copy.pass.cpp:36:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_copy.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
alloc_copy.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
alloc_copy.pass.cpp:42:9: error: use of undeclared identifier 'T'
        T t0;
        ^
alloc_copy.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), t0);
        ^
alloc_copy.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
alloc_copy.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
alloc_copy.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:48:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), t0);
        ^
alloc_copy.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T;
                ~~~~~^
alloc_copy.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T;
                          ^
alloc_copy.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:55:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<alloc_last> T;
                          ^
alloc_copy.pass.cpp:61:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
alloc_copy.pass.cpp:63:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, alloc_last> T;
                          ^
alloc_copy.pass.cpp:69:9: error: use of undeclared identifier 'T'
        T t0(2, 3);
        ^
alloc_copy.pass.cpp:72:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:75:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:76:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:76:21: note: instantiated from:
        assert(std::get<1>(t) == 3);
               ~~~~~^
alloc_copy.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, alloc_first, alloc_last> T;
                ~~~~~^
alloc_copy.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, alloc_first, alloc_last> T;
                          ^
alloc_copy.pass.cpp:80:9: error: use of undeclared identifier 'T'
        T t0(1, 2, 3);
        ^
alloc_copy.pass.cpp:83:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), t0);
        ^
alloc_copy.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:86:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_copy.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:87:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
alloc_copy.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_copy.pass.cpp:88:21: note: instantiated from:
        assert(std::get<2>(t) == 3);
               ~~~~~^
74 diagnostics generated.
alloc_copy.pass.cpp failed to compile
In file included from alloc_move.pass.cpp:36:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move.pass.cpp:37:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_move.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
alloc_move.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
alloc_move.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t0;
        ^
alloc_move.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), std::move(t0));
        ^
alloc_move.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
alloc_move.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
alloc_move.pass.cpp:48:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
alloc_move.pass.cpp:49:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(), std::move(t0));
        ^
alloc_move.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_move.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first> T;
                ~~~~~^
alloc_move.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<alloc_first> T;
                          ^
alloc_move.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t0(1);
        ^
alloc_move.pass.cpp:56:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_last> T;
                ~~~~~^
alloc_move.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<alloc_last> T;
                          ^
alloc_move.pass.cpp:62:9: error: use of undeclared identifier 'T'
        T t0(1);
        ^
alloc_move.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:66:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, alloc_first> T;
                ~~~~~^
alloc_move.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, alloc_first> T;
                          ^
alloc_move.pass.cpp:70:9: error: use of undeclared identifier 'T'
        T t0(0 ,1);
        ^
alloc_move.pass.cpp:72:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:74:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
alloc_move.pass.cpp:75:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:75:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:78:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, alloc_first, alloc_last> T;
                ~~~~~^
alloc_move.pass.cpp:78:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, alloc_first, alloc_last> T;
                          ^
alloc_move.pass.cpp:79:9: error: use of undeclared identifier 'T'
        T t0(1, 2, 3);
        ^
alloc_move.pass.cpp:82:9: error: use of undeclared identifier 'T'
        T t(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:85:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
alloc_move.pass.cpp:86:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:86:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
alloc_move.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move.pass.cpp:87:21: note: instantiated from:
        assert(std::get<2>(t) == 3);
               ~~~~~^
74 diagnostics generated.
alloc_move.pass.cpp failed to compile
In file included from alloc_move_pair.pass.cpp:37:
./../alloc_first.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_first.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_first.h:18:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                            ^
./../alloc_first.h:18:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a)
                                              ^
./../alloc_first.h:18:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a)
               ^
./../alloc_first.h:25:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                            ^
./../alloc_first.h:25:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
                                              ^
./../alloc_first.h:25:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
               ^
./../alloc_first.h:25:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:32:45: error: unknown type name 'A1'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                            ^
./../alloc_first.h:32:47: error: expected ')'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
                                              ^
./../alloc_first.h:32:16: note: to match this '('
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
               ^
./../alloc_first.h:32:5: error: constructor cannot be redeclared
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous declaration is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:25:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:18:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a)
    ^
./../alloc_first.h:26:17: error: use of undeclared identifier 'd'
        : data_(d)
                ^
./../alloc_first.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_first.h:32:5: error: redefinition of 'alloc_first'
    alloc_first(std::allocator_arg_t, const A1<int>& a, const alloc_first& d)
    ^
./../alloc_first.h:25:5: note: previous definition is here
    alloc_first(std::allocator_arg_t, const A1<int>& a, int d)
    ^
./../alloc_first.h:33:17: error: use of undeclared identifier 'd'
        : data_(d.data_)
                ^
./../alloc_first.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_first.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
In file included from alloc_move_pair.pass.cpp:38:
./../alloc_last.h:12:13: error: unknown type name 'A1'
    typedef A1<int> allocator_type;
            ^
./../alloc_last.h:12:15: error: expected member name or ';' after declaration specifiers
    typedef A1<int> allocator_type;
    ~~~~~~~~~~^
./../alloc_last.h:18:22: error: unknown type name 'A1'
    alloc_last(const A1<int>& a)
                     ^
./../alloc_last.h:18:24: error: expected ')'
    alloc_last(const A1<int>& a)
                       ^
./../alloc_last.h:18:15: note: to match this '('
    alloc_last(const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: constructor cannot be redeclared
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous declaration is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:25:29: error: unknown type name 'A1'
    alloc_last(int d, const A1<int>& a)
                            ^
./../alloc_last.h:25:31: error: expected ')'
    alloc_last(int d, const A1<int>& a)
                              ^
./../alloc_last.h:25:15: note: to match this '('
    alloc_last(int d, const A1<int>& a)
              ^
./../alloc_last.h:32:43: error: unknown type name 'A1'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                          ^
./../alloc_last.h:32:45: error: expected ')'
    alloc_last(const alloc_last& d, const A1<int>& a)
                                            ^
./../alloc_last.h:32:15: note: to match this '('
    alloc_last(const alloc_last& d, const A1<int>& a)
              ^
./../alloc_last.h:18:5: error: redefinition of 'alloc_last'
    alloc_last(const A1<int>& a)
    ^
./../alloc_last.h:17:5: note: previous definition is here
    alloc_last(int d) : data_(d) {}
    ^
./../alloc_last.h:21:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:21:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:28:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:28:16: note: instantiated from:
        assert(a.id() == 5);
               ^
./../alloc_last.h:35:9: error: use of undeclared identifier 'a'
        assert(a.id() == 5);
        ^
./../alloc_last.h:35:16: note: instantiated from:
        assert(a.id() == 5);
               ^
alloc_move_pair.pass.cpp:59:49: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<int, std::unique_ptr<D>> T0;
                                                ^~
                                                > >
alloc_move_pair.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                ~~~~~^
alloc_move_pair.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<alloc_first, std::unique_ptr<B>> T1;
                          ^
alloc_move_pair.pass.cpp:63:9: error: use of undeclared identifier 'T1'
        T1 t1(std::allocator_arg, A1<int>(5), std::move(t0));
        ^
alloc_move_pair.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move_pair.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
alloc_move_pair.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
alloc_move_pair.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from alloc_move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
alloc_move_pair.pass.cpp:61:12: note: in instantiation of member function 'std::pair<int, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2, std::unique_ptr<D>(new D(3)));
           ^
In file included from alloc_move_pair.pass.cpp:31:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
57 diagnostics generated.
alloc_move_pair.pass.cpp failed to compile
const_Types.pass.cpp:37:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t(2);
        ~~~~~^
const_Types.pass.cpp:38:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:38:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:41:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, 0);
        ~~~~~^
const_Types.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:43:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:51:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr, "text");
        ~~~~~^
const_Types.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:54:21: note: instantiated from:
        assert(std::get<2>(t) == "text");
               ~~~~~^
const_Types.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2);
        ~~~~~^
const_Types.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
const_Types.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t(2, nullptr);
        ~~~~~^
const_Types.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
const_Types.pass.cpp:70:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string, double> t(2, nullptr, "text");
        ~~~~~^
const_Types.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:71:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
const_Types.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:72:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
const_Types.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:73:21: note: instantiated from:
        assert(std::get<2>(t) == "text");
               ~~~~~^
const_Types.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t) == 0.0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_Types.pass.cpp:74:21: note: instantiated from:
        assert(std::get<3>(t) == 0.0);
               ~~~~~^
25 diagnostics generated.
const_Types.pass.cpp failed to compile
const_pair.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, short> T1;
                ~~~~~^
const_pair.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<int, short> T1;
                          ^
const_pair.pass.cpp:40:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
const_pair.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
const_pair.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == short('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
const_pair.pass.cpp:42:21: note: instantiated from:
        assert(std::get<1>(t1) == short('a'));
               ~~~~~^
5 diagnostics generated.
const_pair.pass.cpp failed to compile
convert_copy.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_copy.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_copy.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_copy.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_copy.pass.cpp:52:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_copy.pass.cpp:53:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:54:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:57:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_copy.pass.cpp:57:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_copy.pass.cpp:58:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_copy.pass.cpp:58:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_copy.pass.cpp:59:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_copy.pass.cpp:60:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:61:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:62:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:62:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:65:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_copy.pass.cpp:65:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_copy.pass.cpp:66:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_copy.pass.cpp:66:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_copy.pass.cpp:67:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_copy.pass.cpp:68:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:69:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:70:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:71:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_copy.pass.cpp:75:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_copy.pass.cpp:75:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_copy.pass.cpp:76:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_copy.pass.cpp:76:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_copy.pass.cpp:77:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d);
        ^
convert_copy.pass.cpp:78:9: error: use of undeclared identifier 'T1'
        T1 t1 = t0;
        ^
convert_copy.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_copy.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_copy.pass.cpp:82:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_copy.pass.cpp:82:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
33 diagnostics generated.
convert_copy.pass.cpp failed to compile
convert_move.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T0;
                ~~~~~^
convert_move.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<double> T0;
                          ^
convert_move.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
convert_move.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
convert_move.pass.cpp:55:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5);
        ^
convert_move.pass.cpp:56:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:60:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T0;
                ~~~~~^
convert_move.pass.cpp:60:27: error: expected unqualified-id
        typedef std::tuple<double, char> T0;
                          ^
convert_move.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int> T1;
                ~~~~~^
convert_move.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<int, int> T1;
                          ^
convert_move.pass.cpp:62:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a');
        ^
convert_move.pass.cpp:63:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:64:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:64:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:65:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:68:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D> T0;
                ~~~~~^
convert_move.pass.cpp:68:27: error: expected unqualified-id
        typedef std::tuple<double, char, D> T0;
                          ^
convert_move.pass.cpp:69:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B> T1;
                ~~~~~^
convert_move.pass.cpp:69:27: error: expected unqualified-id
        typedef std::tuple<int, int, B> T1;
                          ^
convert_move.pass.cpp:70:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', D(3));
        ^
convert_move.pass.cpp:71:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:72:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:73:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:74:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 3);
               ~~~~~^
convert_move.pass.cpp:78:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, D&> T0;
                ~~~~~^
convert_move.pass.cpp:78:27: error: expected unqualified-id
        typedef std::tuple<double, char, D&> T0;
                          ^
convert_move.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, B&> T1;
                ~~~~~^
convert_move.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, int, B&> T1;
                          ^
convert_move.pass.cpp:80:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', d);
        ^
convert_move.pass.cpp:81:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:83:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:83:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:84:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:84:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:85:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1).id_ == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:85:21: note: instantiated from:
        assert(std::get<2>(t1).id_ == 2);
               ~~~~~^
convert_move.pass.cpp:88:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                ~~~~~^
convert_move.pass.cpp:88:27: error: expected unqualified-id
        typedef std::tuple<double, char, std::unique_ptr<D>> T0;
                          ^
convert_move.pass.cpp:89:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                ~~~~~^
convert_move.pass.cpp:89:27: error: expected unqualified-id
        typedef std::tuple<int, int, std::unique_ptr<B>> T1;
                          ^
convert_move.pass.cpp:90:9: error: use of undeclared identifier 'T0'
        T0 t0(2.5, 'a', std::unique_ptr<D>(new D(3)));
        ^
convert_move.pass.cpp:91:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
convert_move.pass.cpp:92:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:92:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
convert_move.pass.cpp:93:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == int('a'));
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:93:21: note: instantiated from:
        assert(std::get<1>(t1) == int('a'));
               ~~~~~^
convert_move.pass.cpp:94:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
convert_move.pass.cpp:94:21: note: instantiated from:
        assert(std::get<2>(t1)->id_ == 3);
               ~~~~~^
42 diagnostics generated.
convert_move.pass.cpp failed to compile
copy.pass.cpp:37:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
copy.pass.cpp:37:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
copy.pass.cpp:38:9: error: use of undeclared identifier 'T'
        T t0;
        ^
copy.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:42:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
copy.pass.cpp:42:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
copy.pass.cpp:43:9: error: use of undeclared identifier 'T'
        T t0(2);
        ^
copy.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:45:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:45:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char> T;
                ~~~~~^
copy.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<int, char> T;
                          ^
copy.pass.cpp:49:9: error: use of undeclared identifier 'T'
        T t0(2, 'a');
        ^
copy.pass.cpp:50:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:51:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:51:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:52:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, char, std::string> T;
                ~~~~~^
copy.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, char, std::string> T;
                          ^
copy.pass.cpp:56:9: error: use of undeclared identifier 'T'
        T t0(2, 'a', "some text");
        ^
copy.pass.cpp:57:9: error: use of undeclared identifier 'T'
        T t = t0;
        ^
copy.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
copy.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 'a');
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t) == 'a');
               ~~~~~^
copy.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "some text");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
copy.pass.cpp:60:21: note: instantiated from:
        assert(std::get<2>(t) == "some text");
               ~~~~~^
22 diagnostics generated.
copy.pass.cpp failed to compile
default.pass.cpp:39:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t;
        ~~~~~^
default.pass.cpp:42:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t;
        ~~~~~^
default.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:46:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*> t;
        ~~~~~^
default.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:51:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string> t;
        ~~~~~^
default.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:54:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:57:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, char*, std::string, DefaultOnly> t;
        ~~~~~^
default.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
default.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t) == nullptr);
               ~~~~~^
default.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == "");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:60:21: note: instantiated from:
        assert(std::get<2>(t) == "");
               ~~~~~^
default.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t) == DefaultOnly());
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
default.pass.cpp:61:21: note: instantiated from:
        assert(std::get<3>(t) == DefaultOnly());
               ~~~~~^
15 diagnostics generated.
default.pass.cpp failed to compile
move.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
move.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
move.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
move.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
move.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
move.pass.cpp:44:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
move.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:50:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
move.pass.cpp:51:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
move.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
move.pass.cpp:57:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
move.pass.cpp:58:9: error: use of undeclared identifier 'T'
        T t = std::move(t0);
        ^
move.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 0);
               ~~~~~^
move.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == 1);
               ~~~~~^
move.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
move.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == 2);
               ~~~~~^
22 diagnostics generated.
move.pass.cpp failed to compile
move_pair.pass.cpp:54:52: error: a space is required between consecutive right angle brackets (use '> >')
        typedef std::pair<double, std::unique_ptr<D>> T0;
                                                   ^~
                                                   > >
move_pair.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                ~~~~~^
move_pair.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int, std::unique_ptr<B>> T1;
                          ^
move_pair.pass.cpp:57:9: error: use of undeclared identifier 'T1'
        T1 t1 = std::move(t0);
        ^
move_pair.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t1) == 2);
               ~~~~~^
move_pair.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1)->id_ == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
move_pair.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t1)->id_ == 3);
               ~~~~~^
In file included from move_pair.pass.cpp:30:
In file included from ../../../../../include/tuple:136:
In file included from ../../../../../include/memory:214:
../../../../../include/utility:137:23: error: no matching constructor for initialization of 'std::unique_ptr<D, std::default_delete<D> >'
        : first(__x), second(__y) {}
                      ^      ~~~
move_pair.pass.cpp:56:12: note: in instantiation of member function 'std::pair<double, std::unique_ptr<D, std::default_delete<D> > >::pair' requested here
        T0 t0(2.5, std::unique_ptr<D>(new D(3)));
           ^
In file included from move_pair.pass.cpp:30:
In file included from ../../../../../include/tuple:136:
../../../../../include/memory:2080:5: note: candidate constructor not viable: 1st argument ('std::unique_ptr<D, std::default_delete<D> > const') would lose const qualifier
    unique_ptr(unique_ptr&);
    ^
../../../../../include/memory:2099:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'std::nullptr_t' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(nullptr_t)
                            ^
../../../../../include/memory:2105:38: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to 'pointer' (aka 'D *') for 1st argument
    _YUGA_INLINE_VISIBILITY explicit unique_ptr(pointer __p)
                                     ^
../../../../../include/memory:2191:29: note: candidate constructor not viable: no known conversion from 'std::unique_ptr<D, std::default_delete<D> > const' to '__rv<std::unique_ptr<D, std::default_delete<D> > >' for 1st argument
    _YUGA_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)
                            ^
../../../../../include/memory:2113:33: note: candidate template ignored: failed template argument deduction
        _YUGA_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>& __p,
                                ^
../../../../../include/memory:2093:29: note: candidate constructor not viable: requires 0 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr()
                            ^
../../../../../include/memory:2202:29: note: candidate constructor not viable: requires 2 arguments, but 1 was provided
    _YUGA_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)
                            ^
15 diagnostics generated.
move_pair.pass.cpp failed to compile
failed 18 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
passed 4 tests in /test/utilities/tuple/tuple.tuple/tuple.cnstr
make_tuple.pass.cpp:40:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int&, float&> t = std::make_tuple(1, std::ref(i),
        ~~~~~^
make_tuple.pass.cpp:42:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:42:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:43:21: note: instantiated from:
        assert(std::get<1>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:44:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:44:21: note: instantiated from:
        assert(std::get<2>(t) == 0);
               ~~~~~^
make_tuple.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:47:21: note: instantiated from:
        assert(std::get<0>(t) == 1);
               ~~~~~^
make_tuple.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:48:21: note: instantiated from:
        assert(std::get<1>(t) == 2);
               ~~~~~^
make_tuple.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
make_tuple.pass.cpp:49:21: note: instantiated from:
        assert(std::get<2>(t) == 3.5);
               ~~~~~^
make_tuple.pass.cpp:50:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 0;
        ~~~~~^
make_tuple.pass.cpp:51:14: error: no member named 'get' in namespace 'std'
        std::get<2>(t) = 0;
        ~~~~~^
9 diagnostics generated.
make_tuple.pass.cpp failed to compile
tie.pass.cpp:40:14: error: no member named 'tie' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
        ~~~~~^
tie.pass.cpp:40:26: error: no member named 'ignore' in namespace 'std'
        std::tie(i, std::ignore, s) = std::make_tuple(42, 3.14, "C++");
                    ~~~~~^
2 diagnostics generated.
tie.pass.cpp failed to compile
tuple_cat.pass.cpp:53:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:54:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t2;
        ~~~~~^
tuple_cat.pass.cpp:55:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:58:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:59:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:60:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:61:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:64:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<> t1;
        ~~~~~^
tuple_cat.pass.cpp:65:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:66:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:70:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:71:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:72:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, int> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:73:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:73:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:74:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:74:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:77:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:78:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int> t2(2);
        ~~~~~^
tuple_cat.pass.cpp:79:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, int*> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:80:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:80:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:81:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:81:21: note: instantiated from:
        assert(std::get<1>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:84:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:85:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:86:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, int, double> t3 = std::tuple_cat(t1, t2);
        ~~~~~^
tuple_cat.pass.cpp:87:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:87:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:88:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:88:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:89:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:89:21: note: instantiated from:
        assert(std::get<2>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:92:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*> t1;
        ~~~~~^
tuple_cat.pass.cpp:93:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:94:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double, int*> t3 = std::tuple_cat(t2, t1);
        ~~~~~^
tuple_cat.pass.cpp:95:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:95:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:96:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:96:21: note: instantiated from:
        assert(std::get<1>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:97:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:97:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:100:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t1(nullptr, 1);
        ~~~~~^
tuple_cat.pass.cpp:101:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:102:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly, int, double> t3 =
        ~~~~~^
tuple_cat.pass.cpp:104:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:104:21: note: instantiated from:
        assert(std::get<0>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:105:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:105:21: note: instantiated from:
        assert(std::get<1>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:106:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:106:21: note: instantiated from:
        assert(std::get<2>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:107:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:107:21: note: instantiated from:
        assert(std::get<3>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:110:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t1(nullptr, 1);
        ~~~~~^
tuple_cat.pass.cpp:111:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double> t2(2, 3.5);
        ~~~~~^
tuple_cat.pass.cpp:112:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int, double, int*, MoveOnly> t3 =
        ~~~~~^
tuple_cat.pass.cpp:114:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:114:21: note: instantiated from:
        assert(std::get<0>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:115:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 3.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:115:21: note: instantiated from:
        assert(std::get<1>(t3) == 3.5);
               ~~~~~^
tuple_cat.pass.cpp:116:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:116:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:117:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:117:21: note: instantiated from:
        assert(std::get<3>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:120:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly> t1(1, 2);
        ~~~~~^
tuple_cat.pass.cpp:121:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<int*, MoveOnly> t2(nullptr, 4);
        ~~~~~^
tuple_cat.pass.cpp:122:14: error: no member named 'tuple' in namespace 'std'
        std::tuple<MoveOnly, MoveOnly, int*, MoveOnly> t3 =
        ~~~~~^
tuple_cat.pass.cpp:124:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t3) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:124:21: note: instantiated from:
        assert(std::get<0>(t3) == 1);
               ~~~~~^
tuple_cat.pass.cpp:125:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t3) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:125:21: note: instantiated from:
        assert(std::get<1>(t3) == 2);
               ~~~~~^
tuple_cat.pass.cpp:126:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t3) == nullptr);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:126:21: note: instantiated from:
        assert(std::get<2>(t3) == nullptr);
               ~~~~~^
tuple_cat.pass.cpp:127:9: error: no member named 'get' in namespace 'std'
        assert(std::get<3>(t3) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
tuple_cat.pass.cpp:127:21: note: instantiated from:
        assert(std::get<3>(t3) == 4);
               ~~~~~^
54 diagnostics generated.
tuple_cat.pass.cpp failed to compile
failed 3 tests in /test/utilities/tuple/tuple.tuple/tuple.creation
get_const.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_const.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_const.pass.cpp:40:15: error: unknown type name 'T'
        const T t(3);
              ^
get_const.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_const.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_const.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_const.pass.cpp:45:15: error: unknown type name 'T'
        const T t("high", 5);
              ^
get_const.pass.cpp:45:17: error: excess elements in scalar initializer
        const T t("high", 5);
                ^ ~~~~~~~~~
get_const.pass.cpp:46:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:46:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_const.pass.cpp:47:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:47:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_const.pass.cpp:50:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_const.pass.cpp:50:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_const.pass.cpp:52:15: error: unknown type name 'T'
        const T t(d, "high", 5);
              ^
get_const.pass.cpp:52:17: error: excess elements in scalar initializer
        const T t(d, "high", 5);
                ^ ~~~~~~~~~~~~
get_const.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:53:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
get_const.pass.cpp:54:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:54:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_const.pass.cpp:55:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:55:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
get_const.pass.cpp:56:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2.5;
        ~~~~~^
get_const.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t) == 2.5);
               ~~~~~^
get_const.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:58:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_const.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_const.pass.cpp:59:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
21 diagnostics generated.
get_const.pass.cpp failed to compile
get_non_const.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
get_non_const.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
get_non_const.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t(3);
        ^
get_non_const.pass.cpp:41:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:41:21: note: instantiated from:
        assert(std::get<0>(t) == 3);
               ~~~~~^
get_non_const.pass.cpp:42:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2;
        ~~~~~^
get_non_const.pass.cpp:43:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:43:21: note: instantiated from:
        assert(std::get<0>(t) == 2);
               ~~~~~^
get_non_const.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<std::string, int> T;
                          ^
get_non_const.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t("high", 5);
        ^
get_non_const.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t) == "high");
               ~~~~~^
get_non_const.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:49:21: note: instantiated from:
        assert(std::get<1>(t) == 5);
               ~~~~~^
get_non_const.pass.cpp:50:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = "four";
        ~~~~~^
get_non_const.pass.cpp:51:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = 4;
        ~~~~~^
get_non_const.pass.cpp:52:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == "four");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:52:21: note: instantiated from:
        assert(std::get<0>(t) == "four");
               ~~~~~^
get_non_const.pass.cpp:53:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:53:21: note: instantiated from:
        assert(std::get<1>(t) == 4);
               ~~~~~^
get_non_const.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, std::string, int> T;
                ~~~~~^
get_non_const.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<double&, std::string, int> T;
                          ^
get_non_const.pass.cpp:58:9: error: use of undeclared identifier 'T'
        T t(d, "high", 5);
        ^
get_non_const.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 1.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t) == 1.5);
               ~~~~~^
get_non_const.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "high");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t) == "high");
               ~~~~~^
get_non_const.pass.cpp:61:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:61:21: note: instantiated from:
        assert(std::get<2>(t) == 5);
               ~~~~~^
get_non_const.pass.cpp:62:14: error: no member named 'get' in namespace 'std'
        std::get<0>(t) = 2.5;
        ~~~~~^
get_non_const.pass.cpp:63:14: error: no member named 'get' in namespace 'std'
        std::get<1>(t) = "four";
        ~~~~~^
get_non_const.pass.cpp:64:14: error: no member named 'get' in namespace 'std'
        std::get<2>(t) = 4;
        ~~~~~^
get_non_const.pass.cpp:65:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t) == 2.5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:65:21: note: instantiated from:
        assert(std::get<0>(t) == 2.5);
               ~~~~~^
get_non_const.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t) == "four");
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:66:21: note: instantiated from:
        assert(std::get<1>(t) == "four");
               ~~~~~^
get_non_const.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~
get_non_const.pass.cpp:67:21: note: instantiated from:
        assert(std::get<2>(t) == 4);
               ~~~~~^
27 diagnostics generated.
get_non_const.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
passed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.elem
tuple_element.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_element.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_element.pass.cpp:42:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:43:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:43:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:42:9: error: expected ')'
tuple_element.pass.cpp:42:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:42:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:42:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:42:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:46:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
tuple_element.pass.cpp:46:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
tuple_element.pass.cpp:47:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:48:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:48:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:47:9: error: expected ')'
tuple_element.pass.cpp:47:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:47:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:47:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:47:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:49:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                          ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:50:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:50:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:49:9: error: expected ')'
tuple_element.pass.cpp:49:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:49:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                      ^
tuple_element.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int*, char, int> T;
                ~~~~~^
tuple_element.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<int*, char, int> T;
                          ^
tuple_element.pass.cpp:54:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                          ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                                                              ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:55:44: note: instantiated from:
                                    int*>::value), "");
                                           ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:55:44: note: instantiated from:
                                    int*>::value), "");
                                           ^
tuple_element.pass.cpp:54:9: error: expected ')'
tuple_element.pass.cpp:54:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
tuple_element.pass.cpp:54:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<0, T>::type,
                      ^
tuple_element.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<0, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:56:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                          ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                                                              ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:57:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:57:44: note: instantiated from:
                                    char>::value), "");
                                           ^
tuple_element.pass.cpp:56:9: error: expected ')'
tuple_element.pass.cpp:56:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
tuple_element.pass.cpp:56:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<1, T>::type,
                      ^
tuple_element.pass.cpp:56:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:56:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<1, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:58:9: error: use of undeclared identifier 'T'
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:59: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                          ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                              ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:63: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                                                              ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:59:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:59:43: note: instantiated from:
                                    int>::value), "");
                                          ^
tuple_element.pass.cpp:58:9: error: expected ')'
tuple_element.pass.cpp:58:9: note: to match this '('
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
tuple_element.pass.cpp:58:23: note: instantiated from:
        static_assert((std::is_same<std::tuple_element<2, T>::type,
                      ^
tuple_element.pass.cpp:58:9: error: type name requires a specifier or qualifier
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_element.pass.cpp:58:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_same<std::tuple_element<2, T>::type,
        ^
In file included from tuple_element.pass.cpp:35:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
60 diagnostics generated.
tuple_element.pass.cpp failed to compile
tuple_size.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
tuple_size.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
tuple_size.pass.cpp:39:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:40:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:39:9: error: expected ')'
tuple_size.pass.cpp:39:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
tuple_size.pass.cpp:39:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
                      ^
tuple_size.pass.cpp:39:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:39:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 0>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:43:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
tuple_size.pass.cpp:43:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
tuple_size.pass.cpp:44:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:45:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:44:9: error: expected ')'
tuple_size.pass.cpp:44:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
tuple_size.pass.cpp:44:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
                      ^
tuple_size.pass.cpp:44:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:44:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 1>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
tuple_size.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
tuple_size.pass.cpp:49:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:50:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:49:9: error: expected ')'
tuple_size.pass.cpp:49:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
tuple_size.pass.cpp:49:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
                      ^
tuple_size.pass.cpp:49:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:49:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 2>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, char*, int> T;
                ~~~~~^
tuple_size.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<char, char*, int> T;
                          ^
tuple_size.pass.cpp:54:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:55: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                      ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:58: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                         ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:55:61: note: instantiated from:
                                      std::tuple_size<T> >::value), "");
                                                            ^
tuple_size.pass.cpp:54:9: error: expected ')'
tuple_size.pass.cpp:54:9: note: to match this '('
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
tuple_size.pass.cpp:54:23: note: instantiated from:
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
                      ^
tuple_size.pass.cpp:54:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
tuple_size.pass.cpp:54:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::integral_constant<std::size_t, 3>,
        ^
In file included from tuple_size.pass.cpp:32:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
44 diagnostics generated.
tuple_size.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.helper
begin.pass.cpp:41:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int*, int*> T;
                ~~~~~^
begin.pass.cpp:41:27: error: expected unqualified-id
        typedef std::tuple<int*, int*> T;
                          ^
begin.pass.cpp:43:15: error: unknown type name 'T'
        const T t(std::begin(array), std::end(array));
              ^
begin.pass.cpp:43:17: error: excess elements in scalar initializer
        const T t(std::begin(array), std::end(array));
                ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
4 diagnostics generated.
begin.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.range
eq.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
eq.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
eq.pass.cpp:40:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
eq.pass.cpp:40:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
eq.pass.cpp:41:15: error: unknown type name 'T1'
        const T1 t1;
              ^
eq.pass.cpp:42:15: error: unknown type name 'T2'
        const T2 t2;
              ^
eq.pass.cpp:47:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:47:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:48:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:48:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:49:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:50:15: error: unknown type name 'T2'
        const T2 t2(1.1);
              ^
eq.pass.cpp:55:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T1;
                ~~~~~^
eq.pass.cpp:55:27: error: expected unqualified-id
        typedef std::tuple<int> T1;
                          ^
eq.pass.cpp:56:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
eq.pass.cpp:56:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
eq.pass.cpp:57:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
eq.pass.cpp:58:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
eq.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:64:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:64:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:65:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:65:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:66:15: error: unknown type name 'T2'
        const T2 t2(1, char(2));
              ^
eq.pass.cpp:66:18: error: excess elements in scalar initializer
        const T2 t2(1, char(2));
                 ^  ~~~~~~~~~~
eq.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:73:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:73:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:74:15: error: unknown type name 'T2'
        const T2 t2(1, char(3));
              ^
eq.pass.cpp:74:18: error: excess elements in scalar initializer
        const T2 t2(1, char(3));
                 ^  ~~~~~~~~~~
eq.pass.cpp:79:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:79:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:80:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:80:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:81:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:81:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:82:15: error: unknown type name 'T2'
        const T2 t2(1.1, char(2));
              ^
eq.pass.cpp:82:18: error: excess elements in scalar initializer
        const T2 t2(1.1, char(2));
                 ^  ~~~~~~~~~~~~
eq.pass.cpp:87:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int, double> T1;
                ~~~~~^
eq.pass.cpp:87:27: error: expected unqualified-id
        typedef std::tuple<int, double> T1;
                          ^
eq.pass.cpp:88:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
eq.pass.cpp:88:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
eq.pass.cpp:89:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
eq.pass.cpp:89:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
eq.pass.cpp:90:15: error: unknown type name 'T2'
        const T2 t2(1.1, char(3));
              ^
eq.pass.cpp:90:18: error: excess elements in scalar initializer
        const T2 t2(1.1, char(3));
                 ^  ~~~~~~~~~~~~
eq.pass.cpp:95:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:95:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:96:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:96:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:97:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:97:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:98:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 3);
              ^
eq.pass.cpp:98:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:103:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:103:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:104:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:104:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:105:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:105:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:106:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 3);
              ^
eq.pass.cpp:106:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 3);
                 ^  ~~~~~~~~~
eq.pass.cpp:111:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:111:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:112:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:112:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:113:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:113:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:114:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 3);
              ^
eq.pass.cpp:114:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 3);
                 ^  ~~~~~~~
eq.pass.cpp:119:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:119:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:120:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:120:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:121:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:121:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:122:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 4);
              ^
eq.pass.cpp:122:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 4);
                 ^  ~~~~~~~
eq.pass.cpp:127:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:127:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:128:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:128:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:129:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:129:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:130:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 2);
              ^
eq.pass.cpp:130:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 2);
                 ^  ~~~~~~~
eq.pass.cpp:135:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:135:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:136:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:136:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:137:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:137:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:138:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 2);
              ^
eq.pass.cpp:138:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 2);
                 ^  ~~~~~~~~~
eq.pass.cpp:143:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:143:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:144:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:144:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:145:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:145:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:146:15: error: unknown type name 'T2'
        const T2 t2(1.1, 3, 3);
              ^
eq.pass.cpp:146:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 3, 3);
                 ^  ~~~~~~~~~
eq.pass.cpp:151:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
eq.pass.cpp:151:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
eq.pass.cpp:152:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
eq.pass.cpp:152:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
eq.pass.cpp:153:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
eq.pass.cpp:153:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
eq.pass.cpp:154:15: error: unknown type name 'T2'
        const T2 t2(1.1, 3, 2);
              ^
eq.pass.cpp:154:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 3, 2);
                 ^  ~~~~~~~~~
114 diagnostics generated.
eq.pass.cpp failed to compile
lt.pass.cpp:51:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T1;
                ~~~~~^
lt.pass.cpp:51:27: error: expected unqualified-id
        typedef std::tuple<> T1;
                          ^
lt.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T2;
                ~~~~~^
lt.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<> T2;
                          ^
lt.pass.cpp:53:15: error: unknown type name 'T1'
        const T1 t1;
              ^
lt.pass.cpp:54:15: error: unknown type name 'T2'
        const T2 t2;
              ^
lt.pass.cpp:61:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:61:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:63:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:64:15: error: unknown type name 'T2'
        const T2 t2(1);
              ^
lt.pass.cpp:71:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:71:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:72:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:72:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:73:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:74:15: error: unknown type name 'T2'
        const T2 t2(0.9);
              ^
lt.pass.cpp:81:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char> T1;
                ~~~~~^
lt.pass.cpp:81:27: error: expected unqualified-id
        typedef std::tuple<char> T1;
                          ^
lt.pass.cpp:82:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double> T2;
                ~~~~~^
lt.pass.cpp:82:27: error: expected unqualified-id
        typedef std::tuple<double> T2;
                          ^
lt.pass.cpp:83:15: error: unknown type name 'T1'
        const T1 t1(1);
              ^
lt.pass.cpp:84:15: error: unknown type name 'T2'
        const T2 t2(1.1);
              ^
lt.pass.cpp:91:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:91:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:92:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:92:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:93:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:93:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:94:15: error: unknown type name 'T2'
        const T2 t2(1, 2);
              ^
lt.pass.cpp:94:18: error: excess elements in scalar initializer
        const T2 t2(1, 2);
                 ^  ~~~~
lt.pass.cpp:101:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:101:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:102:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:102:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:103:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:103:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:104:15: error: unknown type name 'T2'
        const T2 t2(0.9, 2);
              ^
lt.pass.cpp:104:18: error: excess elements in scalar initializer
        const T2 t2(0.9, 2);
                 ^  ~~~~~~
lt.pass.cpp:111:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:111:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:112:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:112:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:113:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:113:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:114:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2);
              ^
lt.pass.cpp:114:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2);
                 ^  ~~~~~~
lt.pass.cpp:121:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:121:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:122:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:122:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:123:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:123:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:124:15: error: unknown type name 'T2'
        const T2 t2(1, 1);
              ^
lt.pass.cpp:124:18: error: excess elements in scalar initializer
        const T2 t2(1, 1);
                 ^  ~~~~
lt.pass.cpp:131:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T1;
                ~~~~~^
lt.pass.cpp:131:27: error: expected unqualified-id
        typedef std::tuple<char, int> T1;
                          ^
lt.pass.cpp:132:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char> T2;
                ~~~~~^
lt.pass.cpp:132:27: error: expected unqualified-id
        typedef std::tuple<double, char> T2;
                          ^
lt.pass.cpp:133:15: error: unknown type name 'T1'
        const T1 t1(1, 2);
              ^
lt.pass.cpp:133:18: error: excess elements in scalar initializer
        const T1 t1(1, 2);
                 ^  ~~~~
lt.pass.cpp:134:15: error: unknown type name 'T2'
        const T2 t2(1, 3);
              ^
lt.pass.cpp:134:18: error: excess elements in scalar initializer
        const T2 t2(1, 3);
                 ^  ~~~~
lt.pass.cpp:141:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:141:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:142:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:142:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:143:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:143:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:144:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 3);
              ^
lt.pass.cpp:144:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:151:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:151:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:152:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:152:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:153:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:153:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:154:15: error: unknown type name 'T2'
        const T2 t2(0.9, 2, 3);
              ^
lt.pass.cpp:154:18: error: excess elements in scalar initializer
        const T2 t2(0.9, 2, 3);
                 ^  ~~~~~~~~~
lt.pass.cpp:161:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:161:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:162:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:162:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:163:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:163:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:164:15: error: unknown type name 'T2'
        const T2 t2(1.1, 2, 3);
              ^
lt.pass.cpp:164:18: error: excess elements in scalar initializer
        const T2 t2(1.1, 2, 3);
                 ^  ~~~~~~~~~
lt.pass.cpp:171:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:171:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:172:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:172:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:173:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:173:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:174:15: error: unknown type name 'T2'
        const T2 t2(1, 1, 3);
              ^
lt.pass.cpp:174:18: error: excess elements in scalar initializer
        const T2 t2(1, 1, 3);
                 ^  ~~~~~~~
lt.pass.cpp:181:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:181:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:182:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:182:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:183:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:183:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:184:15: error: unknown type name 'T2'
        const T2 t2(1, 3, 3);
              ^
lt.pass.cpp:184:18: error: excess elements in scalar initializer
        const T2 t2(1, 3, 3);
                 ^  ~~~~~~~
lt.pass.cpp:191:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:191:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:192:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:192:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:193:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:193:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:194:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 2);
              ^
lt.pass.cpp:194:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 2);
                 ^  ~~~~~~~
lt.pass.cpp:201:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int, double> T1;
                ~~~~~^
lt.pass.cpp:201:27: error: expected unqualified-id
        typedef std::tuple<char, int, double> T1;
                          ^
lt.pass.cpp:202:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double, char, int> T2;
                ~~~~~^
lt.pass.cpp:202:27: error: expected unqualified-id
        typedef std::tuple<double, char, int> T2;
                          ^
lt.pass.cpp:203:15: error: unknown type name 'T1'
        const T1 t1(1, 2, 3);
              ^
lt.pass.cpp:203:18: error: excess elements in scalar initializer
        const T1 t1(1, 2, 3);
                 ^  ~~~~~~~
lt.pass.cpp:204:15: error: unknown type name 'T2'
        const T2 t2(1, 2, 4);
              ^
lt.pass.cpp:204:18: error: excess elements in scalar initializer
        const T2 t2(1, 2, 4);
                 ^  ~~~~~~~
120 diagnostics generated.
lt.pass.cpp failed to compile
failed 2 tests in /test/utilities/tuple/tuple.tuple/tuple.rel
non_member_swap.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
non_member_swap.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
non_member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t0;
        ^
non_member_swap.pass.cpp:41:9: error: use of undeclared identifier 'T'
        T t1;
        ^
non_member_swap.pass.cpp:42:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:45:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:45:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
non_member_swap.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
non_member_swap.pass.cpp:47:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
non_member_swap.pass.cpp:48:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
non_member_swap.pass.cpp:50:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:50:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:53:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:53:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
non_member_swap.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
non_member_swap.pass.cpp:55:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
non_member_swap.pass.cpp:56:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:57:21: note: instantiated from:
        assert(std::get<0>(t0) == 2);
               ~~~~~^
non_member_swap.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:58:21: note: instantiated from:
        assert(std::get<1>(t0) == 3);
               ~~~~~^
non_member_swap.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:59:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:60:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:60:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
non_member_swap.pass.cpp:63:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
non_member_swap.pass.cpp:63:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
non_member_swap.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
non_member_swap.pass.cpp:65:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(3), MoveOnly(4), MoveOnly(5));
        ^
non_member_swap.pass.cpp:66:14: error: use of undeclared identifier 't0'
        swap(t0, t1);
             ^
non_member_swap.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:67:21: note: instantiated from:
        assert(std::get<0>(t0) == 3);
               ~~~~~^
non_member_swap.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:68:21: note: instantiated from:
        assert(std::get<1>(t0) == 4);
               ~~~~~^
non_member_swap.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t0) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:69:21: note: instantiated from:
        assert(std::get<2>(t0) == 5);
               ~~~~~^
non_member_swap.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:70:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
non_member_swap.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:71:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
non_member_swap.pass.cpp:72:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
non_member_swap.pass.cpp:72:21: note: instantiated from:
        assert(std::get<2>(t1) == 2);
               ~~~~~^
32 diagnostics generated.
non_member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.special
member_swap.pass.cpp:38:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
member_swap.pass.cpp:38:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
member_swap.pass.cpp:39:9: error: use of undeclared identifier 'T'
        T t0;
        ^
member_swap.pass.cpp:40:9: error: use of undeclared identifier 'T'
        T t1;
        ^
member_swap.pass.cpp:41:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:41:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly> T;
                          ^
member_swap.pass.cpp:45:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0));
        ^
member_swap.pass.cpp:46:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(1));
        ^
member_swap.pass.cpp:47:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:47:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:48:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:48:21: note: instantiated from:
        assert(std::get<0>(t0) == 1);
               ~~~~~^
member_swap.pass.cpp:49:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:49:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:52:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:52:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly> T;
                          ^
member_swap.pass.cpp:53:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1));
        ^
member_swap.pass.cpp:54:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(2), MoveOnly(3));
        ^
member_swap.pass.cpp:55:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:55:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:56:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:56:21: note: instantiated from:
        assert(std::get<0>(t0) == 2);
               ~~~~~^
member_swap.pass.cpp:57:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:57:21: note: instantiated from:
        assert(std::get<1>(t0) == 3);
               ~~~~~^
member_swap.pass.cpp:58:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:58:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:59:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:59:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
member_swap.pass.cpp:62:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                ~~~~~^
member_swap.pass.cpp:62:27: error: expected unqualified-id
        typedef std::tuple<MoveOnly, MoveOnly, MoveOnly> T;
                          ^
member_swap.pass.cpp:63:9: error: use of undeclared identifier 'T'
        T t0(MoveOnly(0), MoveOnly(1), MoveOnly(2));
        ^
member_swap.pass.cpp:64:9: error: use of undeclared identifier 'T'
        T t1(MoveOnly(3), MoveOnly(4), MoveOnly(5));
        ^
member_swap.pass.cpp:65:9: error: use of undeclared identifier 't0'
        t0.swap(t1);
        ^
member_swap.pass.cpp:65:17: error: use of undeclared identifier 't1'
        t0.swap(t1);
                ^
member_swap.pass.cpp:66:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t0) == 3);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:66:21: note: instantiated from:
        assert(std::get<0>(t0) == 3);
               ~~~~~^
member_swap.pass.cpp:67:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t0) == 4);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:67:21: note: instantiated from:
        assert(std::get<1>(t0) == 4);
               ~~~~~^
member_swap.pass.cpp:68:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t0) == 5);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:68:21: note: instantiated from:
        assert(std::get<2>(t0) == 5);
               ~~~~~^
member_swap.pass.cpp:69:9: error: no member named 'get' in namespace 'std'
        assert(std::get<0>(t1) == 0);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:69:21: note: instantiated from:
        assert(std::get<0>(t1) == 0);
               ~~~~~^
member_swap.pass.cpp:70:9: error: no member named 'get' in namespace 'std'
        assert(std::get<1>(t1) == 1);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:70:21: note: instantiated from:
        assert(std::get<1>(t1) == 1);
               ~~~~~^
member_swap.pass.cpp:71:9: error: no member named 'get' in namespace 'std'
        assert(std::get<2>(t1) == 2);
        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~
member_swap.pass.cpp:71:21: note: instantiated from:
        assert(std::get<2>(t1) == 2);
               ~~~~~^
36 diagnostics generated.
member_swap.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.swap
uses_allocator.pass.cpp:39:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<> T;
                ~~~~~^
uses_allocator.pass.cpp:39:27: error: expected unqualified-id
        typedef std::tuple<> T;
                          ^
uses_allocator.pass.cpp:40:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:41:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:40:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:40:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:41:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:41:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:41:79: error: expected ')'
uses_allocator.pass.cpp:40:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:44:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<int> T;
                ~~~~~^
uses_allocator.pass.cpp:44:27: error: expected unqualified-id
        typedef std::tuple<int> T;
                          ^
uses_allocator.pass.cpp:45:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:45:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:45:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:46:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:45:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:45:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:46:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:46:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:46:79: error: expected ')'
uses_allocator.pass.cpp:45:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:49:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<char, int> T;
                ~~~~~^
uses_allocator.pass.cpp:49:27: error: expected unqualified-id
        typedef std::tuple<char, int> T;
                          ^
uses_allocator.pass.cpp:50:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:50:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:50:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:51:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:50:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:50:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:51:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:51:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:51:79: error: expected ')'
uses_allocator.pass.cpp:50:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
uses_allocator.pass.cpp:54:22: error: no type named 'tuple' in namespace 'std'
        typedef std::tuple<double&, char, int> T;
                ~~~~~^
uses_allocator.pass.cpp:54:27: error: expected unqualified-id
        typedef std::tuple<double&, char, int> T;
                          ^
uses_allocator.pass.cpp:55:9: error: use of undeclared identifier 'T'
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:60: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                           ^
uses_allocator.pass.cpp:55:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:55:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
uses_allocator.pass.cpp:56:73: note: instantiated from:
                                       std::uses_allocator<T, A>>::value), "");
                                                                        ^
uses_allocator.pass.cpp:55:9: error: type name requires a specifier or qualifier
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:55:9: error: C++ requires a type specifier for all declarations
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
uses_allocator.pass.cpp:56:79: error: type name requires a specifier or qualifier
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:56:79: error: C++ requires a type specifier for all declarations
                                       std::uses_allocator<T, A>>::value), "");
                                                                              ^
uses_allocator.pass.cpp:56:79: error: expected ')'
uses_allocator.pass.cpp:55:9: note: to match this '('
        static_assert((std::is_base_of<std::true_type,
        ^
In file included from uses_allocator.pass.cpp:31:
In file included from ../../../../../include/tuple:133:
../../../../../include/__yuga_config:142:41: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                        ^
44 diagnostics generated.
uses_allocator.pass.cpp failed to compile
failed 1 tests in /test/utilities/tuple/tuple.tuple/tuple.traits
passed 1 tests in /test/utilities/type.index
passed 5 tests in /test/utilities/type.index/type.index.members
passed 2 tests in /test/utilities/type.index/type.index.overview
passed 1 tests in /test/utilities/type.index/type.index.synopsis
passed 1 tests in /test/utilities/type.index/type.index.templ
passed 1 tests in /test/utilities/utilities.general
passed 1 tests in /test/utilities/utility
forward.pass.cpp:78:5: error: no matching function for call to 'forward'
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
forward.pass.cpp:78:31: note: instantiated from:
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
                              ^~~~~~~~~~~~~~~~~~~~~~
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:79:
In file included from ../../../../include/__tuple:39:
../../../../include/type_traits:1205:1: note: candidate function [with T = A const &, U = A] not viable: no known conversion from 'A' to 'A &' for 1st argument
forward(U& t)
^
../../../../include/type_traits:1217:1: note: candidate template ignored: failed template argument deduction
forward(U& t)
^
forward.pass.cpp:78:5: error: type name requires a specifier or qualifier
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:78:5: error: C++ requires a type specifier for all declarations
    static_assert(sizeof(test(std::forward<const A&>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:80:5: error: no matching function for call to 'forward'
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
forward.pass.cpp:80:31: note: instantiated from:
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
                              ^~~~~~~~~~~~~~~~~~~~~
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:79:
In file included from ../../../../include/__tuple:39:
../../../../include/type_traits:1205:1: note: candidate function [with T = A const, U = A] not viable: no known conversion from 'A' to 'A &' for 1st argument
forward(U& t)
^
../../../../include/type_traits:1217:1: note: candidate template ignored: failed template argument deduction
forward(U& t)
^
forward.pass.cpp:80:5: error: type name requires a specifier or qualifier
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
forward.pass.cpp:80:5: error: C++ requires a type specifier for all declarations
    static_assert(sizeof(test(std::forward<const A>(source()))) == 2, "");
    ^
In file included from forward.pass.cpp:26:
In file included from ../../../../include/utility:78:
../../../../include/__yuga_config:142:69: note: instantiated from:
    typedef __static_assert_check<sizeof(__static_assert_test<(__b)>)> \
                                                                    ^
10 diagnostics generated.
forward.pass.cpp failed to compile
failed 1 tests in /test/utilities/utility/forward
passed 13 tests in /test/utilities/utility/forward
passed 1 tests in /test/utilities/utility/operators
not implemented:  /test/utilities/utility/pairs
not implemented:  /test/utilities/utility/pairs/pair.astuple
not implemented:  /test/utilities/utility/pairs/pair.range
not implemented:  /test/utilities/utility/pairs/pairs.general
not implemented:  /test/utilities/utility/pairs/pairs.pair
passed 2 tests in /test/utilities/utility/utility.swap
passed 1 tests in /test/utilities/utility.requirements
passed 1 tests in /test/utilities/utility.requirements/allocator.requirements
passed 1 tests in /test/utilities/utility.requirements/utility.arg.requirements
****************************************************
Results for /test:
using clang version 1.5 (trunk 100008)
Target: x86_64-apple-darwin10
Thread model: posix
with -nostdinc++ -nodefaultlibs /usr/lib/libSystem.B.dylib -arch x86_64 -I../include /usr/lib/libc++.dylib
----------------------------------------------------
sections without tests   : 139
sections with failures   : 147
sections without failures: 747
                       +   ----
total number of sections : 1033
----------------------------------------------------
number of tests failed   : 561
number of tests passed   : 2736
                       +   ----
total number of tests    : 3297
****************************************************
